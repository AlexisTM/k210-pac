#![doc = "Peripheral access API for K210 microcontrollers (generated using svd2rust v0.14.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.14.0/svd2rust/#peripheral-api"]
#![deny(missing_docs)]
#![deny(warnings)]
#![allow(non_camel_case_types)]
#![no_std]
extern crate bare_metal;
extern crate riscv;
#[cfg(feature = "rt")]
extern crate riscv_rt;
extern crate vcell;
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = "Core Local Interruptor"]
pub struct CLINT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CLINT {}
impl CLINT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const clint::RegisterBlock {
        0x0200_0000 as *const _
    }
}
impl Deref for CLINT {
    type Target = clint::RegisterBlock;
    fn deref(&self) -> &clint::RegisterBlock {
        unsafe { &*CLINT::ptr() }
    }
}
#[doc = "Core Local Interruptor"]
pub mod clint {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Hart software interrupt register"]
        pub msip: [MSIP; 2],
        _reserved0: [u8; 16376usize],
        #[doc = "0x4000 - Hart time comparator register"]
        pub mtimecmp: [MTIMECMP; 2],
        _reserved1: [u8; 32744usize],
        #[doc = "0xbff8 - Timer register"]
        pub mtime: MTIME,
    }
    #[doc = "Hart software interrupt register"]
    pub struct MSIP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Hart software interrupt register"]
    pub mod msip {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSIP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Hart time comparator register"]
    pub struct MTIMECMP {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Hart time comparator register"]
    pub mod mtimecmp {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::MTIMECMP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Timer register"]
    pub struct MTIME {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Timer register"]
    pub mod mtime {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::MTIME {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Platform-Level Interrupt Controller"]
pub struct PLIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PLIC {}
impl PLIC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const plic::RegisterBlock {
        0x0c00_0000 as *const _
    }
}
impl Deref for PLIC {
    type Target = plic::RegisterBlock;
    fn deref(&self) -> &plic::RegisterBlock {
        unsafe { &*PLIC::ptr() }
    }
}
#[doc = "Platform-Level Interrupt Controller"]
pub mod plic {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Source Priority Register"]
        pub priority: [PRIORITY; 1024],
        #[doc = "0x1000 - Interrupt Pending Register"]
        pub pending: [PENDING; 32],
        _reserved0: [u8; 3968usize],
        #[doc = "0x2000 - Target Interrupt Enables"]
        pub target_enables: [TARGET_ENABLES; 4],
        _reserved1: [u8; 203415040usize],
        #[doc = "0xc200000 - Target Configuration"]
        pub targets0: TARGETS,
        _reserved2: [u8; 4088usize],
        #[doc = "0xc201000 - Target Configuration"]
        pub targets1: TARGETS,
        _reserved3: [u8; 4088usize],
        #[doc = "0xc202000 - Target Configuration"]
        pub targets2: TARGETS,
        _reserved4: [u8; 4088usize],
        #[doc = "0xc203000 - Target Configuration"]
        pub targets3: TARGETS,
    }
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct TARGET_ENABLES {
        #[doc = "0x00 - Interrupt Enable Register"]
        pub enable: [self::target_enables::ENABLE; 32],
    }
    #[doc = r" Register block"]
    #[doc = "Target Interrupt Enables"]
    pub mod target_enables {
        #[doc = "Interrupt Enable Register"]
        pub struct ENABLE {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Interrupt Enable Register"]
        pub mod enable {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::ENABLE {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
    }
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct TARGETS {
        #[doc = "0x00 - Priority Threshold Register"]
        pub threshold: self::targets::THRESHOLD,
        #[doc = "0x04 - Claim/Complete Register"]
        pub claim: self::targets::CLAIM,
    }
    #[doc = r" Register block"]
    #[doc = "Target Configuration"]
    pub mod targets {
        #[doc = "Priority Threshold Register"]
        pub struct THRESHOLD {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Priority Threshold Register"]
        pub mod threshold {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::THRESHOLD {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `priority`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PRIORITYR {
                #[doc = "Never interrupt"]
                NEVER,
                #[doc = "Priority 1"]
                P1,
                #[doc = "Priority 2"]
                P2,
                #[doc = "Priority 3"]
                P3,
                #[doc = "Priority 4"]
                P4,
                #[doc = "Priority 5"]
                P5,
                #[doc = "Priority 6"]
                P6,
                #[doc = "Priority 7"]
                P7,
            }
            impl PRIORITYR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        PRIORITYR::NEVER => 0,
                        PRIORITYR::P1 => 0x01,
                        PRIORITYR::P2 => 0x02,
                        PRIORITYR::P3 => 0x03,
                        PRIORITYR::P4 => 0x04,
                        PRIORITYR::P5 => 0x05,
                        PRIORITYR::P6 => 0x06,
                        PRIORITYR::P7 => 0x07,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> PRIORITYR {
                    match value {
                        0 => PRIORITYR::NEVER,
                        1 => PRIORITYR::P1,
                        2 => PRIORITYR::P2,
                        3 => PRIORITYR::P3,
                        4 => PRIORITYR::P4,
                        5 => PRIORITYR::P5,
                        6 => PRIORITYR::P6,
                        7 => PRIORITYR::P7,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `NEVER`"]
                #[inline]
                pub fn is_never(&self) -> bool {
                    *self == PRIORITYR::NEVER
                }
                #[doc = "Checks if the value of the field is `P1`"]
                #[inline]
                pub fn is_p1(&self) -> bool {
                    *self == PRIORITYR::P1
                }
                #[doc = "Checks if the value of the field is `P2`"]
                #[inline]
                pub fn is_p2(&self) -> bool {
                    *self == PRIORITYR::P2
                }
                #[doc = "Checks if the value of the field is `P3`"]
                #[inline]
                pub fn is_p3(&self) -> bool {
                    *self == PRIORITYR::P3
                }
                #[doc = "Checks if the value of the field is `P4`"]
                #[inline]
                pub fn is_p4(&self) -> bool {
                    *self == PRIORITYR::P4
                }
                #[doc = "Checks if the value of the field is `P5`"]
                #[inline]
                pub fn is_p5(&self) -> bool {
                    *self == PRIORITYR::P5
                }
                #[doc = "Checks if the value of the field is `P6`"]
                #[inline]
                pub fn is_p6(&self) -> bool {
                    *self == PRIORITYR::P6
                }
                #[doc = "Checks if the value of the field is `P7`"]
                #[inline]
                pub fn is_p7(&self) -> bool {
                    *self == PRIORITYR::P7
                }
            }
            #[doc = "Values that can be written to the field `priority`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PRIORITYW {
                #[doc = "Never interrupt"]
                NEVER,
                #[doc = "Priority 1"]
                P1,
                #[doc = "Priority 2"]
                P2,
                #[doc = "Priority 3"]
                P3,
                #[doc = "Priority 4"]
                P4,
                #[doc = "Priority 5"]
                P5,
                #[doc = "Priority 6"]
                P6,
                #[doc = "Priority 7"]
                P7,
            }
            impl PRIORITYW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        PRIORITYW::NEVER => 0,
                        PRIORITYW::P1 => 1,
                        PRIORITYW::P2 => 2,
                        PRIORITYW::P3 => 3,
                        PRIORITYW::P4 => 4,
                        PRIORITYW::P5 => 5,
                        PRIORITYW::P6 => 6,
                        PRIORITYW::P7 => 7,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _PRIORITYW<'a> {
                w: &'a mut W,
            }
            impl<'a> _PRIORITYW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: PRIORITYW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Never interrupt"]
                #[inline]
                pub fn never(self) -> &'a mut W {
                    self.variant(PRIORITYW::NEVER)
                }
                #[doc = "Priority 1"]
                #[inline]
                pub fn p1(self) -> &'a mut W {
                    self.variant(PRIORITYW::P1)
                }
                #[doc = "Priority 2"]
                #[inline]
                pub fn p2(self) -> &'a mut W {
                    self.variant(PRIORITYW::P2)
                }
                #[doc = "Priority 3"]
                #[inline]
                pub fn p3(self) -> &'a mut W {
                    self.variant(PRIORITYW::P3)
                }
                #[doc = "Priority 4"]
                #[inline]
                pub fn p4(self) -> &'a mut W {
                    self.variant(PRIORITYW::P4)
                }
                #[doc = "Priority 5"]
                #[inline]
                pub fn p5(self) -> &'a mut W {
                    self.variant(PRIORITYW::P5)
                }
                #[doc = "Priority 6"]
                #[inline]
                pub fn p6(self) -> &'a mut W {
                    self.variant(PRIORITYW::P6)
                }
                #[doc = "Priority 7"]
                #[inline]
                pub fn p7(self) -> &'a mut W {
                    self.variant(PRIORITYW::P7)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:2"]
                #[inline]
                pub fn priority(&self) -> PRIORITYR {
                    PRIORITYR::_from({
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:2"]
                #[inline]
                pub fn priority(&mut self) -> _PRIORITYW {
                    _PRIORITYW { w: self }
                }
            }
        }
        #[doc = "Claim/Complete Register"]
        pub struct CLAIM {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Claim/Complete Register"]
        pub mod claim {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::CLAIM {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
    }
    #[doc = "Interrupt Source Priority Register"]
    pub struct PRIORITY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Source Priority Register"]
    pub mod priority {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRIORITY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Pending Register"]
    pub struct PENDING {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Pending Register"]
    pub mod pending {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PENDING {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "High-speed UART"]
pub struct UARTHS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UARTHS {}
impl UARTHS {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uarths::RegisterBlock {
        0x3800_0000 as *const _
    }
}
impl Deref for UARTHS {
    type Target = uarths::RegisterBlock;
    fn deref(&self) -> &uarths::RegisterBlock {
        unsafe { &*UARTHS::ptr() }
    }
}
#[doc = "High-speed UART"]
pub mod uarths {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Transmit Data Register"]
        pub txdata: TXDATA,
        #[doc = "0x04 - Receive Data Register"]
        pub rxdata: RXDATA,
        #[doc = "0x08 - Transmit Control Register"]
        pub txctrl: TXCTRL,
        #[doc = "0x0c - Receive Control Register"]
        pub rxctrl: RXCTRL,
        #[doc = "0x10 - Interrupt Enable Register"]
        pub ie: IE,
        #[doc = "0x14 - Interrupt Pending Register"]
        pub ip: IP,
        #[doc = "0x18 - Baud Rate Divisor Register"]
        pub div: DIV,
    }
    #[doc = "Transmit Data Register"]
    pub struct TXDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit Data Register"]
    pub mod txdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FULLR {
            bits: bool,
        }
        impl FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FULLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FULLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Transmit data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
            #[doc = "Bit 31 - Transmit FIFO full"]
            #[inline]
            pub fn full(&self) -> FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FULLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Transmit data"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
            #[doc = "Bit 31 - Transmit FIFO full"]
            #[inline]
            pub fn full(&mut self) -> _FULLW {
                _FULLW { w: self }
            }
        }
    }
    #[doc = "Receive Data Register"]
    pub struct RXDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive Data Register"]
    pub mod rxdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXDATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTYR {
            bits: bool,
        }
        impl EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Received data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
            #[doc = "Bit 31 - Receive FIFO empty"]
            #[inline]
            pub fn empty(&self) -> EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EMPTYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Received data"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
            #[doc = "Bit 31 - Receive FIFO empty"]
            #[inline]
            pub fn empty(&mut self) -> _EMPTYW {
                _EMPTYW { w: self }
            }
        }
    }
    #[doc = "Transmit Control Register"]
    pub struct TXCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit Control Register"]
    pub mod txctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXENR {
            bits: bool,
        }
        impl TXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NSTOPR {
            bits: bool,
        }
        impl NSTOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXCNTR {
            bits: u8,
        }
        impl TXCNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NSTOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NSTOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXCNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXCNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmit enable"]
            #[inline]
            pub fn txen(&self) -> TXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXENR { bits }
            }
            #[doc = "Bit 1 - Number of stop bits"]
            #[inline]
            pub fn nstop(&self) -> NSTOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NSTOPR { bits }
            }
            #[doc = "Bits 16:18 - Transmit watermark level"]
            #[inline]
            pub fn txcnt(&self) -> TXCNTR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TXCNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transmit enable"]
            #[inline]
            pub fn txen(&mut self) -> _TXENW {
                _TXENW { w: self }
            }
            #[doc = "Bit 1 - Number of stop bits"]
            #[inline]
            pub fn nstop(&mut self) -> _NSTOPW {
                _NSTOPW { w: self }
            }
            #[doc = "Bits 16:18 - Transmit watermark level"]
            #[inline]
            pub fn txcnt(&mut self) -> _TXCNTW {
                _TXCNTW { w: self }
            }
        }
    }
    #[doc = "Receive Control Register"]
    pub struct RXCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive Control Register"]
    pub mod rxctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXENR {
            bits: bool,
        }
        impl RXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXCNTR {
            bits: u8,
        }
        impl RXCNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXCNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXCNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receive enable"]
            #[inline]
            pub fn rxen(&self) -> RXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXENR { bits }
            }
            #[doc = "Bits 16:18 - Receive watermark level"]
            #[inline]
            pub fn rxcnt(&self) -> RXCNTR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXCNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receive enable"]
            #[inline]
            pub fn rxen(&mut self) -> _RXENW {
                _RXENW { w: self }
            }
            #[doc = "Bits 16:18 - Receive watermark level"]
            #[inline]
            pub fn rxcnt(&mut self) -> _RXCNTW {
                _RXCNTW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Register"]
    pub struct IE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Register"]
    pub mod ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXWMR {
            bits: bool,
        }
        impl TXWMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXWMR {
            bits: bool,
        }
        impl RXWMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXWMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXWMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXWMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXWMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmit watermark interrupt enable"]
            #[inline]
            pub fn txwm(&self) -> TXWMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXWMR { bits }
            }
            #[doc = "Bit 1 - Receive watermark interrupt enable"]
            #[inline]
            pub fn rxwm(&self) -> RXWMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXWMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transmit watermark interrupt enable"]
            #[inline]
            pub fn txwm(&mut self) -> _TXWMW {
                _TXWMW { w: self }
            }
            #[doc = "Bit 1 - Receive watermark interrupt enable"]
            #[inline]
            pub fn rxwm(&mut self) -> _RXWMW {
                _RXWMW { w: self }
            }
        }
    }
    #[doc = "Interrupt Pending Register"]
    pub struct IP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Pending Register"]
    pub mod ip {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXWMR {
            bits: bool,
        }
        impl TXWMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXWMR {
            bits: bool,
        }
        impl RXWMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXWMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXWMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXWMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXWMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmit watermark interrupt pending"]
            #[inline]
            pub fn txwm(&self) -> TXWMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXWMR { bits }
            }
            #[doc = "Bit 1 - Receive watermark interrupt pending"]
            #[inline]
            pub fn rxwm(&self) -> RXWMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXWMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transmit watermark interrupt pending"]
            #[inline]
            pub fn txwm(&mut self) -> _TXWMW {
                _TXWMW { w: self }
            }
            #[doc = "Bit 1 - Receive watermark interrupt pending"]
            #[inline]
            pub fn rxwm(&mut self) -> _RXWMW {
                _RXWMW { w: self }
            }
        }
    }
    #[doc = "Baud Rate Divisor Register"]
    pub struct DIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud Rate Divisor Register"]
    pub mod div {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u16,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Baud rate divisor"]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Baud rate divisor"]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
}
#[doc = "High-speed GPIO"]
pub struct GPIOHS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOHS {}
impl GPIOHS {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpiohs::RegisterBlock {
        0x3800_1000 as *const _
    }
}
impl Deref for GPIOHS {
    type Target = gpiohs::RegisterBlock;
    fn deref(&self) -> &gpiohs::RegisterBlock {
        unsafe { &*GPIOHS::ptr() }
    }
}
#[doc = "High-speed GPIO"]
pub mod gpiohs {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Input Value Register"]
        pub input_val: INPUT_VAL,
        #[doc = "0x04 - Pin Input Enable Register"]
        pub input_en: INPUT_EN,
        #[doc = "0x08 - Pin Output Enable Register"]
        pub output_en: OUTPUT_EN,
        #[doc = "0x0c - Output Value Register"]
        pub output_val: OUTPUT_VAL,
        #[doc = "0x10 - Internal Pull-Up Enable Register"]
        pub pullup_en: PULLUP_EN,
        #[doc = "0x14 - Drive Strength Register"]
        pub drive: DRIVE,
        #[doc = "0x18 - Rise Interrupt Enable Register"]
        pub rise_ie: RISE_IE,
        #[doc = "0x1c - Rise Interrupt Pending Register"]
        pub rise_ip: RISE_IP,
        #[doc = "0x20 - Fall Interrupt Enable Register"]
        pub fall_ie: FALL_IE,
        #[doc = "0x24 - Fall Interrupt Pending Register"]
        pub fall_ip: FALL_IP,
        #[doc = "0x28 - High Interrupt Enable Register"]
        pub high_ie: HIGH_IE,
        #[doc = "0x2c - High Interrupt Pending Register"]
        pub high_ip: HIGH_IP,
        #[doc = "0x30 - Low Interrupt Enable Register"]
        pub low_ie: LOW_IE,
        #[doc = "0x34 - Low Interrupt Pending Register"]
        pub low_ip: LOW_IP,
        #[doc = "0x38 - HW I/O Function Enable Register"]
        pub iof_en: IOF_EN,
        #[doc = "0x3c - HW I/O Function Select Register"]
        pub iof_sel: IOF_SEL,
        #[doc = "0x40 - Output XOR (invert) Register"]
        pub output_xor: OUTPUT_XOR,
    }
    #[doc = "Input Value Register"]
    pub struct INPUT_VAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Input Value Register"]
    pub mod input_val {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INPUT_VAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Pin Input Enable Register"]
    pub struct INPUT_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin Input Enable Register"]
    pub mod input_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INPUT_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Pin Output Enable Register"]
    pub struct OUTPUT_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Pin Output Enable Register"]
    pub mod output_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUT_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Output Value Register"]
    pub struct OUTPUT_VAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Output Value Register"]
    pub mod output_val {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUT_VAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Internal Pull-Up Enable Register"]
    pub struct PULLUP_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Internal Pull-Up Enable Register"]
    pub mod pullup_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PULLUP_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Drive Strength Register"]
    pub struct DRIVE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Drive Strength Register"]
    pub mod drive {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DRIVE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Rise Interrupt Enable Register"]
    pub struct RISE_IE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Rise Interrupt Enable Register"]
    pub mod rise_ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RISE_IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Rise Interrupt Pending Register"]
    pub struct RISE_IP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Rise Interrupt Pending Register"]
    pub mod rise_ip {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RISE_IP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Fall Interrupt Enable Register"]
    pub struct FALL_IE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Fall Interrupt Enable Register"]
    pub mod fall_ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FALL_IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Fall Interrupt Pending Register"]
    pub struct FALL_IP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Fall Interrupt Pending Register"]
    pub mod fall_ip {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FALL_IP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "High Interrupt Enable Register"]
    pub struct HIGH_IE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "High Interrupt Enable Register"]
    pub mod high_ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::HIGH_IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "High Interrupt Pending Register"]
    pub struct HIGH_IP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "High Interrupt Pending Register"]
    pub mod high_ip {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::HIGH_IP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Low Interrupt Enable Register"]
    pub struct LOW_IE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Low Interrupt Enable Register"]
    pub mod low_ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LOW_IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Low Interrupt Pending Register"]
    pub struct LOW_IP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Low Interrupt Pending Register"]
    pub mod low_ip {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LOW_IP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "HW I/O Function Enable Register"]
    pub struct IOF_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "HW I/O Function Enable Register"]
    pub mod iof_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOF_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "HW I/O Function Select Register"]
    pub struct IOF_SEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "HW I/O Function Select Register"]
    pub mod iof_sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOF_SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Output XOR (invert) Register"]
    pub struct OUTPUT_XOR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Output XOR (invert) Register"]
    pub mod output_xor {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUT_XOR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN8R {
            bits: bool,
        }
        impl PIN8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN9R {
            bits: bool,
        }
        impl PIN9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN10R {
            bits: bool,
        }
        impl PIN10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN11R {
            bits: bool,
        }
        impl PIN11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN12R {
            bits: bool,
        }
        impl PIN12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN13R {
            bits: bool,
        }
        impl PIN13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN14R {
            bits: bool,
        }
        impl PIN14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN15R {
            bits: bool,
        }
        impl PIN15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN16R {
            bits: bool,
        }
        impl PIN16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN17R {
            bits: bool,
        }
        impl PIN17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN18R {
            bits: bool,
        }
        impl PIN18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN19R {
            bits: bool,
        }
        impl PIN19R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN20R {
            bits: bool,
        }
        impl PIN20R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN21R {
            bits: bool,
        }
        impl PIN21R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN22R {
            bits: bool,
        }
        impl PIN22R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN23R {
            bits: bool,
        }
        impl PIN23R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN24R {
            bits: bool,
        }
        impl PIN24R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN25R {
            bits: bool,
        }
        impl PIN25R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN26R {
            bits: bool,
        }
        impl PIN26R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN27R {
            bits: bool,
        }
        impl PIN27R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN28R {
            bits: bool,
        }
        impl PIN28R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN29R {
            bits: bool,
        }
        impl PIN29R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN30R {
            bits: bool,
        }
        impl PIN30R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN31R {
            bits: bool,
        }
        impl PIN31R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN8R { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN9R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN10R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN11R { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN12R { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN13R { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN14R { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN15R { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN16R { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN17R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN18R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN19R { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN20R { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN21R { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN22R { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN23R { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN24R { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN25R { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN26R { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN27R { bits }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN28R { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN29R { bits }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN30R { bits }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN31R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28"]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30"]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31"]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
}
#[doc = "Neural Network Accelerator"]
pub struct KPU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KPU {}
impl KPU {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const kpu::RegisterBlock {
        0x4080_0000 as *const _
    }
}
impl Deref for KPU {
    type Target = kpu::RegisterBlock;
    fn deref(&self) -> &kpu::RegisterBlock {
        unsafe { &*KPU::ptr() }
    }
}
#[doc = "Neural Network Accelerator"]
pub mod kpu {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Layer arguments FIFO: each layer is defined by writing 12 successive argument values to this register"]
        pub layer_argument_fifo: LAYER_ARGUMENT_FIFO,
        #[doc = "0x08 - Interrupt status"]
        pub interrupt_status: INTERRUPT_STATUS,
        #[doc = "0x10 - Interrupt raw"]
        pub interrupt_raw: INTERRUPT_RAW,
        #[doc = "0x18 - Interrupt mask: 0 enables the interrupt, 1 masks the interrupt"]
        pub interrupt_mask: INTERRUPT_MASK,
        #[doc = "0x20 - Interrupt clear: write 1 to a bit to clear interrupt"]
        pub interrupt_clear: INTERRUPT_CLEAR,
        #[doc = "0x28 - FIFO threshold"]
        pub fifo_threshold: FIFO_THRESHOLD,
        #[doc = "0x30 - FIFO data output"]
        pub fifo_data_out: FIFO_DATA_OUT,
        #[doc = "0x38 - FIFO control"]
        pub fifo_ctrl: FIFO_CTRL,
        #[doc = "0x40 - Eight bit mode"]
        pub eight_bit_mode: EIGHT_BIT_MODE,
    }
    #[doc = "Layer arguments FIFO: each layer is defined by writing 12 successive argument values to this register"]
    pub struct LAYER_ARGUMENT_FIFO {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Layer arguments FIFO: each layer is defined by writing 12 successive argument values to this register"]
    pub mod layer_argument_fifo {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::LAYER_ARGUMENT_FIFO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt status"]
    pub struct INTERRUPT_STATUS {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Interrupt status"]
    pub mod interrupt_status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTERRUPT_STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALC_DONER {
            bits: bool,
        }
        impl CALC_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LAYER_CFG_ALMOST_EMPTYR {
            bits: bool,
        }
        impl LAYER_CFG_ALMOST_EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LAYER_CFG_ALMOST_FULLR {
            bits: bool,
        }
        impl LAYER_CFG_ALMOST_FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALC_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALC_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LAYER_CFG_ALMOST_EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LAYER_CFG_ALMOST_EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LAYER_CFG_ALMOST_FULLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LAYER_CFG_ALMOST_FULLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline]
            pub fn calc_done(&self) -> CALC_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CALC_DONER { bits }
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline]
            pub fn layer_cfg_almost_empty(&self) -> LAYER_CFG_ALMOST_EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                LAYER_CFG_ALMOST_EMPTYR { bits }
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline]
            pub fn layer_cfg_almost_full(&self) -> LAYER_CFG_ALMOST_FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                LAYER_CFG_ALMOST_FULLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline]
            pub fn calc_done(&mut self) -> _CALC_DONEW {
                _CALC_DONEW { w: self }
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline]
            pub fn layer_cfg_almost_empty(&mut self) -> _LAYER_CFG_ALMOST_EMPTYW {
                _LAYER_CFG_ALMOST_EMPTYW { w: self }
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline]
            pub fn layer_cfg_almost_full(&mut self) -> _LAYER_CFG_ALMOST_FULLW {
                _LAYER_CFG_ALMOST_FULLW { w: self }
            }
        }
    }
    #[doc = "Interrupt raw"]
    pub struct INTERRUPT_RAW {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Interrupt raw"]
    pub mod interrupt_raw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTERRUPT_RAW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt mask: 0 enables the interrupt, 1 masks the interrupt"]
    pub struct INTERRUPT_MASK {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Interrupt mask: 0 enables the interrupt, 1 masks the interrupt"]
    pub mod interrupt_mask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTERRUPT_MASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt clear: write 1 to a bit to clear interrupt"]
    pub struct INTERRUPT_CLEAR {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Interrupt clear: write 1 to a bit to clear interrupt"]
    pub mod interrupt_clear {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTERRUPT_CLEAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "FIFO threshold"]
    pub struct FIFO_THRESHOLD {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FIFO threshold"]
    pub mod fifo_threshold {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::FIFO_THRESHOLD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FULL_THRESHOLDR {
            bits: u8,
        }
        impl FULL_THRESHOLDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EMPTY_THRESHOLDR {
            bits: u8,
        }
        impl EMPTY_THRESHOLDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FULL_THRESHOLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FULL_THRESHOLDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMPTY_THRESHOLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMPTY_THRESHOLDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bits 0:3 - FIFO full threshold"]
            #[inline]
            pub fn full_threshold(&self) -> FULL_THRESHOLDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) as u8
                };
                FULL_THRESHOLDR { bits }
            }
            #[doc = "Bits 4:7 - FIFO empty threshold"]
            #[inline]
            pub fn empty_threshold(&self) -> EMPTY_THRESHOLDR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u64) as u8
                };
                EMPTY_THRESHOLDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - FIFO full threshold"]
            #[inline]
            pub fn full_threshold(&mut self) -> _FULL_THRESHOLDW {
                _FULL_THRESHOLDW { w: self }
            }
            #[doc = "Bits 4:7 - FIFO empty threshold"]
            #[inline]
            pub fn empty_threshold(&mut self) -> _EMPTY_THRESHOLDW {
                _EMPTY_THRESHOLDW { w: self }
            }
        }
    }
    #[doc = "FIFO data output"]
    pub struct FIFO_DATA_OUT {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FIFO data output"]
    pub mod fifo_data_out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::FIFO_DATA_OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "FIFO control"]
    pub struct FIFO_CTRL {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FIFO control"]
    pub mod fifo_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::FIFO_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_FIFO_FLUSH_NR {
            bits: bool,
        }
        impl DMA_FIFO_FLUSH_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GS_FIFO_FLUSH_NR {
            bits: bool,
        }
        impl GS_FIFO_FLUSH_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CFG_FIFO_FLUSH_NR {
            bits: bool,
        }
        impl CFG_FIFO_FLUSH_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMD_FIFO_FLUSH_NR {
            bits: bool,
        }
        impl CMD_FIFO_FLUSH_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESP_FIFO_FLUSH_NR {
            bits: bool,
        }
        impl RESP_FIFO_FLUSH_NR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_FIFO_FLUSH_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_FIFO_FLUSH_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GS_FIFO_FLUSH_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GS_FIFO_FLUSH_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG_FIFO_FLUSH_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG_FIFO_FLUSH_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMD_FIFO_FLUSH_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMD_FIFO_FLUSH_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESP_FIFO_FLUSH_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESP_FIFO_FLUSH_NW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Flush DMA FIFO"]
            #[inline]
            pub fn dma_fifo_flush_n(&self) -> DMA_FIFO_FLUSH_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                DMA_FIFO_FLUSH_NR { bits }
            }
            #[doc = "Bit 1 - Flush GS FIFO"]
            #[inline]
            pub fn gs_fifo_flush_n(&self) -> GS_FIFO_FLUSH_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                GS_FIFO_FLUSH_NR { bits }
            }
            #[doc = "Bit 2 - Flush configuration FIFO"]
            #[inline]
            pub fn cfg_fifo_flush_n(&self) -> CFG_FIFO_FLUSH_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CFG_FIFO_FLUSH_NR { bits }
            }
            #[doc = "Bit 3 - Flush command FIFO"]
            #[inline]
            pub fn cmd_fifo_flush_n(&self) -> CMD_FIFO_FLUSH_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CMD_FIFO_FLUSH_NR { bits }
            }
            #[doc = "Bit 4 - Flush response FIFO"]
            #[inline]
            pub fn resp_fifo_flush_n(&self) -> RESP_FIFO_FLUSH_NR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                RESP_FIFO_FLUSH_NR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Flush DMA FIFO"]
            #[inline]
            pub fn dma_fifo_flush_n(&mut self) -> _DMA_FIFO_FLUSH_NW {
                _DMA_FIFO_FLUSH_NW { w: self }
            }
            #[doc = "Bit 1 - Flush GS FIFO"]
            #[inline]
            pub fn gs_fifo_flush_n(&mut self) -> _GS_FIFO_FLUSH_NW {
                _GS_FIFO_FLUSH_NW { w: self }
            }
            #[doc = "Bit 2 - Flush configuration FIFO"]
            #[inline]
            pub fn cfg_fifo_flush_n(&mut self) -> _CFG_FIFO_FLUSH_NW {
                _CFG_FIFO_FLUSH_NW { w: self }
            }
            #[doc = "Bit 3 - Flush command FIFO"]
            #[inline]
            pub fn cmd_fifo_flush_n(&mut self) -> _CMD_FIFO_FLUSH_NW {
                _CMD_FIFO_FLUSH_NW { w: self }
            }
            #[doc = "Bit 4 - Flush response FIFO"]
            #[inline]
            pub fn resp_fifo_flush_n(&mut self) -> _RESP_FIFO_FLUSH_NW {
                _RESP_FIFO_FLUSH_NW { w: self }
            }
        }
    }
    #[doc = "Eight bit mode"]
    pub struct EIGHT_BIT_MODE {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Eight bit mode"]
    pub mod eight_bit_mode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::EIGHT_BIT_MODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EIGHT_BIT_MODER {
            bits: bool,
        }
        impl EIGHT_BIT_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EIGHT_BIT_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EIGHT_BIT_MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Use 8-bit instead of 16-bit precision if set"]
            #[inline]
            pub fn eight_bit_mode(&self) -> EIGHT_BIT_MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                EIGHT_BIT_MODER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Use 8-bit instead of 16-bit precision if set"]
            #[inline]
            pub fn eight_bit_mode(&mut self) -> _EIGHT_BIT_MODEW {
                _EIGHT_BIT_MODEW { w: self }
            }
        }
    }
}
#[doc = "Fast Fourier Transform Accelerator"]
pub struct FFT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FFT {}
impl FFT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const fft::RegisterBlock {
        0x4200_0000 as *const _
    }
}
impl Deref for FFT {
    type Target = fft::RegisterBlock;
    fn deref(&self) -> &fft::RegisterBlock {
        unsafe { &*FFT::ptr() }
    }
}
#[doc = "Fast Fourier Transform Accelerator"]
pub mod fft {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - FFT input data fifo"]
        pub input_fifo: INPUT_FIFO,
        #[doc = "0x08 - FFT control register"]
        pub ctrl: CTRL,
        #[doc = "0x10 - FIFO control"]
        pub fifo_ctrl: FIFO_CTRL,
        #[doc = "0x18 - intr_mask"]
        pub interruptmask: INTERRUPTMASK,
        #[doc = "0x20 - Interrupt clear"]
        pub intr_clear: INTR_CLEAR,
        #[doc = "0x28 - FFT status register"]
        pub status: STATUS,
        #[doc = "0x30 - FFT status raw"]
        pub status_raw: STATUS_RAW,
        #[doc = "0x38 - FFT output FIFO"]
        pub output_fifo: OUTPUT_FIFO,
    }
    #[doc = "FFT input data fifo"]
    pub struct INPUT_FIFO {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FFT input data fifo"]
    pub mod input_fifo {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INPUT_FIFO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "FFT control register"]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FFT control register"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `point`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POINTR {
            #[doc = "512 point"]
            P512,
            #[doc = "256 point"]
            P256,
            #[doc = "128 point"]
            P128,
            #[doc = "64 point"]
            P64,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl POINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    POINTR::P512 => 0,
                    POINTR::P256 => 0x01,
                    POINTR::P128 => 0x02,
                    POINTR::P64 => 0x03,
                    POINTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> POINTR {
                match value {
                    0 => POINTR::P512,
                    1 => POINTR::P256,
                    2 => POINTR::P128,
                    3 => POINTR::P64,
                    i => POINTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `P512`"]
            #[inline]
            pub fn is_p512(&self) -> bool {
                *self == POINTR::P512
            }
            #[doc = "Checks if the value of the field is `P256`"]
            #[inline]
            pub fn is_p256(&self) -> bool {
                *self == POINTR::P256
            }
            #[doc = "Checks if the value of the field is `P128`"]
            #[inline]
            pub fn is_p128(&self) -> bool {
                *self == POINTR::P128
            }
            #[doc = "Checks if the value of the field is `P64`"]
            #[inline]
            pub fn is_p64(&self) -> bool {
                *self == POINTR::P64
            }
        }
        #[doc = "Possible values of the field `mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "FFT mode"]
            FFT,
            #[doc = "Inverse FFT mode"]
            IFFT,
        }
        impl MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MODER::FFT => false,
                    MODER::IFFT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MODER {
                match value {
                    false => MODER::FFT,
                    true => MODER::IFFT,
                }
            }
            #[doc = "Checks if the value of the field is `FFT`"]
            #[inline]
            pub fn is_fft(&self) -> bool {
                *self == MODER::FFT
            }
            #[doc = "Checks if the value of the field is `IFFT`"]
            #[inline]
            pub fn is_ifft(&self) -> bool {
                *self == MODER::IFFT
            }
        }
        #[doc = r" Value of the field"]
        pub struct SHIFTR {
            bits: u16,
        }
        impl SHIFTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_SENDR {
            bits: bool,
        }
        impl DMA_SENDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `input_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INPUT_MODER {
            #[doc = "RIRI (real imaginary interleaved)"]
            RIRI,
            #[doc = "RRRR (only real part)"]
            RRRR,
            #[doc = "First input the real part and then input the imaginary part"]
            RRII,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl INPUT_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    INPUT_MODER::RIRI => 0,
                    INPUT_MODER::RRRR => 0x01,
                    INPUT_MODER::RRII => 0x02,
                    INPUT_MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> INPUT_MODER {
                match value {
                    0 => INPUT_MODER::RIRI,
                    1 => INPUT_MODER::RRRR,
                    2 => INPUT_MODER::RRII,
                    i => INPUT_MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RIRI`"]
            #[inline]
            pub fn is_riri(&self) -> bool {
                *self == INPUT_MODER::RIRI
            }
            #[doc = "Checks if the value of the field is `RRRR`"]
            #[inline]
            pub fn is_rrrr(&self) -> bool {
                *self == INPUT_MODER::RRRR
            }
            #[doc = "Checks if the value of the field is `RRII`"]
            #[inline]
            pub fn is_rrii(&self) -> bool {
                *self == INPUT_MODER::RRII
            }
        }
        #[doc = "Possible values of the field `data_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_MODER {
            #[doc = "64 bit effective"]
            WIDTH_64,
            #[doc = "128 bit effective"]
            WIDTH_128,
        }
        impl DATA_MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DATA_MODER::WIDTH_64 => false,
                    DATA_MODER::WIDTH_128 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DATA_MODER {
                match value {
                    false => DATA_MODER::WIDTH_64,
                    true => DATA_MODER::WIDTH_128,
                }
            }
            #[doc = "Checks if the value of the field is `WIDTH_64`"]
            #[inline]
            pub fn is_width_64(&self) -> bool {
                *self == DATA_MODER::WIDTH_64
            }
            #[doc = "Checks if the value of the field is `WIDTH_128`"]
            #[inline]
            pub fn is_width_128(&self) -> bool {
                *self == DATA_MODER::WIDTH_128
            }
        }
        #[doc = "Values that can be written to the field `point`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POINTW {
            #[doc = "512 point"]
            P512,
            #[doc = "256 point"]
            P256,
            #[doc = "128 point"]
            P128,
            #[doc = "64 point"]
            P64,
        }
        impl POINTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    POINTW::P512 => 0,
                    POINTW::P256 => 1,
                    POINTW::P128 => 2,
                    POINTW::P64 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POINTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POINTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "512 point"]
            #[inline]
            pub fn p512(self) -> &'a mut W {
                self.variant(POINTW::P512)
            }
            #[doc = "256 point"]
            #[inline]
            pub fn p256(self) -> &'a mut W {
                self.variant(POINTW::P256)
            }
            #[doc = "128 point"]
            #[inline]
            pub fn p128(self) -> &'a mut W {
                self.variant(POINTW::P128)
            }
            #[doc = "64 point"]
            #[inline]
            pub fn p64(self) -> &'a mut W {
                self.variant(POINTW::P64)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODEW {
            #[doc = "FFT mode"]
            FFT,
            #[doc = "Inverse FFT mode"]
            IFFT,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MODEW::FFT => false,
                    MODEW::IFFT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "FFT mode"]
            #[inline]
            pub fn fft(self) -> &'a mut W {
                self.variant(MODEW::FFT)
            }
            #[doc = "Inverse FFT mode"]
            #[inline]
            pub fn ifft(self) -> &'a mut W {
                self.variant(MODEW::IFFT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SHIFTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SHIFTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_SENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SENDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `input_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INPUT_MODEW {
            #[doc = "RIRI (real imaginary interleaved)"]
            RIRI,
            #[doc = "RRRR (only real part)"]
            RRRR,
            #[doc = "First input the real part and then input the imaginary part"]
            RRII,
        }
        impl INPUT_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INPUT_MODEW::RIRI => 0,
                    INPUT_MODEW::RRRR => 1,
                    INPUT_MODEW::RRII => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPUT_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUT_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INPUT_MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "RIRI (real imaginary interleaved)"]
            #[inline]
            pub fn riri(self) -> &'a mut W {
                self.variant(INPUT_MODEW::RIRI)
            }
            #[doc = "RRRR (only real part)"]
            #[inline]
            pub fn rrrr(self) -> &'a mut W {
                self.variant(INPUT_MODEW::RRRR)
            }
            #[doc = "First input the real part and then input the imaginary part"]
            #[inline]
            pub fn rrii(self) -> &'a mut W {
                self.variant(INPUT_MODEW::RRII)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `data_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_MODEW {
            #[doc = "64 bit effective"]
            WIDTH_64,
            #[doc = "128 bit effective"]
            WIDTH_128,
        }
        impl DATA_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DATA_MODEW::WIDTH_64 => false,
                    DATA_MODEW::WIDTH_128 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DATA_MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "64 bit effective"]
            #[inline]
            pub fn width_64(self) -> &'a mut W {
                self.variant(DATA_MODEW::WIDTH_64)
            }
            #[doc = "128 bit effective"]
            #[inline]
            pub fn width_128(self) -> &'a mut W {
                self.variant(DATA_MODEW::WIDTH_128)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bits 0:2 - FFT calculation data length"]
            #[inline]
            pub fn point(&self) -> POINTR {
                POINTR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) as u8
                })
            }
            #[doc = "Bit 3 - FFT mode"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                })
            }
            #[doc = "Bits 4:12 - Corresponding to the nine layer butterfly shift operation, 0x0: does not shift; 0x1: shift 1st layer. ..."]
            #[inline]
            pub fn shift(&self) -> SHIFTR {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u64) as u16
                };
                SHIFTR { bits }
            }
            #[doc = "Bit 13 - FFT enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 14 - FFT DMA enable"]
            #[inline]
            pub fn dma_send(&self) -> DMA_SENDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                DMA_SENDR { bits }
            }
            #[doc = "Bits 15:16 - Input data arrangement"]
            #[inline]
            pub fn input_mode(&self) -> INPUT_MODER {
                INPUT_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u64) as u8
                })
            }
            #[doc = "Bit 17 - Effective width of input data"]
            #[inline]
            pub fn data_mode(&self) -> DATA_MODER {
                DATA_MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - FFT calculation data length"]
            #[inline]
            pub fn point(&mut self) -> _POINTW {
                _POINTW { w: self }
            }
            #[doc = "Bit 3 - FFT mode"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bits 4:12 - Corresponding to the nine layer butterfly shift operation, 0x0: does not shift; 0x1: shift 1st layer. ..."]
            #[inline]
            pub fn shift(&mut self) -> _SHIFTW {
                _SHIFTW { w: self }
            }
            #[doc = "Bit 13 - FFT enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 14 - FFT DMA enable"]
            #[inline]
            pub fn dma_send(&mut self) -> _DMA_SENDW {
                _DMA_SENDW { w: self }
            }
            #[doc = "Bits 15:16 - Input data arrangement"]
            #[inline]
            pub fn input_mode(&mut self) -> _INPUT_MODEW {
                _INPUT_MODEW { w: self }
            }
            #[doc = "Bit 17 - Effective width of input data"]
            #[inline]
            pub fn data_mode(&mut self) -> _DATA_MODEW {
                _DATA_MODEW { w: self }
            }
        }
    }
    #[doc = "FIFO control"]
    pub struct FIFO_CTRL {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FIFO control"]
    pub mod fifo_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::FIFO_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESP_FIFO_FLUSHR {
            bits: bool,
        }
        impl RESP_FIFO_FLUSHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMD_FIFO_FLUSHR {
            bits: bool,
        }
        impl CMD_FIFO_FLUSHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GS_FIFO_FLUSHR {
            bits: bool,
        }
        impl GS_FIFO_FLUSHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESP_FIFO_FLUSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESP_FIFO_FLUSHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMD_FIFO_FLUSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMD_FIFO_FLUSHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GS_FIFO_FLUSHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GS_FIFO_FLUSHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Response memory initialization flag"]
            #[inline]
            pub fn resp_fifo_flush(&self) -> RESP_FIFO_FLUSHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                RESP_FIFO_FLUSHR { bits }
            }
            #[doc = "Bit 1 - Command memory initialization flag"]
            #[inline]
            pub fn cmd_fifo_flush(&self) -> CMD_FIFO_FLUSHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CMD_FIFO_FLUSHR { bits }
            }
            #[doc = "Bit 2 - Output interface memory initialization flag"]
            #[inline]
            pub fn gs_fifo_flush(&self) -> GS_FIFO_FLUSHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                GS_FIFO_FLUSHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Response memory initialization flag"]
            #[inline]
            pub fn resp_fifo_flush(&mut self) -> _RESP_FIFO_FLUSHW {
                _RESP_FIFO_FLUSHW { w: self }
            }
            #[doc = "Bit 1 - Command memory initialization flag"]
            #[inline]
            pub fn cmd_fifo_flush(&mut self) -> _CMD_FIFO_FLUSHW {
                _CMD_FIFO_FLUSHW { w: self }
            }
            #[doc = "Bit 2 - Output interface memory initialization flag"]
            #[inline]
            pub fn gs_fifo_flush(&mut self) -> _GS_FIFO_FLUSHW {
                _GS_FIFO_FLUSHW { w: self }
            }
        }
    }
    #[doc = "intr_mask"]
    pub struct INTERRUPTMASK {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "intr_mask"]
    pub mod interruptmask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTERRUPTMASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_DONER {
            bits: bool,
        }
        impl FFT_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&self) -> FFT_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                FFT_DONER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&mut self) -> _FFT_DONEW {
                _FFT_DONEW { w: self }
            }
        }
    }
    #[doc = "Interrupt clear"]
    pub struct INTR_CLEAR {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Interrupt clear"]
    pub mod intr_clear {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTR_CLEAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_DONER {
            bits: bool,
        }
        impl FFT_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&self) -> FFT_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                FFT_DONER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&mut self) -> _FFT_DONEW {
                _FFT_DONEW { w: self }
            }
        }
    }
    #[doc = "FFT status register"]
    pub struct STATUS {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FFT status register"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_DONER {
            bits: bool,
        }
        impl FFT_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&self) -> FFT_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                FFT_DONER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&mut self) -> _FFT_DONEW {
                _FFT_DONEW { w: self }
            }
        }
    }
    #[doc = "FFT status raw"]
    pub struct STATUS_RAW {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FFT status raw"]
    pub mod status_raw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::STATUS_RAW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_DONER {
            bits: bool,
        }
        impl FFT_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_WORKR {
            bits: bool,
        }
        impl FFT_WORKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_WORKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_WORKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&self) -> FFT_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                FFT_DONER { bits }
            }
            #[doc = "Bit 1 - FFT work"]
            #[inline]
            pub fn fft_work(&self) -> FFT_WORKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                FFT_WORKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - FFT done"]
            #[inline]
            pub fn fft_done(&mut self) -> _FFT_DONEW {
                _FFT_DONEW { w: self }
            }
            #[doc = "Bit 1 - FFT work"]
            #[inline]
            pub fn fft_work(&mut self) -> _FFT_WORKW {
                _FFT_WORKW { w: self }
            }
        }
    }
    #[doc = "FFT output FIFO"]
    pub struct OUTPUT_FIFO {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "FFT output FIFO"]
    pub mod output_fifo {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::OUTPUT_FIFO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Direct Memory Access Controller"]
pub struct DMAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMAC {}
impl DMAC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dmac::RegisterBlock {
        0x5000_0000 as *const _
    }
}
impl Deref for DMAC {
    type Target = dmac::RegisterBlock;
    fn deref(&self) -> &dmac::RegisterBlock {
        unsafe { &*DMAC::ptr() }
    }
}
#[doc = "Direct Memory Access Controller"]
pub mod dmac {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - ID Register"]
        pub id: ID,
        #[doc = "0x08 - COMPVER Register"]
        pub compver: COMPVER,
        #[doc = "0x10 - Configure Register"]
        pub cfg: CFG,
        #[doc = "0x18 - Channel Enable Register"]
        pub chen: CHEN,
        _reserved0: [u8; 16usize],
        #[doc = "0x30 - Interrupt Status Register"]
        pub intstatus: INTSTATUS,
        #[doc = "0x38 - Common Interrupt Clear Register"]
        pub com_intclear: COM_INTCLEAR,
        #[doc = "0x40 - Common Interrupt Status Enable Register"]
        pub com_intstatus_en: COM_INTSTATUS_EN,
        #[doc = "0x48 - Common Interrupt Signal Enable Register"]
        pub com_intsignal_en: COM_INTSIGNAL_EN,
        #[doc = "0x50 - Common Interrupt Status"]
        pub com_intstatus: COM_INTSTATUS,
        #[doc = "0x58 - Reset register"]
        pub reset: RESET,
        _reserved1: [u8; 160usize],
        #[doc = "0x100 - Channel configuration"]
        pub channel: [CHANNEL; 6],
    }
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct CHANNEL {
        #[doc = "0x00 - SAR Address Register"]
        pub sar: self::channel::SAR,
        #[doc = "0x08 - DAR Address Register"]
        pub dar: self::channel::DAR,
        #[doc = "0x10 - Block Transfer Size Register"]
        pub block_ts: self::channel::BLOCK_TS,
        #[doc = "0x18 - Control Register"]
        pub ctl: self::channel::CTL,
        #[doc = "0x20 - Configure Register"]
        pub cfg: self::channel::CFG,
        #[doc = "0x28 - Linked List Pointer register"]
        pub llp: self::channel::LLP,
        #[doc = "0x30 - Channel Status Register"]
        pub status: self::channel::STATUS,
        #[doc = "0x38 - Channel Software handshake Source Register"]
        pub swhssrc: self::channel::SWHSSRC,
        #[doc = "0x40 - Channel Software handshake Destination Register"]
        pub swhsdst: self::channel::SWHSDST,
        #[doc = "0x48 - Channel Block Transfer Resume Request Register"]
        pub blk_tfr: self::channel::BLK_TFR,
        #[doc = "0x50 - Channel AXI ID Register"]
        pub axi_id: self::channel::AXI_ID,
        #[doc = "0x58 - AXI QOS Register"]
        pub axi_qos: self::channel::AXI_QOS,
        _reserved0: [u8; 32usize],
        #[doc = "0x80 - Interrupt Status Enable Register"]
        pub intstatus_en: self::channel::INTSTATUS_EN,
        #[doc = "0x88 - Channel Interrupt Status Register"]
        pub intstatus: self::channel::INTSTATUS,
        #[doc = "0x90 - Interrupt Signal Enable Register"]
        pub intsignal_en: self::channel::INTSIGNAL_EN,
        #[doc = "0x98 - Interrupt Clear Register"]
        pub intclear: self::channel::INTCLEAR,
        _reserved1: [u8; 88usize],
        #[doc = "0xf8 - Padding to make structure size 256 bytes so that channels\\[\\] is an array"]
        pub _reserved: self::channel::_RESERVED,
    }
    #[doc = r" Register block"]
    #[doc = "Channel configuration"]
    pub mod channel {
        #[doc = "SAR Address Register"]
        pub struct SAR {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "SAR Address Register"]
        pub mod sar {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::SAR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "DAR Address Register"]
        pub struct DAR {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "DAR Address Register"]
        pub mod dar {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::DAR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Block Transfer Size Register"]
        pub struct BLOCK_TS {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Block Transfer Size Register"]
        pub mod block_ts {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::BLOCK_TS {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct BLOCK_TSR {
                bits: u32,
            }
            impl BLOCK_TSR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            #[doc = r" Proxy"]
            pub struct _BLOCK_TSW<'a> {
                w: &'a mut W,
            }
            impl<'a> _BLOCK_TSW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    const MASK: u32 = 0x003f_ffff;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bits 0:21 - Block transfer size"]
                #[inline]
                pub fn block_ts(&self) -> BLOCK_TSR {
                    let bits = {
                        const MASK: u32 = 0x003f_ffff;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) as u32
                    };
                    BLOCK_TSR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:21 - Block transfer size"]
                #[inline]
                pub fn block_ts(&mut self) -> _BLOCK_TSW {
                    _BLOCK_TSW { w: self }
                }
            }
        }
        #[doc = "Control Register"]
        pub struct CTL {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Control Register"]
        pub mod ctl {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::CTL {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `sms`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SMSR {
                #[doc = "AXI master 1"]
                AXI_MASTER_1,
                #[doc = "AXI master 2"]
                AXI_MASTER_2,
            }
            impl SMSR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        SMSR::AXI_MASTER_1 => false,
                        SMSR::AXI_MASTER_2 => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> SMSR {
                    match value {
                        false => SMSR::AXI_MASTER_1,
                        true => SMSR::AXI_MASTER_2,
                    }
                }
                #[doc = "Checks if the value of the field is `AXI_MASTER_1`"]
                #[inline]
                pub fn is_axi_master_1(&self) -> bool {
                    *self == SMSR::AXI_MASTER_1
                }
                #[doc = "Checks if the value of the field is `AXI_MASTER_2`"]
                #[inline]
                pub fn is_axi_master_2(&self) -> bool {
                    *self == SMSR::AXI_MASTER_2
                }
            }
            #[doc = "Possible values of the field `dms`"]
            pub type DMSR = SMSR;
            #[doc = "Possible values of the field `sinc`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SINCR {
                #[doc = "Increment address"]
                INCREMENT,
                #[doc = "Don't increment address"]
                NOCHANGE,
            }
            impl SINCR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        SINCR::INCREMENT => false,
                        SINCR::NOCHANGE => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> SINCR {
                    match value {
                        false => SINCR::INCREMENT,
                        true => SINCR::NOCHANGE,
                    }
                }
                #[doc = "Checks if the value of the field is `INCREMENT`"]
                #[inline]
                pub fn is_increment(&self) -> bool {
                    *self == SINCR::INCREMENT
                }
                #[doc = "Checks if the value of the field is `NOCHANGE`"]
                #[inline]
                pub fn is_nochange(&self) -> bool {
                    *self == SINCR::NOCHANGE
                }
            }
            #[doc = "Possible values of the field `dinc`"]
            pub type DINCR = SINCR;
            #[doc = "Possible values of the field `src_tr_width`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_TR_WIDTHR {
                #[doc = "8 bits"]
                WIDTH_8,
                #[doc = "16 bits"]
                WIDTH_16,
                #[doc = "32 bits"]
                WIDTH_32,
                #[doc = "64 bits"]
                WIDTH_64,
                #[doc = "128 bits"]
                WIDTH_128,
                #[doc = "256 bits"]
                WIDTH_256,
                #[doc = "512 bits"]
                WIDTH_512,
                #[doc = r" Reserved"]
                _Reserved(u8),
            }
            impl SRC_TR_WIDTHR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        SRC_TR_WIDTHR::WIDTH_8 => 0,
                        SRC_TR_WIDTHR::WIDTH_16 => 0x01,
                        SRC_TR_WIDTHR::WIDTH_32 => 0x02,
                        SRC_TR_WIDTHR::WIDTH_64 => 0x03,
                        SRC_TR_WIDTHR::WIDTH_128 => 0x04,
                        SRC_TR_WIDTHR::WIDTH_256 => 0x05,
                        SRC_TR_WIDTHR::WIDTH_512 => 0x06,
                        SRC_TR_WIDTHR::_Reserved(bits) => bits,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> SRC_TR_WIDTHR {
                    match value {
                        0 => SRC_TR_WIDTHR::WIDTH_8,
                        1 => SRC_TR_WIDTHR::WIDTH_16,
                        2 => SRC_TR_WIDTHR::WIDTH_32,
                        3 => SRC_TR_WIDTHR::WIDTH_64,
                        4 => SRC_TR_WIDTHR::WIDTH_128,
                        5 => SRC_TR_WIDTHR::WIDTH_256,
                        6 => SRC_TR_WIDTHR::WIDTH_512,
                        i => SRC_TR_WIDTHR::_Reserved(i),
                    }
                }
                #[doc = "Checks if the value of the field is `WIDTH_8`"]
                #[inline]
                pub fn is_width_8(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_8
                }
                #[doc = "Checks if the value of the field is `WIDTH_16`"]
                #[inline]
                pub fn is_width_16(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_16
                }
                #[doc = "Checks if the value of the field is `WIDTH_32`"]
                #[inline]
                pub fn is_width_32(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_32
                }
                #[doc = "Checks if the value of the field is `WIDTH_64`"]
                #[inline]
                pub fn is_width_64(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_64
                }
                #[doc = "Checks if the value of the field is `WIDTH_128`"]
                #[inline]
                pub fn is_width_128(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_128
                }
                #[doc = "Checks if the value of the field is `WIDTH_256`"]
                #[inline]
                pub fn is_width_256(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_256
                }
                #[doc = "Checks if the value of the field is `WIDTH_512`"]
                #[inline]
                pub fn is_width_512(&self) -> bool {
                    *self == SRC_TR_WIDTHR::WIDTH_512
                }
            }
            #[doc = "Possible values of the field `dst_tr_width`"]
            pub type DST_TR_WIDTHR = SRC_TR_WIDTHR;
            #[doc = "Possible values of the field `src_msize`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_MSIZER {
                #[doc = "1 data item"]
                LENGTH_1,
                #[doc = "4 data items"]
                LENGTH_4,
                #[doc = "8 data items"]
                LENGTH_8,
                #[doc = "16 data items"]
                LENGTH_16,
                #[doc = "32 data items"]
                LENGTH_32,
                #[doc = "64 data items"]
                LENGTH_64,
                #[doc = "128 data items"]
                LENGTH_128,
                #[doc = "256 data items"]
                LENGTH_256,
                #[doc = "512 data items"]
                LENGTH_512,
                #[doc = "1024 data items"]
                LENGTH_1024,
                #[doc = r" Reserved"]
                _Reserved(u8),
            }
            impl SRC_MSIZER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        SRC_MSIZER::LENGTH_1 => 0,
                        SRC_MSIZER::LENGTH_4 => 0x01,
                        SRC_MSIZER::LENGTH_8 => 0x02,
                        SRC_MSIZER::LENGTH_16 => 0x03,
                        SRC_MSIZER::LENGTH_32 => 0x04,
                        SRC_MSIZER::LENGTH_64 => 0x05,
                        SRC_MSIZER::LENGTH_128 => 0x06,
                        SRC_MSIZER::LENGTH_256 => 0x07,
                        SRC_MSIZER::LENGTH_512 => 0x08,
                        SRC_MSIZER::LENGTH_1024 => 0x09,
                        SRC_MSIZER::_Reserved(bits) => bits,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> SRC_MSIZER {
                    match value {
                        0 => SRC_MSIZER::LENGTH_1,
                        1 => SRC_MSIZER::LENGTH_4,
                        2 => SRC_MSIZER::LENGTH_8,
                        3 => SRC_MSIZER::LENGTH_16,
                        4 => SRC_MSIZER::LENGTH_32,
                        5 => SRC_MSIZER::LENGTH_64,
                        6 => SRC_MSIZER::LENGTH_128,
                        7 => SRC_MSIZER::LENGTH_256,
                        8 => SRC_MSIZER::LENGTH_512,
                        9 => SRC_MSIZER::LENGTH_1024,
                        i => SRC_MSIZER::_Reserved(i),
                    }
                }
                #[doc = "Checks if the value of the field is `LENGTH_1`"]
                #[inline]
                pub fn is_length_1(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_1
                }
                #[doc = "Checks if the value of the field is `LENGTH_4`"]
                #[inline]
                pub fn is_length_4(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_4
                }
                #[doc = "Checks if the value of the field is `LENGTH_8`"]
                #[inline]
                pub fn is_length_8(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_8
                }
                #[doc = "Checks if the value of the field is `LENGTH_16`"]
                #[inline]
                pub fn is_length_16(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_16
                }
                #[doc = "Checks if the value of the field is `LENGTH_32`"]
                #[inline]
                pub fn is_length_32(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_32
                }
                #[doc = "Checks if the value of the field is `LENGTH_64`"]
                #[inline]
                pub fn is_length_64(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_64
                }
                #[doc = "Checks if the value of the field is `LENGTH_128`"]
                #[inline]
                pub fn is_length_128(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_128
                }
                #[doc = "Checks if the value of the field is `LENGTH_256`"]
                #[inline]
                pub fn is_length_256(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_256
                }
                #[doc = "Checks if the value of the field is `LENGTH_512`"]
                #[inline]
                pub fn is_length_512(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_512
                }
                #[doc = "Checks if the value of the field is `LENGTH_1024`"]
                #[inline]
                pub fn is_length_1024(&self) -> bool {
                    *self == SRC_MSIZER::LENGTH_1024
                }
            }
            #[doc = "Possible values of the field `dst_msize`"]
            pub type DST_MSIZER = SRC_MSIZER;
            #[doc = r" Value of the field"]
            pub struct NONPOSTED_LASTWRITE_ENR {
                bits: bool,
            }
            impl NONPOSTED_LASTWRITE_ENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct ARLEN_ENR {
                bits: bool,
            }
            impl ARLEN_ENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct ARLENR {
                bits: u8,
            }
            impl ARLENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = r" Value of the field"]
            pub struct AWLEN_ENR {
                bits: bool,
            }
            impl AWLEN_ENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct AWLENR {
                bits: u8,
            }
            impl AWLENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_STAT_ENR {
                bits: bool,
            }
            impl SRC_STAT_ENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_STAT_ENR {
                bits: bool,
            }
            impl DST_STAT_ENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct IOC_BLKTFRR {
                bits: bool,
            }
            impl IOC_BLKTFRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SHADOWREG_OR_LLI_LASTR {
                bits: bool,
            }
            impl SHADOWREG_OR_LLI_LASTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SHADOWREG_OR_LLI_VALIDR {
                bits: bool,
            }
            impl SHADOWREG_OR_LLI_VALIDR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = "Values that can be written to the field `sms`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SMSW {
                #[doc = "AXI master 1"]
                AXI_MASTER_1,
                #[doc = "AXI master 2"]
                AXI_MASTER_2,
            }
            impl SMSW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        SMSW::AXI_MASTER_1 => false,
                        SMSW::AXI_MASTER_2 => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _SMSW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SMSW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: SMSW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "AXI master 1"]
                #[inline]
                pub fn axi_master_1(self) -> &'a mut W {
                    self.variant(SMSW::AXI_MASTER_1)
                }
                #[doc = "AXI master 2"]
                #[inline]
                pub fn axi_master_2(self) -> &'a mut W {
                    self.variant(SMSW::AXI_MASTER_2)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `dms`"]
            pub type DMSW = SMSW;
            #[doc = r" Proxy"]
            pub struct _DMSW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DMSW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DMSW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "AXI master 1"]
                #[inline]
                pub fn axi_master_1(self) -> &'a mut W {
                    self.variant(SMSW::AXI_MASTER_1)
                }
                #[doc = "AXI master 2"]
                #[inline]
                pub fn axi_master_2(self) -> &'a mut W {
                    self.variant(SMSW::AXI_MASTER_2)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `sinc`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SINCW {
                #[doc = "Increment address"]
                INCREMENT,
                #[doc = "Don't increment address"]
                NOCHANGE,
            }
            impl SINCW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        SINCW::INCREMENT => false,
                        SINCW::NOCHANGE => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _SINCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SINCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: SINCW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Increment address"]
                #[inline]
                pub fn increment(self) -> &'a mut W {
                    self.variant(SINCW::INCREMENT)
                }
                #[doc = "Don't increment address"]
                #[inline]
                pub fn nochange(self) -> &'a mut W {
                    self.variant(SINCW::NOCHANGE)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `dinc`"]
            pub type DINCW = SINCW;
            #[doc = r" Proxy"]
            pub struct _DINCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DINCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DINCW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Increment address"]
                #[inline]
                pub fn increment(self) -> &'a mut W {
                    self.variant(SINCW::INCREMENT)
                }
                #[doc = "Don't increment address"]
                #[inline]
                pub fn nochange(self) -> &'a mut W {
                    self.variant(SINCW::NOCHANGE)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `src_tr_width`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_TR_WIDTHW {
                #[doc = "8 bits"]
                WIDTH_8,
                #[doc = "16 bits"]
                WIDTH_16,
                #[doc = "32 bits"]
                WIDTH_32,
                #[doc = "64 bits"]
                WIDTH_64,
                #[doc = "128 bits"]
                WIDTH_128,
                #[doc = "256 bits"]
                WIDTH_256,
                #[doc = "512 bits"]
                WIDTH_512,
            }
            impl SRC_TR_WIDTHW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        SRC_TR_WIDTHW::WIDTH_8 => 0,
                        SRC_TR_WIDTHW::WIDTH_16 => 1,
                        SRC_TR_WIDTHW::WIDTH_32 => 2,
                        SRC_TR_WIDTHW::WIDTH_64 => 3,
                        SRC_TR_WIDTHW::WIDTH_128 => 4,
                        SRC_TR_WIDTHW::WIDTH_256 => 5,
                        SRC_TR_WIDTHW::WIDTH_512 => 6,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_TR_WIDTHW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_TR_WIDTHW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: SRC_TR_WIDTHW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "8 bits"]
                #[inline]
                pub fn width_8(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_8)
                }
                #[doc = "16 bits"]
                #[inline]
                pub fn width_16(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_16)
                }
                #[doc = "32 bits"]
                #[inline]
                pub fn width_32(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_32)
                }
                #[doc = "64 bits"]
                #[inline]
                pub fn width_64(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_64)
                }
                #[doc = "128 bits"]
                #[inline]
                pub fn width_128(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_128)
                }
                #[doc = "256 bits"]
                #[inline]
                pub fn width_256(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_256)
                }
                #[doc = "512 bits"]
                #[inline]
                pub fn width_512(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_512)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `dst_tr_width`"]
            pub type DST_TR_WIDTHW = SRC_TR_WIDTHW;
            #[doc = r" Proxy"]
            pub struct _DST_TR_WIDTHW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_TR_WIDTHW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DST_TR_WIDTHW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "8 bits"]
                #[inline]
                pub fn width_8(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_8)
                }
                #[doc = "16 bits"]
                #[inline]
                pub fn width_16(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_16)
                }
                #[doc = "32 bits"]
                #[inline]
                pub fn width_32(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_32)
                }
                #[doc = "64 bits"]
                #[inline]
                pub fn width_64(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_64)
                }
                #[doc = "128 bits"]
                #[inline]
                pub fn width_128(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_128)
                }
                #[doc = "256 bits"]
                #[inline]
                pub fn width_256(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_256)
                }
                #[doc = "512 bits"]
                #[inline]
                pub fn width_512(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTHW::WIDTH_512)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 11;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `src_msize`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_MSIZEW {
                #[doc = "1 data item"]
                LENGTH_1,
                #[doc = "4 data items"]
                LENGTH_4,
                #[doc = "8 data items"]
                LENGTH_8,
                #[doc = "16 data items"]
                LENGTH_16,
                #[doc = "32 data items"]
                LENGTH_32,
                #[doc = "64 data items"]
                LENGTH_64,
                #[doc = "128 data items"]
                LENGTH_128,
                #[doc = "256 data items"]
                LENGTH_256,
                #[doc = "512 data items"]
                LENGTH_512,
                #[doc = "1024 data items"]
                LENGTH_1024,
            }
            impl SRC_MSIZEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        SRC_MSIZEW::LENGTH_1 => 0,
                        SRC_MSIZEW::LENGTH_4 => 1,
                        SRC_MSIZEW::LENGTH_8 => 2,
                        SRC_MSIZEW::LENGTH_16 => 3,
                        SRC_MSIZEW::LENGTH_32 => 4,
                        SRC_MSIZEW::LENGTH_64 => 5,
                        SRC_MSIZEW::LENGTH_128 => 6,
                        SRC_MSIZEW::LENGTH_256 => 7,
                        SRC_MSIZEW::LENGTH_512 => 8,
                        SRC_MSIZEW::LENGTH_1024 => 9,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_MSIZEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_MSIZEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: SRC_MSIZEW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "1 data item"]
                #[inline]
                pub fn length_1(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_1)
                }
                #[doc = "4 data items"]
                #[inline]
                pub fn length_4(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_4)
                }
                #[doc = "8 data items"]
                #[inline]
                pub fn length_8(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_8)
                }
                #[doc = "16 data items"]
                #[inline]
                pub fn length_16(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_16)
                }
                #[doc = "32 data items"]
                #[inline]
                pub fn length_32(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_32)
                }
                #[doc = "64 data items"]
                #[inline]
                pub fn length_64(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_64)
                }
                #[doc = "128 data items"]
                #[inline]
                pub fn length_128(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_128)
                }
                #[doc = "256 data items"]
                #[inline]
                pub fn length_256(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_256)
                }
                #[doc = "512 data items"]
                #[inline]
                pub fn length_512(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_512)
                }
                #[doc = "1024 data items"]
                #[inline]
                pub fn length_1024(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_1024)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 14;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `dst_msize`"]
            pub type DST_MSIZEW = SRC_MSIZEW;
            #[doc = r" Proxy"]
            pub struct _DST_MSIZEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_MSIZEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DST_MSIZEW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "1 data item"]
                #[inline]
                pub fn length_1(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_1)
                }
                #[doc = "4 data items"]
                #[inline]
                pub fn length_4(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_4)
                }
                #[doc = "8 data items"]
                #[inline]
                pub fn length_8(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_8)
                }
                #[doc = "16 data items"]
                #[inline]
                pub fn length_16(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_16)
                }
                #[doc = "32 data items"]
                #[inline]
                pub fn length_32(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_32)
                }
                #[doc = "64 data items"]
                #[inline]
                pub fn length_64(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_64)
                }
                #[doc = "128 data items"]
                #[inline]
                pub fn length_128(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_128)
                }
                #[doc = "256 data items"]
                #[inline]
                pub fn length_256(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_256)
                }
                #[doc = "512 data items"]
                #[inline]
                pub fn length_512(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_512)
                }
                #[doc = "1024 data items"]
                #[inline]
                pub fn length_1024(self) -> &'a mut W {
                    self.variant(SRC_MSIZEW::LENGTH_1024)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 18;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _NONPOSTED_LASTWRITE_ENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _NONPOSTED_LASTWRITE_ENW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _ARLEN_ENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _ARLEN_ENW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 38;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _ARLENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _ARLENW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 39;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _AWLEN_ENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _AWLEN_ENW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 47;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _AWLENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _AWLENW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 48;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_STAT_ENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_STAT_ENW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 56;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_STAT_ENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_STAT_ENW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 57;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _IOC_BLKTFRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _IOC_BLKTFRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 58;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SHADOWREG_OR_LLI_LASTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SHADOWREG_OR_LLI_LASTW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 62;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SHADOWREG_OR_LLI_VALIDW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SHADOWREG_OR_LLI_VALIDW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 63;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Source master select"]
                #[inline]
                pub fn sms(&self) -> SMSR {
                    SMSR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bit 2 - Destination master select"]
                #[inline]
                pub fn dms(&self) -> DMSR {
                    DMSR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bit 4 - Source address increment"]
                #[inline]
                pub fn sinc(&self) -> SINCR {
                    SINCR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bit 6 - Destination address increment"]
                #[inline]
                pub fn dinc(&self) -> DINCR {
                    DINCR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bits 8:10 - Source transfer width"]
                #[inline]
                pub fn src_tr_width(&self) -> SRC_TR_WIDTHR {
                    SRC_TR_WIDTHR::_from({
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bits 11:13 - Destination transfer width"]
                #[inline]
                pub fn dst_tr_width(&self) -> DST_TR_WIDTHR {
                    DST_TR_WIDTHR::_from({
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bits 14:17 - Source burst transaction length"]
                #[inline]
                pub fn src_msize(&self) -> SRC_MSIZER {
                    SRC_MSIZER::_from({
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 14;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bits 18:21 - Destination burst transaction length"]
                #[inline]
                pub fn dst_msize(&self) -> DST_MSIZER {
                    DST_MSIZER::_from({
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 18;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bit 30 - Non Posted Last Write Enable (posted writes may be used till the end of the block)"]
                #[inline]
                pub fn nonposted_lastwrite_en(&self) -> NONPOSTED_LASTWRITE_ENR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 30;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    NONPOSTED_LASTWRITE_ENR { bits }
                }
                #[doc = "Bit 38 - Source burst length enable"]
                #[inline]
                pub fn arlen_en(&self) -> ARLEN_ENR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 38;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    ARLEN_ENR { bits }
                }
                #[doc = "Bits 39:46 - Source burst length"]
                #[inline]
                pub fn arlen(&self) -> ARLENR {
                    let bits = {
                        const MASK: u8 = 0xff;
                        const OFFSET: u8 = 39;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    ARLENR { bits }
                }
                #[doc = "Bit 47 - Destination burst length enable"]
                #[inline]
                pub fn awlen_en(&self) -> AWLEN_ENR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 47;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    AWLEN_ENR { bits }
                }
                #[doc = "Bits 48:55 - Destination burst length"]
                #[inline]
                pub fn awlen(&self) -> AWLENR {
                    let bits = {
                        const MASK: u8 = 0xff;
                        const OFFSET: u8 = 48;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    AWLENR { bits }
                }
                #[doc = "Bit 56 - Source status enable"]
                #[inline]
                pub fn src_stat_en(&self) -> SRC_STAT_ENR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 56;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_STAT_ENR { bits }
                }
                #[doc = "Bit 57 - Destination status enable"]
                #[inline]
                pub fn dst_stat_en(&self) -> DST_STAT_ENR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 57;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_STAT_ENR { bits }
                }
                #[doc = "Bit 58 - Interrupt completion of block transfer"]
                #[inline]
                pub fn ioc_blktfr(&self) -> IOC_BLKTFRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 58;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    IOC_BLKTFRR { bits }
                }
                #[doc = "Bit 62 - Last shadow linked list item (indicates shadowreg/LLI content is the last one)"]
                #[inline]
                pub fn shadowreg_or_lli_last(&self) -> SHADOWREG_OR_LLI_LASTR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 62;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SHADOWREG_OR_LLI_LASTR { bits }
                }
                #[doc = "Bit 63 - last shadow linked list item valid (indicate shadowreg/LLI content is valid)"]
                #[inline]
                pub fn shadowreg_or_lli_valid(&self) -> SHADOWREG_OR_LLI_VALIDR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 63;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SHADOWREG_OR_LLI_VALIDR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Source master select"]
                #[inline]
                pub fn sms(&mut self) -> _SMSW {
                    _SMSW { w: self }
                }
                #[doc = "Bit 2 - Destination master select"]
                #[inline]
                pub fn dms(&mut self) -> _DMSW {
                    _DMSW { w: self }
                }
                #[doc = "Bit 4 - Source address increment"]
                #[inline]
                pub fn sinc(&mut self) -> _SINCW {
                    _SINCW { w: self }
                }
                #[doc = "Bit 6 - Destination address increment"]
                #[inline]
                pub fn dinc(&mut self) -> _DINCW {
                    _DINCW { w: self }
                }
                #[doc = "Bits 8:10 - Source transfer width"]
                #[inline]
                pub fn src_tr_width(&mut self) -> _SRC_TR_WIDTHW {
                    _SRC_TR_WIDTHW { w: self }
                }
                #[doc = "Bits 11:13 - Destination transfer width"]
                #[inline]
                pub fn dst_tr_width(&mut self) -> _DST_TR_WIDTHW {
                    _DST_TR_WIDTHW { w: self }
                }
                #[doc = "Bits 14:17 - Source burst transaction length"]
                #[inline]
                pub fn src_msize(&mut self) -> _SRC_MSIZEW {
                    _SRC_MSIZEW { w: self }
                }
                #[doc = "Bits 18:21 - Destination burst transaction length"]
                #[inline]
                pub fn dst_msize(&mut self) -> _DST_MSIZEW {
                    _DST_MSIZEW { w: self }
                }
                #[doc = "Bit 30 - Non Posted Last Write Enable (posted writes may be used till the end of the block)"]
                #[inline]
                pub fn nonposted_lastwrite_en(&mut self) -> _NONPOSTED_LASTWRITE_ENW {
                    _NONPOSTED_LASTWRITE_ENW { w: self }
                }
                #[doc = "Bit 38 - Source burst length enable"]
                #[inline]
                pub fn arlen_en(&mut self) -> _ARLEN_ENW {
                    _ARLEN_ENW { w: self }
                }
                #[doc = "Bits 39:46 - Source burst length"]
                #[inline]
                pub fn arlen(&mut self) -> _ARLENW {
                    _ARLENW { w: self }
                }
                #[doc = "Bit 47 - Destination burst length enable"]
                #[inline]
                pub fn awlen_en(&mut self) -> _AWLEN_ENW {
                    _AWLEN_ENW { w: self }
                }
                #[doc = "Bits 48:55 - Destination burst length"]
                #[inline]
                pub fn awlen(&mut self) -> _AWLENW {
                    _AWLENW { w: self }
                }
                #[doc = "Bit 56 - Source status enable"]
                #[inline]
                pub fn src_stat_en(&mut self) -> _SRC_STAT_ENW {
                    _SRC_STAT_ENW { w: self }
                }
                #[doc = "Bit 57 - Destination status enable"]
                #[inline]
                pub fn dst_stat_en(&mut self) -> _DST_STAT_ENW {
                    _DST_STAT_ENW { w: self }
                }
                #[doc = "Bit 58 - Interrupt completion of block transfer"]
                #[inline]
                pub fn ioc_blktfr(&mut self) -> _IOC_BLKTFRW {
                    _IOC_BLKTFRW { w: self }
                }
                #[doc = "Bit 62 - Last shadow linked list item (indicates shadowreg/LLI content is the last one)"]
                #[inline]
                pub fn shadowreg_or_lli_last(&mut self) -> _SHADOWREG_OR_LLI_LASTW {
                    _SHADOWREG_OR_LLI_LASTW { w: self }
                }
                #[doc = "Bit 63 - last shadow linked list item valid (indicate shadowreg/LLI content is valid)"]
                #[inline]
                pub fn shadowreg_or_lli_valid(&mut self) -> _SHADOWREG_OR_LLI_VALIDW {
                    _SHADOWREG_OR_LLI_VALIDW { w: self }
                }
            }
        }
        #[doc = "Configure Register"]
        pub struct CFG {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Configure Register"]
        pub mod cfg {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::CFG {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `src_multblk_type`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_MULTBLK_TYPER {
                #[doc = "Continuous multi-block type"]
                CONTIGUOUS,
                #[doc = "Reload multi-block type"]
                RELOAD,
                #[doc = "Shadow register based multi-block type"]
                SHADOW_REGISTER,
                #[doc = "Linked list based multi-block type"]
                LINKED_LIST,
            }
            impl SRC_MULTBLK_TYPER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        SRC_MULTBLK_TYPER::CONTIGUOUS => 0,
                        SRC_MULTBLK_TYPER::RELOAD => 0x01,
                        SRC_MULTBLK_TYPER::SHADOW_REGISTER => 0x02,
                        SRC_MULTBLK_TYPER::LINKED_LIST => 0x03,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> SRC_MULTBLK_TYPER {
                    match value {
                        0 => SRC_MULTBLK_TYPER::CONTIGUOUS,
                        1 => SRC_MULTBLK_TYPER::RELOAD,
                        2 => SRC_MULTBLK_TYPER::SHADOW_REGISTER,
                        3 => SRC_MULTBLK_TYPER::LINKED_LIST,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `CONTIGUOUS`"]
                #[inline]
                pub fn is_contiguous(&self) -> bool {
                    *self == SRC_MULTBLK_TYPER::CONTIGUOUS
                }
                #[doc = "Checks if the value of the field is `RELOAD`"]
                #[inline]
                pub fn is_reload(&self) -> bool {
                    *self == SRC_MULTBLK_TYPER::RELOAD
                }
                #[doc = "Checks if the value of the field is `SHADOW_REGISTER`"]
                #[inline]
                pub fn is_shadow_register(&self) -> bool {
                    *self == SRC_MULTBLK_TYPER::SHADOW_REGISTER
                }
                #[doc = "Checks if the value of the field is `LINKED_LIST`"]
                #[inline]
                pub fn is_linked_list(&self) -> bool {
                    *self == SRC_MULTBLK_TYPER::LINKED_LIST
                }
            }
            #[doc = "Possible values of the field `dst_multblk_type`"]
            pub type DST_MULTBLK_TYPER = SRC_MULTBLK_TYPER;
            #[doc = "Possible values of the field `tt_fc`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TT_FCR {
                #[doc = "Transfer memory to memory and flow controller is DMAC"]
                MEM2MEM_DMA,
                #[doc = "Transfer memory to peripheral and flow controller is DMAC"]
                MEM2PRF_DMA,
                #[doc = "Transfer peripheral to memory and flow controller is DMAC"]
                PRF2MEM_DMA,
                #[doc = "Transfer peripheral to peripheral and flow controller is DMAC"]
                PRF2PRF_DMA,
                #[doc = "Transfer peripheral to memory and flow controller is source peripheral"]
                PRF2MEM_PRF,
                #[doc = "Transfer peripheral to peripheral and flow controller is source peripheral"]
                PRF2PRF_SRCPRF,
                #[doc = "Transfer memory to peripheral and flow controller is destination peripheral"]
                MEM2PRF_PRF,
                #[doc = "Transfer peripheral to peripheral and flow controller is destination peripheral"]
                PRF2PRF_DSTPRF,
            }
            impl TT_FCR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        TT_FCR::MEM2MEM_DMA => 0,
                        TT_FCR::MEM2PRF_DMA => 0x01,
                        TT_FCR::PRF2MEM_DMA => 0x02,
                        TT_FCR::PRF2PRF_DMA => 0x03,
                        TT_FCR::PRF2MEM_PRF => 0x04,
                        TT_FCR::PRF2PRF_SRCPRF => 0x05,
                        TT_FCR::MEM2PRF_PRF => 0x06,
                        TT_FCR::PRF2PRF_DSTPRF => 0x07,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> TT_FCR {
                    match value {
                        0 => TT_FCR::MEM2MEM_DMA,
                        1 => TT_FCR::MEM2PRF_DMA,
                        2 => TT_FCR::PRF2MEM_DMA,
                        3 => TT_FCR::PRF2PRF_DMA,
                        4 => TT_FCR::PRF2MEM_PRF,
                        5 => TT_FCR::PRF2PRF_SRCPRF,
                        6 => TT_FCR::MEM2PRF_PRF,
                        7 => TT_FCR::PRF2PRF_DSTPRF,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `MEM2MEM_DMA`"]
                #[inline]
                pub fn is_mem2mem_dma(&self) -> bool {
                    *self == TT_FCR::MEM2MEM_DMA
                }
                #[doc = "Checks if the value of the field is `MEM2PRF_DMA`"]
                #[inline]
                pub fn is_mem2prf_dma(&self) -> bool {
                    *self == TT_FCR::MEM2PRF_DMA
                }
                #[doc = "Checks if the value of the field is `PRF2MEM_DMA`"]
                #[inline]
                pub fn is_prf2mem_dma(&self) -> bool {
                    *self == TT_FCR::PRF2MEM_DMA
                }
                #[doc = "Checks if the value of the field is `PRF2PRF_DMA`"]
                #[inline]
                pub fn is_prf2prf_dma(&self) -> bool {
                    *self == TT_FCR::PRF2PRF_DMA
                }
                #[doc = "Checks if the value of the field is `PRF2MEM_PRF`"]
                #[inline]
                pub fn is_prf2mem_prf(&self) -> bool {
                    *self == TT_FCR::PRF2MEM_PRF
                }
                #[doc = "Checks if the value of the field is `PRF2PRF_SRCPRF`"]
                #[inline]
                pub fn is_prf2prf_srcprf(&self) -> bool {
                    *self == TT_FCR::PRF2PRF_SRCPRF
                }
                #[doc = "Checks if the value of the field is `MEM2PRF_PRF`"]
                #[inline]
                pub fn is_mem2prf_prf(&self) -> bool {
                    *self == TT_FCR::MEM2PRF_PRF
                }
                #[doc = "Checks if the value of the field is `PRF2PRF_DSTPRF`"]
                #[inline]
                pub fn is_prf2prf_dstprf(&self) -> bool {
                    *self == TT_FCR::PRF2PRF_DSTPRF
                }
            }
            #[doc = "Possible values of the field `hs_sel_src`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HS_SEL_SRCR {
                #[doc = "Hardware handshaking is used"]
                HARDWARE,
                #[doc = "Software handshaking is used"]
                SOFTWARE,
            }
            impl HS_SEL_SRCR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        HS_SEL_SRCR::HARDWARE => false,
                        HS_SEL_SRCR::SOFTWARE => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> HS_SEL_SRCR {
                    match value {
                        false => HS_SEL_SRCR::HARDWARE,
                        true => HS_SEL_SRCR::SOFTWARE,
                    }
                }
                #[doc = "Checks if the value of the field is `HARDWARE`"]
                #[inline]
                pub fn is_hardware(&self) -> bool {
                    *self == HS_SEL_SRCR::HARDWARE
                }
                #[doc = "Checks if the value of the field is `SOFTWARE`"]
                #[inline]
                pub fn is_software(&self) -> bool {
                    *self == HS_SEL_SRCR::SOFTWARE
                }
            }
            #[doc = "Possible values of the field `hs_sel_dst`"]
            pub type HS_SEL_DSTR = HS_SEL_SRCR;
            #[doc = "Possible values of the field `src_hwhs_pol`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_HWHS_POLR {
                #[doc = "Active high"]
                ACTIVE_HIGH,
                #[doc = "Active low"]
                ACTIVE_LOW,
            }
            impl SRC_HWHS_POLR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        SRC_HWHS_POLR::ACTIVE_HIGH => false,
                        SRC_HWHS_POLR::ACTIVE_LOW => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> SRC_HWHS_POLR {
                    match value {
                        false => SRC_HWHS_POLR::ACTIVE_HIGH,
                        true => SRC_HWHS_POLR::ACTIVE_LOW,
                    }
                }
                #[doc = "Checks if the value of the field is `ACTIVE_HIGH`"]
                #[inline]
                pub fn is_active_high(&self) -> bool {
                    *self == SRC_HWHS_POLR::ACTIVE_HIGH
                }
                #[doc = "Checks if the value of the field is `ACTIVE_LOW`"]
                #[inline]
                pub fn is_active_low(&self) -> bool {
                    *self == SRC_HWHS_POLR::ACTIVE_LOW
                }
            }
            #[doc = "Possible values of the field `dst_hwhs_pol`"]
            pub type DST_HWHS_POLR = SRC_HWHS_POLR;
            #[doc = r" Value of the field"]
            pub struct SRC_PERR {
                bits: u8,
            }
            impl SRC_PERR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_PERR {
                bits: u8,
            }
            impl DST_PERR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = r" Value of the field"]
            pub struct CH_PRIORR {
                bits: u8,
            }
            impl CH_PRIORR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = r" Value of the field"]
            pub struct LOCK_CHR {
                bits: bool,
            }
            impl LOCK_CHR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = "Possible values of the field `lock_ch_l`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum LOCK_CH_LR {
                #[doc = "Duration of channel is locked for entire DMA transfer"]
                DMA_TRANSFER,
                #[doc = "Duration of channel is locked for current block transfer"]
                BLOCK_TRANSFER,
                #[doc = "Duration of channel is locked for current transaction"]
                TRANSACTION,
                #[doc = r" Reserved"]
                _Reserved(u8),
            }
            impl LOCK_CH_LR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        LOCK_CH_LR::DMA_TRANSFER => 0,
                        LOCK_CH_LR::BLOCK_TRANSFER => 0x01,
                        LOCK_CH_LR::TRANSACTION => 0x02,
                        LOCK_CH_LR::_Reserved(bits) => bits,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> LOCK_CH_LR {
                    match value {
                        0 => LOCK_CH_LR::DMA_TRANSFER,
                        1 => LOCK_CH_LR::BLOCK_TRANSFER,
                        2 => LOCK_CH_LR::TRANSACTION,
                        i => LOCK_CH_LR::_Reserved(i),
                    }
                }
                #[doc = "Checks if the value of the field is `DMA_TRANSFER`"]
                #[inline]
                pub fn is_dma_transfer(&self) -> bool {
                    *self == LOCK_CH_LR::DMA_TRANSFER
                }
                #[doc = "Checks if the value of the field is `BLOCK_TRANSFER`"]
                #[inline]
                pub fn is_block_transfer(&self) -> bool {
                    *self == LOCK_CH_LR::BLOCK_TRANSFER
                }
                #[doc = "Checks if the value of the field is `TRANSACTION`"]
                #[inline]
                pub fn is_transaction(&self) -> bool {
                    *self == LOCK_CH_LR::TRANSACTION
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_OSR_LMTR {
                bits: u8,
            }
            impl SRC_OSR_LMTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_OSR_LMTR {
                bits: u8,
            }
            impl DST_OSR_LMTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    self.bits
                }
            }
            #[doc = "Values that can be written to the field `src_multblk_type`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_MULTBLK_TYPEW {
                #[doc = "Continuous multi-block type"]
                CONTIGUOUS,
                #[doc = "Reload multi-block type"]
                RELOAD,
                #[doc = "Shadow register based multi-block type"]
                SHADOW_REGISTER,
                #[doc = "Linked list based multi-block type"]
                LINKED_LIST,
            }
            impl SRC_MULTBLK_TYPEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        SRC_MULTBLK_TYPEW::CONTIGUOUS => 0,
                        SRC_MULTBLK_TYPEW::RELOAD => 1,
                        SRC_MULTBLK_TYPEW::SHADOW_REGISTER => 2,
                        SRC_MULTBLK_TYPEW::LINKED_LIST => 3,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_MULTBLK_TYPEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_MULTBLK_TYPEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: SRC_MULTBLK_TYPEW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Continuous multi-block type"]
                #[inline]
                pub fn contiguous(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::CONTIGUOUS)
                }
                #[doc = "Reload multi-block type"]
                #[inline]
                pub fn reload(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::RELOAD)
                }
                #[doc = "Shadow register based multi-block type"]
                #[inline]
                pub fn shadow_register(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::SHADOW_REGISTER)
                }
                #[doc = "Linked list based multi-block type"]
                #[inline]
                pub fn linked_list(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::LINKED_LIST)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `dst_multblk_type`"]
            pub type DST_MULTBLK_TYPEW = SRC_MULTBLK_TYPEW;
            #[doc = r" Proxy"]
            pub struct _DST_MULTBLK_TYPEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_MULTBLK_TYPEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DST_MULTBLK_TYPEW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Continuous multi-block type"]
                #[inline]
                pub fn contiguous(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::CONTIGUOUS)
                }
                #[doc = "Reload multi-block type"]
                #[inline]
                pub fn reload(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::RELOAD)
                }
                #[doc = "Shadow register based multi-block type"]
                #[inline]
                pub fn shadow_register(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::SHADOW_REGISTER)
                }
                #[doc = "Linked list based multi-block type"]
                #[inline]
                pub fn linked_list(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPEW::LINKED_LIST)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `tt_fc`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TT_FCW {
                #[doc = "Transfer memory to memory and flow controller is DMAC"]
                MEM2MEM_DMA,
                #[doc = "Transfer memory to peripheral and flow controller is DMAC"]
                MEM2PRF_DMA,
                #[doc = "Transfer peripheral to memory and flow controller is DMAC"]
                PRF2MEM_DMA,
                #[doc = "Transfer peripheral to peripheral and flow controller is DMAC"]
                PRF2PRF_DMA,
                #[doc = "Transfer peripheral to memory and flow controller is source peripheral"]
                PRF2MEM_PRF,
                #[doc = "Transfer peripheral to peripheral and flow controller is source peripheral"]
                PRF2PRF_SRCPRF,
                #[doc = "Transfer memory to peripheral and flow controller is destination peripheral"]
                MEM2PRF_PRF,
                #[doc = "Transfer peripheral to peripheral and flow controller is destination peripheral"]
                PRF2PRF_DSTPRF,
            }
            impl TT_FCW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        TT_FCW::MEM2MEM_DMA => 0,
                        TT_FCW::MEM2PRF_DMA => 1,
                        TT_FCW::PRF2MEM_DMA => 2,
                        TT_FCW::PRF2PRF_DMA => 3,
                        TT_FCW::PRF2MEM_PRF => 4,
                        TT_FCW::PRF2PRF_SRCPRF => 5,
                        TT_FCW::MEM2PRF_PRF => 6,
                        TT_FCW::PRF2PRF_DSTPRF => 7,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _TT_FCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TT_FCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: TT_FCW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Transfer memory to memory and flow controller is DMAC"]
                #[inline]
                pub fn mem2mem_dma(self) -> &'a mut W {
                    self.variant(TT_FCW::MEM2MEM_DMA)
                }
                #[doc = "Transfer memory to peripheral and flow controller is DMAC"]
                #[inline]
                pub fn mem2prf_dma(self) -> &'a mut W {
                    self.variant(TT_FCW::MEM2PRF_DMA)
                }
                #[doc = "Transfer peripheral to memory and flow controller is DMAC"]
                #[inline]
                pub fn prf2mem_dma(self) -> &'a mut W {
                    self.variant(TT_FCW::PRF2MEM_DMA)
                }
                #[doc = "Transfer peripheral to peripheral and flow controller is DMAC"]
                #[inline]
                pub fn prf2prf_dma(self) -> &'a mut W {
                    self.variant(TT_FCW::PRF2PRF_DMA)
                }
                #[doc = "Transfer peripheral to memory and flow controller is source peripheral"]
                #[inline]
                pub fn prf2mem_prf(self) -> &'a mut W {
                    self.variant(TT_FCW::PRF2MEM_PRF)
                }
                #[doc = "Transfer peripheral to peripheral and flow controller is source peripheral"]
                #[inline]
                pub fn prf2prf_srcprf(self) -> &'a mut W {
                    self.variant(TT_FCW::PRF2PRF_SRCPRF)
                }
                #[doc = "Transfer memory to peripheral and flow controller is destination peripheral"]
                #[inline]
                pub fn mem2prf_prf(self) -> &'a mut W {
                    self.variant(TT_FCW::MEM2PRF_PRF)
                }
                #[doc = "Transfer peripheral to peripheral and flow controller is destination peripheral"]
                #[inline]
                pub fn prf2prf_dstprf(self) -> &'a mut W {
                    self.variant(TT_FCW::PRF2PRF_DSTPRF)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 32;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `hs_sel_src`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HS_SEL_SRCW {
                #[doc = "Hardware handshaking is used"]
                HARDWARE,
                #[doc = "Software handshaking is used"]
                SOFTWARE,
            }
            impl HS_SEL_SRCW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        HS_SEL_SRCW::HARDWARE => false,
                        HS_SEL_SRCW::SOFTWARE => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _HS_SEL_SRCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _HS_SEL_SRCW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: HS_SEL_SRCW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Hardware handshaking is used"]
                #[inline]
                pub fn hardware(self) -> &'a mut W {
                    self.variant(HS_SEL_SRCW::HARDWARE)
                }
                #[doc = "Software handshaking is used"]
                #[inline]
                pub fn software(self) -> &'a mut W {
                    self.variant(HS_SEL_SRCW::SOFTWARE)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 35;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `hs_sel_dst`"]
            pub type HS_SEL_DSTW = HS_SEL_SRCW;
            #[doc = r" Proxy"]
            pub struct _HS_SEL_DSTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _HS_SEL_DSTW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: HS_SEL_DSTW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Hardware handshaking is used"]
                #[inline]
                pub fn hardware(self) -> &'a mut W {
                    self.variant(HS_SEL_SRCW::HARDWARE)
                }
                #[doc = "Software handshaking is used"]
                #[inline]
                pub fn software(self) -> &'a mut W {
                    self.variant(HS_SEL_SRCW::SOFTWARE)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 36;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `src_hwhs_pol`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_HWHS_POLW {
                #[doc = "Active high"]
                ACTIVE_HIGH,
                #[doc = "Active low"]
                ACTIVE_LOW,
            }
            impl SRC_HWHS_POLW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        SRC_HWHS_POLW::ACTIVE_HIGH => false,
                        SRC_HWHS_POLW::ACTIVE_LOW => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_HWHS_POLW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_HWHS_POLW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: SRC_HWHS_POLW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Active high"]
                #[inline]
                pub fn active_high(self) -> &'a mut W {
                    self.variant(SRC_HWHS_POLW::ACTIVE_HIGH)
                }
                #[doc = "Active low"]
                #[inline]
                pub fn active_low(self) -> &'a mut W {
                    self.variant(SRC_HWHS_POLW::ACTIVE_LOW)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 37;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `dst_hwhs_pol`"]
            pub type DST_HWHS_POLW = SRC_HWHS_POLW;
            #[doc = r" Proxy"]
            pub struct _DST_HWHS_POLW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_HWHS_POLW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: DST_HWHS_POLW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Active high"]
                #[inline]
                pub fn active_high(self) -> &'a mut W {
                    self.variant(SRC_HWHS_POLW::ACTIVE_HIGH)
                }
                #[doc = "Active low"]
                #[inline]
                pub fn active_low(self) -> &'a mut W {
                    self.variant(SRC_HWHS_POLW::ACTIVE_LOW)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 38;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_PERW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_PERW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 39;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_PERW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_PERW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 44;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _CH_PRIORW<'a> {
                w: &'a mut W,
            }
            impl<'a> _CH_PRIORW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 49;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LOCK_CHW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LOCK_CHW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 52;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `lock_ch_l`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum LOCK_CH_LW {
                #[doc = "Duration of channel is locked for entire DMA transfer"]
                DMA_TRANSFER,
                #[doc = "Duration of channel is locked for current block transfer"]
                BLOCK_TRANSFER,
                #[doc = "Duration of channel is locked for current transaction"]
                TRANSACTION,
            }
            impl LOCK_CH_LW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        LOCK_CH_LW::DMA_TRANSFER => 0,
                        LOCK_CH_LW::BLOCK_TRANSFER => 1,
                        LOCK_CH_LW::TRANSACTION => 2,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _LOCK_CH_LW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LOCK_CH_LW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: LOCK_CH_LW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "Duration of channel is locked for entire DMA transfer"]
                #[inline]
                pub fn dma_transfer(self) -> &'a mut W {
                    self.variant(LOCK_CH_LW::DMA_TRANSFER)
                }
                #[doc = "Duration of channel is locked for current block transfer"]
                #[inline]
                pub fn block_transfer(self) -> &'a mut W {
                    self.variant(LOCK_CH_LW::BLOCK_TRANSFER)
                }
                #[doc = "Duration of channel is locked for current transaction"]
                #[inline]
                pub fn transaction(self) -> &'a mut W {
                    self.variant(LOCK_CH_LW::TRANSACTION)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 53;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_OSR_LMTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_OSR_LMTW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 55;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_OSR_LMTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_OSR_LMTW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 59;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bits 0:1 - Source multi-block transfer type"]
                #[inline]
                pub fn src_multblk_type(&self) -> SRC_MULTBLK_TYPER {
                    SRC_MULTBLK_TYPER::_from({
                        const MASK: u8 = 0x03;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bits 2:3 - Destination multi-block transfer type"]
                #[inline]
                pub fn dst_multblk_type(&self) -> DST_MULTBLK_TYPER {
                    DST_MULTBLK_TYPER::_from({
                        const MASK: u8 = 0x03;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bits 32:34 - Transfer type and flow control"]
                #[inline]
                pub fn tt_fc(&self) -> TT_FCR {
                    TT_FCR::_from({
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 32;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bit 35 - Source software or hardware handshaking select"]
                #[inline]
                pub fn hs_sel_src(&self) -> HS_SEL_SRCR {
                    HS_SEL_SRCR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 35;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bit 36 - Destination software or hardware handshaking select"]
                #[inline]
                pub fn hs_sel_dst(&self) -> HS_SEL_DSTR {
                    HS_SEL_DSTR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 36;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bit 37 - Source hardware handshaking interface polarity"]
                #[inline]
                pub fn src_hwhs_pol(&self) -> SRC_HWHS_POLR {
                    SRC_HWHS_POLR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 37;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bit 38 - Destination hardware handshaking interface polarity"]
                #[inline]
                pub fn dst_hwhs_pol(&self) -> DST_HWHS_POLR {
                    DST_HWHS_POLR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 38;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bits 39:42 - Assign a hardware handshaking interface to source of channel"]
                #[inline]
                pub fn src_per(&self) -> SRC_PERR {
                    let bits = {
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 39;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    SRC_PERR { bits }
                }
                #[doc = "Bits 44:47 - Assign a hardware handshaking interface to destination of channel"]
                #[inline]
                pub fn dst_per(&self) -> DST_PERR {
                    let bits = {
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 44;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    DST_PERR { bits }
                }
                #[doc = "Bits 49:51 - Channel priority (7 is highest, 0 is lowest)"]
                #[inline]
                pub fn ch_prior(&self) -> CH_PRIORR {
                    let bits = {
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 49;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    CH_PRIORR { bits }
                }
                #[doc = "Bit 52 - Channel lock bit"]
                #[inline]
                pub fn lock_ch(&self) -> LOCK_CHR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 52;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LOCK_CHR { bits }
                }
                #[doc = "Bits 53:54 - Channel lock level"]
                #[inline]
                pub fn lock_ch_l(&self) -> LOCK_CH_LR {
                    LOCK_CH_LR::_from({
                        const MASK: u8 = 0x03;
                        const OFFSET: u8 = 53;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    })
                }
                #[doc = "Bits 55:58 - Source outstanding request limit"]
                #[inline]
                pub fn src_osr_lmt(&self) -> SRC_OSR_LMTR {
                    let bits = {
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 55;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    SRC_OSR_LMTR { bits }
                }
                #[doc = "Bits 59:62 - Destination outstanding request limit"]
                #[inline]
                pub fn dst_osr_lmt(&self) -> DST_OSR_LMTR {
                    let bits = {
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 59;
                        ((self.bits >> OFFSET) & MASK as u64) as u8
                    };
                    DST_OSR_LMTR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:1 - Source multi-block transfer type"]
                #[inline]
                pub fn src_multblk_type(&mut self) -> _SRC_MULTBLK_TYPEW {
                    _SRC_MULTBLK_TYPEW { w: self }
                }
                #[doc = "Bits 2:3 - Destination multi-block transfer type"]
                #[inline]
                pub fn dst_multblk_type(&mut self) -> _DST_MULTBLK_TYPEW {
                    _DST_MULTBLK_TYPEW { w: self }
                }
                #[doc = "Bits 32:34 - Transfer type and flow control"]
                #[inline]
                pub fn tt_fc(&mut self) -> _TT_FCW {
                    _TT_FCW { w: self }
                }
                #[doc = "Bit 35 - Source software or hardware handshaking select"]
                #[inline]
                pub fn hs_sel_src(&mut self) -> _HS_SEL_SRCW {
                    _HS_SEL_SRCW { w: self }
                }
                #[doc = "Bit 36 - Destination software or hardware handshaking select"]
                #[inline]
                pub fn hs_sel_dst(&mut self) -> _HS_SEL_DSTW {
                    _HS_SEL_DSTW { w: self }
                }
                #[doc = "Bit 37 - Source hardware handshaking interface polarity"]
                #[inline]
                pub fn src_hwhs_pol(&mut self) -> _SRC_HWHS_POLW {
                    _SRC_HWHS_POLW { w: self }
                }
                #[doc = "Bit 38 - Destination hardware handshaking interface polarity"]
                #[inline]
                pub fn dst_hwhs_pol(&mut self) -> _DST_HWHS_POLW {
                    _DST_HWHS_POLW { w: self }
                }
                #[doc = "Bits 39:42 - Assign a hardware handshaking interface to source of channel"]
                #[inline]
                pub fn src_per(&mut self) -> _SRC_PERW {
                    _SRC_PERW { w: self }
                }
                #[doc = "Bits 44:47 - Assign a hardware handshaking interface to destination of channel"]
                #[inline]
                pub fn dst_per(&mut self) -> _DST_PERW {
                    _DST_PERW { w: self }
                }
                #[doc = "Bits 49:51 - Channel priority (7 is highest, 0 is lowest)"]
                #[inline]
                pub fn ch_prior(&mut self) -> _CH_PRIORW {
                    _CH_PRIORW { w: self }
                }
                #[doc = "Bit 52 - Channel lock bit"]
                #[inline]
                pub fn lock_ch(&mut self) -> _LOCK_CHW {
                    _LOCK_CHW { w: self }
                }
                #[doc = "Bits 53:54 - Channel lock level"]
                #[inline]
                pub fn lock_ch_l(&mut self) -> _LOCK_CH_LW {
                    _LOCK_CH_LW { w: self }
                }
                #[doc = "Bits 55:58 - Source outstanding request limit"]
                #[inline]
                pub fn src_osr_lmt(&mut self) -> _SRC_OSR_LMTW {
                    _SRC_OSR_LMTW { w: self }
                }
                #[doc = "Bits 59:62 - Destination outstanding request limit"]
                #[inline]
                pub fn dst_osr_lmt(&mut self) -> _DST_OSR_LMTW {
                    _DST_OSR_LMTW { w: self }
                }
            }
        }
        #[doc = "Linked List Pointer register"]
        pub struct LLP {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Linked List Pointer register"]
        pub mod llp {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::LLP {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `lms`"]
            pub type LMSR = super::ctl::SMSR;
            #[doc = r" Value of the field"]
            pub struct LOCR {
                bits: u64,
            }
            impl LOCR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
            }
            #[doc = "Values that can be written to the field `lms`"]
            pub type LMSW = super::ctl::SMSW;
            #[doc = r" Proxy"]
            pub struct _LMSW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LMSW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: LMSW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "AXI master 1"]
                #[inline]
                pub fn axi_master_1(self) -> &'a mut W {
                    self.variant(super::ctl::SMSW::AXI_MASTER_1)
                }
                #[doc = "AXI master 2"]
                #[inline]
                pub fn axi_master_2(self) -> &'a mut W {
                    self.variant(super::ctl::SMSW::AXI_MASTER_2)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LOCW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LOCW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u64) -> &'a mut W {
                    const MASK: u64 = 0xffff_ffff;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - LLI master select"]
                #[inline]
                pub fn lms(&self) -> LMSR {
                    LMSR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    })
                }
                #[doc = "Bits 6:63 - Starting address memeory of LLI block"]
                #[inline]
                pub fn loc(&self) -> LOCR {
                    let bits = {
                        const MASK: u64 = 0xffff_ffff;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u64) as u64
                    };
                    LOCR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - LLI master select"]
                #[inline]
                pub fn lms(&mut self) -> _LMSW {
                    _LMSW { w: self }
                }
                #[doc = "Bits 6:63 - Starting address memeory of LLI block"]
                #[inline]
                pub fn loc(&mut self) -> _LOCW {
                    _LOCW { w: self }
                }
            }
        }
        #[doc = "Channel Status Register"]
        pub struct STATUS {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Channel Status Register"]
        pub mod status {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::STATUS {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct CMPLTD_BLK_SIZER {
                bits: u32,
            }
            impl CMPLTD_BLK_SIZER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            #[doc = r" Proxy"]
            pub struct _CMPLTD_BLK_SIZEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _CMPLTD_BLK_SIZEW<'a> {
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    const MASK: u32 = 0x003f_ffff;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bits 0:21 - Completed block transfer size"]
                #[inline]
                pub fn cmpltd_blk_size(&self) -> CMPLTD_BLK_SIZER {
                    let bits = {
                        const MASK: u32 = 0x003f_ffff;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) as u32
                    };
                    CMPLTD_BLK_SIZER { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:21 - Completed block transfer size"]
                #[inline]
                pub fn cmpltd_blk_size(&mut self) -> _CMPLTD_BLK_SIZEW {
                    _CMPLTD_BLK_SIZEW { w: self }
                }
            }
        }
        #[doc = "Channel Software handshake Source Register"]
        pub struct SWHSSRC {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Channel Software handshake Source Register"]
        pub mod swhssrc {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::SWHSSRC {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct REQR {
                bits: bool,
            }
            impl REQR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct REQ_WER {
                bits: bool,
            }
            impl REQ_WER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SGLREQR {
                bits: bool,
            }
            impl SGLREQR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SGLREQ_WER {
                bits: bool,
            }
            impl SGLREQ_WER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LSTR {
                bits: bool,
            }
            impl LSTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LST_WER {
                bits: bool,
            }
            impl LST_WER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _REQW<'a> {
                w: &'a mut W,
            }
            impl<'a> _REQW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _REQ_WEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _REQ_WEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SGLREQW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SGLREQW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SGLREQ_WEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SGLREQ_WEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LSTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LSTW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LST_WEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LST_WEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Software handshake request for channel source"]
                #[inline]
                pub fn req(&self) -> REQR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    REQR { bits }
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline]
                pub fn req_we(&self) -> REQ_WER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    REQ_WER { bits }
                }
                #[doc = "Bit 2 - Software handshake single request for channel source"]
                #[inline]
                pub fn sglreq(&self) -> SGLREQR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SGLREQR { bits }
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline]
                pub fn sglreq_we(&self) -> SGLREQ_WER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SGLREQ_WER { bits }
                }
                #[doc = "Bit 4 - Software handshake last request for channel source"]
                #[inline]
                pub fn lst(&self) -> LSTR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LSTR { bits }
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline]
                pub fn lst_we(&self) -> LST_WER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LST_WER { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Software handshake request for channel source"]
                #[inline]
                pub fn req(&mut self) -> _REQW {
                    _REQW { w: self }
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline]
                pub fn req_we(&mut self) -> _REQ_WEW {
                    _REQ_WEW { w: self }
                }
                #[doc = "Bit 2 - Software handshake single request for channel source"]
                #[inline]
                pub fn sglreq(&mut self) -> _SGLREQW {
                    _SGLREQW { w: self }
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline]
                pub fn sglreq_we(&mut self) -> _SGLREQ_WEW {
                    _SGLREQ_WEW { w: self }
                }
                #[doc = "Bit 4 - Software handshake last request for channel source"]
                #[inline]
                pub fn lst(&mut self) -> _LSTW {
                    _LSTW { w: self }
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline]
                pub fn lst_we(&mut self) -> _LST_WEW {
                    _LST_WEW { w: self }
                }
            }
        }
        #[doc = "Channel Software handshake Destination Register"]
        pub struct SWHSDST {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Channel Software handshake Destination Register"]
        pub mod swhsdst {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::SWHSDST {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct REQR {
                bits: bool,
            }
            impl REQR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct REQ_WER {
                bits: bool,
            }
            impl REQ_WER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SGLREQR {
                bits: bool,
            }
            impl SGLREQR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SGLREQ_WER {
                bits: bool,
            }
            impl SGLREQ_WER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LSTR {
                bits: bool,
            }
            impl LSTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LST_WER {
                bits: bool,
            }
            impl LST_WER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _REQW<'a> {
                w: &'a mut W,
            }
            impl<'a> _REQW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _REQ_WEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _REQ_WEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SGLREQW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SGLREQW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SGLREQ_WEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SGLREQ_WEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LSTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LSTW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LST_WEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LST_WEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Software handshake request for channel destination"]
                #[inline]
                pub fn req(&self) -> REQR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    REQR { bits }
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline]
                pub fn req_we(&self) -> REQ_WER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    REQ_WER { bits }
                }
                #[doc = "Bit 2 - Software handshake single request for channel destination"]
                #[inline]
                pub fn sglreq(&self) -> SGLREQR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SGLREQR { bits }
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline]
                pub fn sglreq_we(&self) -> SGLREQ_WER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SGLREQ_WER { bits }
                }
                #[doc = "Bit 4 - Software handshake last request for channel destination"]
                #[inline]
                pub fn lst(&self) -> LSTR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LSTR { bits }
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline]
                pub fn lst_we(&self) -> LST_WER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LST_WER { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Software handshake request for channel destination"]
                #[inline]
                pub fn req(&mut self) -> _REQW {
                    _REQW { w: self }
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline]
                pub fn req_we(&mut self) -> _REQ_WEW {
                    _REQ_WEW { w: self }
                }
                #[doc = "Bit 2 - Software handshake single request for channel destination"]
                #[inline]
                pub fn sglreq(&mut self) -> _SGLREQW {
                    _SGLREQW { w: self }
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline]
                pub fn sglreq_we(&mut self) -> _SGLREQ_WEW {
                    _SGLREQ_WEW { w: self }
                }
                #[doc = "Bit 4 - Software handshake last request for channel destination"]
                #[inline]
                pub fn lst(&mut self) -> _LSTW {
                    _LSTW { w: self }
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline]
                pub fn lst_we(&mut self) -> _LST_WEW {
                    _LST_WEW { w: self }
                }
            }
        }
        #[doc = "Channel Block Transfer Resume Request Register"]
        pub struct BLK_TFR {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Channel Block Transfer Resume Request Register"]
        pub mod blk_tfr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::BLK_TFR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct RESUMEREQR {
                bits: bool,
            }
            impl RESUMEREQR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _RESUMEREQW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RESUMEREQW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Block transfer resume request"]
                #[inline]
                pub fn resumereq(&self) -> RESUMEREQR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    RESUMEREQR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Block transfer resume request"]
                #[inline]
                pub fn resumereq(&mut self) -> _RESUMEREQW {
                    _RESUMEREQW { w: self }
                }
            }
        }
        #[doc = "Channel AXI ID Register"]
        pub struct AXI_ID {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Channel AXI ID Register"]
        pub mod axi_id {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::AXI_ID {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "AXI QOS Register"]
        pub struct AXI_QOS {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "AXI QOS Register"]
        pub mod axi_qos {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::AXI_QOS {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Interrupt Status Enable Register"]
        pub struct INTSTATUS_EN {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Interrupt Status Enable Register"]
        pub mod intstatus_en {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::INTSTATUS_EN {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct BLOCK_TFR_DONER {
                bits: bool,
            }
            impl BLOCK_TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TFR_DONER {
                bits: bool,
            }
            impl TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_TRANSCOMPR {
                bits: bool,
            }
            impl SRC_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_TRANSCOMPR {
                bits: bool,
            }
            impl DST_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_DEC_ERRR {
                bits: bool,
            }
            impl SRC_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_DEC_ERRR {
                bits: bool,
            }
            impl DST_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_SLV_ERRR {
                bits: bool,
            }
            impl SRC_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_SLV_ERRR {
                bits: bool,
            }
            impl DST_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_DEC_ERRR {
                bits: bool,
            }
            impl LLI_RD_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_DEC_ERRR {
                bits: bool,
            }
            impl LLI_WR_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_SLV_ERRR {
                bits: bool,
            }
            impl LLI_RD_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_SLV_ERRR {
                bits: bool,
            }
            impl LLI_WR_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _BLOCK_TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _BLOCK_TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    BLOCK_TFR_DONER { bits }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&self) -> TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    TFR_DONER { bits }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_TRANSCOMPR { bits }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_TRANSCOMPR { bits }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&self) -> SRC_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_DEC_ERRR { bits }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&self) -> DST_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_DEC_ERRR { bits }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&self) -> SRC_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_SLV_ERRR { bits }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&self) -> DST_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_SLV_ERRR { bits }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_DEC_ERRR { bits }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_DEC_ERRR { bits }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_SLV_ERRR { bits }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_SLV_ERRR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&mut self) -> _BLOCK_TFR_DONEW {
                    _BLOCK_TFR_DONEW { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&mut self) -> _TFR_DONEW {
                    _TFR_DONEW { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&mut self) -> _SRC_TRANSCOMPW {
                    _SRC_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&mut self) -> _DST_TRANSCOMPW {
                    _DST_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&mut self) -> _SRC_DEC_ERRW {
                    _SRC_DEC_ERRW { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&mut self) -> _DST_DEC_ERRW {
                    _DST_DEC_ERRW { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&mut self) -> _SRC_SLV_ERRW {
                    _SRC_SLV_ERRW { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&mut self) -> _DST_SLV_ERRW {
                    _DST_SLV_ERRW { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&mut self) -> _LLI_RD_DEC_ERRW {
                    _LLI_RD_DEC_ERRW { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&mut self) -> _LLI_WR_DEC_ERRW {
                    _LLI_WR_DEC_ERRW { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&mut self) -> _LLI_RD_SLV_ERRW {
                    _LLI_RD_SLV_ERRW { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&mut self) -> _LLI_WR_SLV_ERRW {
                    _LLI_WR_SLV_ERRW { w: self }
                }
            }
        }
        #[doc = "Channel Interrupt Status Register"]
        pub struct INTSTATUS {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Channel Interrupt Status Register"]
        pub mod intstatus {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::INTSTATUS {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct BLOCK_TFR_DONER {
                bits: bool,
            }
            impl BLOCK_TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TFR_DONER {
                bits: bool,
            }
            impl TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_TRANSCOMPR {
                bits: bool,
            }
            impl SRC_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_TRANSCOMPR {
                bits: bool,
            }
            impl DST_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_DEC_ERRR {
                bits: bool,
            }
            impl SRC_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_DEC_ERRR {
                bits: bool,
            }
            impl DST_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_SLV_ERRR {
                bits: bool,
            }
            impl SRC_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_SLV_ERRR {
                bits: bool,
            }
            impl DST_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_DEC_ERRR {
                bits: bool,
            }
            impl LLI_RD_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_DEC_ERRR {
                bits: bool,
            }
            impl LLI_WR_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_SLV_ERRR {
                bits: bool,
            }
            impl LLI_RD_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_SLV_ERRR {
                bits: bool,
            }
            impl LLI_WR_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _BLOCK_TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _BLOCK_TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    BLOCK_TFR_DONER { bits }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&self) -> TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    TFR_DONER { bits }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_TRANSCOMPR { bits }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_TRANSCOMPR { bits }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&self) -> SRC_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_DEC_ERRR { bits }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&self) -> DST_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_DEC_ERRR { bits }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&self) -> SRC_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_SLV_ERRR { bits }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&self) -> DST_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_SLV_ERRR { bits }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_DEC_ERRR { bits }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_DEC_ERRR { bits }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_SLV_ERRR { bits }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_SLV_ERRR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&mut self) -> _BLOCK_TFR_DONEW {
                    _BLOCK_TFR_DONEW { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&mut self) -> _TFR_DONEW {
                    _TFR_DONEW { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&mut self) -> _SRC_TRANSCOMPW {
                    _SRC_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&mut self) -> _DST_TRANSCOMPW {
                    _DST_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&mut self) -> _SRC_DEC_ERRW {
                    _SRC_DEC_ERRW { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&mut self) -> _DST_DEC_ERRW {
                    _DST_DEC_ERRW { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&mut self) -> _SRC_SLV_ERRW {
                    _SRC_SLV_ERRW { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&mut self) -> _DST_SLV_ERRW {
                    _DST_SLV_ERRW { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&mut self) -> _LLI_RD_DEC_ERRW {
                    _LLI_RD_DEC_ERRW { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&mut self) -> _LLI_WR_DEC_ERRW {
                    _LLI_WR_DEC_ERRW { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&mut self) -> _LLI_RD_SLV_ERRW {
                    _LLI_RD_SLV_ERRW { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&mut self) -> _LLI_WR_SLV_ERRW {
                    _LLI_WR_SLV_ERRW { w: self }
                }
            }
        }
        #[doc = "Interrupt Signal Enable Register"]
        pub struct INTSIGNAL_EN {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Interrupt Signal Enable Register"]
        pub mod intsignal_en {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::INTSIGNAL_EN {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct BLOCK_TFR_DONER {
                bits: bool,
            }
            impl BLOCK_TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TFR_DONER {
                bits: bool,
            }
            impl TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_TRANSCOMPR {
                bits: bool,
            }
            impl SRC_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_TRANSCOMPR {
                bits: bool,
            }
            impl DST_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_DEC_ERRR {
                bits: bool,
            }
            impl SRC_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_DEC_ERRR {
                bits: bool,
            }
            impl DST_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_SLV_ERRR {
                bits: bool,
            }
            impl SRC_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_SLV_ERRR {
                bits: bool,
            }
            impl DST_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_DEC_ERRR {
                bits: bool,
            }
            impl LLI_RD_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_DEC_ERRR {
                bits: bool,
            }
            impl LLI_WR_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_SLV_ERRR {
                bits: bool,
            }
            impl LLI_RD_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_SLV_ERRR {
                bits: bool,
            }
            impl LLI_WR_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _BLOCK_TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _BLOCK_TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    BLOCK_TFR_DONER { bits }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&self) -> TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    TFR_DONER { bits }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_TRANSCOMPR { bits }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_TRANSCOMPR { bits }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&self) -> SRC_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_DEC_ERRR { bits }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&self) -> DST_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_DEC_ERRR { bits }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&self) -> SRC_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_SLV_ERRR { bits }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&self) -> DST_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_SLV_ERRR { bits }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_DEC_ERRR { bits }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_DEC_ERRR { bits }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_SLV_ERRR { bits }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_SLV_ERRR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&mut self) -> _BLOCK_TFR_DONEW {
                    _BLOCK_TFR_DONEW { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&mut self) -> _TFR_DONEW {
                    _TFR_DONEW { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&mut self) -> _SRC_TRANSCOMPW {
                    _SRC_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&mut self) -> _DST_TRANSCOMPW {
                    _DST_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&mut self) -> _SRC_DEC_ERRW {
                    _SRC_DEC_ERRW { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&mut self) -> _DST_DEC_ERRW {
                    _DST_DEC_ERRW { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&mut self) -> _SRC_SLV_ERRW {
                    _SRC_SLV_ERRW { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&mut self) -> _DST_SLV_ERRW {
                    _DST_SLV_ERRW { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&mut self) -> _LLI_RD_DEC_ERRW {
                    _LLI_RD_DEC_ERRW { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&mut self) -> _LLI_WR_DEC_ERRW {
                    _LLI_WR_DEC_ERRW { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&mut self) -> _LLI_RD_SLV_ERRW {
                    _LLI_RD_SLV_ERRW { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&mut self) -> _LLI_WR_SLV_ERRW {
                    _LLI_WR_SLV_ERRW { w: self }
                }
            }
        }
        #[doc = "Interrupt Clear Register"]
        pub struct INTCLEAR {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Interrupt Clear Register"]
        pub mod intclear {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::INTCLEAR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct BLOCK_TFR_DONER {
                bits: bool,
            }
            impl BLOCK_TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TFR_DONER {
                bits: bool,
            }
            impl TFR_DONER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_TRANSCOMPR {
                bits: bool,
            }
            impl SRC_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_TRANSCOMPR {
                bits: bool,
            }
            impl DST_TRANSCOMPR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_DEC_ERRR {
                bits: bool,
            }
            impl SRC_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_DEC_ERRR {
                bits: bool,
            }
            impl DST_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct SRC_SLV_ERRR {
                bits: bool,
            }
            impl SRC_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct DST_SLV_ERRR {
                bits: bool,
            }
            impl DST_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_DEC_ERRR {
                bits: bool,
            }
            impl LLI_RD_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_DEC_ERRR {
                bits: bool,
            }
            impl LLI_WR_DEC_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_RD_SLV_ERRR {
                bits: bool,
            }
            impl LLI_RD_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct LLI_WR_SLV_ERRR {
                bits: bool,
            }
            impl LLI_WR_SLV_ERRR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _BLOCK_TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _BLOCK_TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _TFR_DONEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TFR_DONEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_TRANSCOMPW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_TRANSCOMPW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _SRC_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _SRC_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _DST_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _DST_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_DEC_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_DEC_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_RD_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_RD_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _LLI_WR_SLV_ERRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _LLI_WR_SLV_ERRW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    self.w.bits &= !((MASK as u64) << OFFSET);
                    self.w.bits |= ((value & MASK) as u64) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    BLOCK_TFR_DONER { bits }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&self) -> TFR_DONER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    TFR_DONER { bits }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_TRANSCOMPR { bits }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMPR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_TRANSCOMPR { bits }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&self) -> SRC_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_DEC_ERRR { bits }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&self) -> DST_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 6;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_DEC_ERRR { bits }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&self) -> SRC_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 7;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    SRC_SLV_ERRR { bits }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&self) -> DST_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 8;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    DST_SLV_ERRR { bits }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 9;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_DEC_ERRR { bits }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 10;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_DEC_ERRR { bits }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 11;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_RD_SLV_ERRR { bits }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERRR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 12;
                        ((self.bits >> OFFSET) & MASK as u64) != 0
                    };
                    LLI_WR_SLV_ERRR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Block transfer done"]
                #[inline]
                pub fn block_tfr_done(&mut self) -> _BLOCK_TFR_DONEW {
                    _BLOCK_TFR_DONEW { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline]
                pub fn tfr_done(&mut self) -> _TFR_DONEW {
                    _TFR_DONEW { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline]
                pub fn src_transcomp(&mut self) -> _SRC_TRANSCOMPW {
                    _SRC_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline]
                pub fn dst_transcomp(&mut self) -> _DST_TRANSCOMPW {
                    _DST_TRANSCOMPW { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline]
                pub fn src_dec_err(&mut self) -> _SRC_DEC_ERRW {
                    _SRC_DEC_ERRW { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline]
                pub fn dst_dec_err(&mut self) -> _DST_DEC_ERRW {
                    _DST_DEC_ERRW { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline]
                pub fn src_slv_err(&mut self) -> _SRC_SLV_ERRW {
                    _SRC_SLV_ERRW { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline]
                pub fn dst_slv_err(&mut self) -> _DST_SLV_ERRW {
                    _DST_SLV_ERRW { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline]
                pub fn lli_rd_dec_err(&mut self) -> _LLI_RD_DEC_ERRW {
                    _LLI_RD_DEC_ERRW { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline]
                pub fn lli_wr_dec_err(&mut self) -> _LLI_WR_DEC_ERRW {
                    _LLI_WR_DEC_ERRW { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline]
                pub fn lli_rd_slv_err(&mut self) -> _LLI_RD_SLV_ERRW {
                    _LLI_RD_SLV_ERRW { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline]
                pub fn lli_wr_slv_err(&mut self) -> _LLI_WR_SLV_ERRW {
                    _LLI_WR_SLV_ERRW { w: self }
                }
            }
        }
        #[doc = "Padding to make structure size 256 bytes so that channels\\[\\] is an array"]
        pub struct _RESERVED {
            register: ::vcell::VolatileCell<u64>,
        }
        #[doc = "Padding to make structure size 256 bytes so that channels\\[\\] is an array"]
        pub mod _reserved {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u64,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u64,
            }
            impl super::_RESERVED {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
    }
    #[doc = "ID Register"]
    pub struct ID {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "ID Register"]
    pub mod id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::ID {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "COMPVER Register"]
    pub struct COMPVER {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "COMPVER Register"]
    pub mod compver {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::COMPVER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Configure Register"]
    pub struct CFG {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Configure Register"]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMAC_ENR {
            bits: bool,
        }
        impl DMAC_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INT_ENR {
            bits: bool,
        }
        impl INT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMAC_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMAC_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Enable DMAC"]
            #[inline]
            pub fn dmac_en(&self) -> DMAC_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                DMAC_ENR { bits }
            }
            #[doc = "Bit 1 - Globally enable interrupt generation"]
            #[inline]
            pub fn int_en(&self) -> INT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                INT_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable DMAC"]
            #[inline]
            pub fn dmac_en(&mut self) -> _DMAC_ENW {
                _DMAC_ENW { w: self }
            }
            #[doc = "Bit 1 - Globally enable interrupt generation"]
            #[inline]
            pub fn int_en(&mut self) -> _INT_ENW {
                _INT_ENW { w: self }
            }
        }
    }
    #[doc = "Channel Enable Register"]
    pub struct CHEN {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Channel Enable Register"]
    pub mod chen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::CHEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_ENR {
            bits: bool,
        }
        impl CH1_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_ENR {
            bits: bool,
        }
        impl CH2_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_ENR {
            bits: bool,
        }
        impl CH3_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_ENR {
            bits: bool,
        }
        impl CH4_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_ENR {
            bits: bool,
        }
        impl CH5_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_ENR {
            bits: bool,
        }
        impl CH6_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_EN_WER {
            bits: bool,
        }
        impl CH1_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_EN_WER {
            bits: bool,
        }
        impl CH2_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_EN_WER {
            bits: bool,
        }
        impl CH3_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_EN_WER {
            bits: bool,
        }
        impl CH4_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_EN_WER {
            bits: bool,
        }
        impl CH5_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_EN_WER {
            bits: bool,
        }
        impl CH6_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_SUSPR {
            bits: bool,
        }
        impl CH1_SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_SUSPR {
            bits: bool,
        }
        impl CH2_SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_SUSPR {
            bits: bool,
        }
        impl CH3_SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_SUSPR {
            bits: bool,
        }
        impl CH4_SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_SUSPR {
            bits: bool,
        }
        impl CH5_SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_SUSPR {
            bits: bool,
        }
        impl CH6_SUSPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_SUSP_WER {
            bits: bool,
        }
        impl CH1_SUSP_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_SUSP_WER {
            bits: bool,
        }
        impl CH2_SUSP_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_SUSP_WER {
            bits: bool,
        }
        impl CH3_SUSP_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_SUSP_WER {
            bits: bool,
        }
        impl CH4_SUSP_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_SUSP_WER {
            bits: bool,
        }
        impl CH5_SUSP_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_SUSP_WER {
            bits: bool,
        }
        impl CH6_SUSP_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_ABORTR {
            bits: bool,
        }
        impl CH1_ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_ABORTR {
            bits: bool,
        }
        impl CH2_ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_ABORTR {
            bits: bool,
        }
        impl CH3_ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_ABORTR {
            bits: bool,
        }
        impl CH4_ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_ABORTR {
            bits: bool,
        }
        impl CH5_ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_ABORTR {
            bits: bool,
        }
        impl CH6_ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_ABORT_WER {
            bits: bool,
        }
        impl CH1_ABORT_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_ABORT_WER {
            bits: bool,
        }
        impl CH2_ABORT_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_ABORT_WER {
            bits: bool,
        }
        impl CH3_ABORT_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_ABORT_WER {
            bits: bool,
        }
        impl CH4_ABORT_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_ABORT_WER {
            bits: bool,
        }
        impl CH5_ABORT_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_ABORT_WER {
            bits: bool,
        }
        impl CH6_ABORT_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_SUSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_SUSPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_SUSP_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_SUSP_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_SUSP_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_SUSP_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_SUSP_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_SUSP_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_SUSP_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_SUSP_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_SUSP_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_SUSP_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_SUSP_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_SUSP_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 32;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 33;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 34;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 35;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 36;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 37;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_ABORT_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_ABORT_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 40;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_ABORT_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_ABORT_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 41;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_ABORT_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_ABORT_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 42;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_ABORT_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_ABORT_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 43;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_ABORT_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_ABORT_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 44;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_ABORT_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_ABORT_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 45;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Enable channel 1"]
            #[inline]
            pub fn ch1_en(&self) -> CH1_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_ENR { bits }
            }
            #[doc = "Bit 1 - Enable channel 2"]
            #[inline]
            pub fn ch2_en(&self) -> CH2_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_ENR { bits }
            }
            #[doc = "Bit 2 - Enable channel 3"]
            #[inline]
            pub fn ch3_en(&self) -> CH3_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_ENR { bits }
            }
            #[doc = "Bit 3 - Enable channel 4"]
            #[inline]
            pub fn ch4_en(&self) -> CH4_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_ENR { bits }
            }
            #[doc = "Bit 4 - Enable channel 5"]
            #[inline]
            pub fn ch5_en(&self) -> CH5_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_ENR { bits }
            }
            #[doc = "Bit 5 - Enable channel 6"]
            #[inline]
            pub fn ch6_en(&self) -> CH6_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_ENR { bits }
            }
            #[doc = "Bit 8 - Write enable channel 1"]
            #[inline]
            pub fn ch1_en_we(&self) -> CH1_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_EN_WER { bits }
            }
            #[doc = "Bit 9 - Write enable channel 2"]
            #[inline]
            pub fn ch2_en_we(&self) -> CH2_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_EN_WER { bits }
            }
            #[doc = "Bit 10 - Write enable channel 3"]
            #[inline]
            pub fn ch3_en_we(&self) -> CH3_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_EN_WER { bits }
            }
            #[doc = "Bit 11 - Write enable channel 4"]
            #[inline]
            pub fn ch4_en_we(&self) -> CH4_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_EN_WER { bits }
            }
            #[doc = "Bit 12 - Write enable channel 5"]
            #[inline]
            pub fn ch5_en_we(&self) -> CH5_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_EN_WER { bits }
            }
            #[doc = "Bit 13 - Write enable channel 6"]
            #[inline]
            pub fn ch6_en_we(&self) -> CH6_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_EN_WER { bits }
            }
            #[doc = "Bit 16 - Suspend request channel 1"]
            #[inline]
            pub fn ch1_susp(&self) -> CH1_SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_SUSPR { bits }
            }
            #[doc = "Bit 17 - Suspend request channel 2"]
            #[inline]
            pub fn ch2_susp(&self) -> CH2_SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_SUSPR { bits }
            }
            #[doc = "Bit 18 - Suspend request channel 3"]
            #[inline]
            pub fn ch3_susp(&self) -> CH3_SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_SUSPR { bits }
            }
            #[doc = "Bit 19 - Suspend request channel 4"]
            #[inline]
            pub fn ch4_susp(&self) -> CH4_SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_SUSPR { bits }
            }
            #[doc = "Bit 20 - Suspend request channel 5"]
            #[inline]
            pub fn ch5_susp(&self) -> CH5_SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_SUSPR { bits }
            }
            #[doc = "Bit 21 - Suspend request channel 6"]
            #[inline]
            pub fn ch6_susp(&self) -> CH6_SUSPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_SUSPR { bits }
            }
            #[doc = "Bit 24 - Enable write to ch1_susp bit"]
            #[inline]
            pub fn ch1_susp_we(&self) -> CH1_SUSP_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_SUSP_WER { bits }
            }
            #[doc = "Bit 25 - Enable write to ch2_susp bit"]
            #[inline]
            pub fn ch2_susp_we(&self) -> CH2_SUSP_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_SUSP_WER { bits }
            }
            #[doc = "Bit 26 - Enable write to ch3_susp bit"]
            #[inline]
            pub fn ch3_susp_we(&self) -> CH3_SUSP_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_SUSP_WER { bits }
            }
            #[doc = "Bit 27 - Enable write to ch4_susp bit"]
            #[inline]
            pub fn ch4_susp_we(&self) -> CH4_SUSP_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_SUSP_WER { bits }
            }
            #[doc = "Bit 28 - Enable write to ch5_susp bit"]
            #[inline]
            pub fn ch5_susp_we(&self) -> CH5_SUSP_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_SUSP_WER { bits }
            }
            #[doc = "Bit 29 - Enable write to ch6_susp bit"]
            #[inline]
            pub fn ch6_susp_we(&self) -> CH6_SUSP_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_SUSP_WER { bits }
            }
            #[doc = "Bit 32 - Abort request channel 1"]
            #[inline]
            pub fn ch1_abort(&self) -> CH1_ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 32;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_ABORTR { bits }
            }
            #[doc = "Bit 33 - Abort request channel 2"]
            #[inline]
            pub fn ch2_abort(&self) -> CH2_ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 33;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_ABORTR { bits }
            }
            #[doc = "Bit 34 - Abort request channel 3"]
            #[inline]
            pub fn ch3_abort(&self) -> CH3_ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 34;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_ABORTR { bits }
            }
            #[doc = "Bit 35 - Abort request channel 4"]
            #[inline]
            pub fn ch4_abort(&self) -> CH4_ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 35;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_ABORTR { bits }
            }
            #[doc = "Bit 36 - Abort request channel 5"]
            #[inline]
            pub fn ch5_abort(&self) -> CH5_ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 36;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_ABORTR { bits }
            }
            #[doc = "Bit 37 - Abort request channel 6"]
            #[inline]
            pub fn ch6_abort(&self) -> CH6_ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 37;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_ABORTR { bits }
            }
            #[doc = "Bit 40 - Enable write to ch1_abort bit"]
            #[inline]
            pub fn ch1_abort_we(&self) -> CH1_ABORT_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 40;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_ABORT_WER { bits }
            }
            #[doc = "Bit 41 - Enable write to ch2_abort bit"]
            #[inline]
            pub fn ch2_abort_we(&self) -> CH2_ABORT_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 41;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_ABORT_WER { bits }
            }
            #[doc = "Bit 42 - Enable write to ch3_abort bit"]
            #[inline]
            pub fn ch3_abort_we(&self) -> CH3_ABORT_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 42;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_ABORT_WER { bits }
            }
            #[doc = "Bit 43 - Enable write to ch4_abort bit"]
            #[inline]
            pub fn ch4_abort_we(&self) -> CH4_ABORT_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 43;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_ABORT_WER { bits }
            }
            #[doc = "Bit 44 - Enable write to ch5_abort bit"]
            #[inline]
            pub fn ch5_abort_we(&self) -> CH5_ABORT_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 44;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_ABORT_WER { bits }
            }
            #[doc = "Bit 45 - Enable write to ch6_abort bit"]
            #[inline]
            pub fn ch6_abort_we(&self) -> CH6_ABORT_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 45;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_ABORT_WER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable channel 1"]
            #[inline]
            pub fn ch1_en(&mut self) -> _CH1_ENW {
                _CH1_ENW { w: self }
            }
            #[doc = "Bit 1 - Enable channel 2"]
            #[inline]
            pub fn ch2_en(&mut self) -> _CH2_ENW {
                _CH2_ENW { w: self }
            }
            #[doc = "Bit 2 - Enable channel 3"]
            #[inline]
            pub fn ch3_en(&mut self) -> _CH3_ENW {
                _CH3_ENW { w: self }
            }
            #[doc = "Bit 3 - Enable channel 4"]
            #[inline]
            pub fn ch4_en(&mut self) -> _CH4_ENW {
                _CH4_ENW { w: self }
            }
            #[doc = "Bit 4 - Enable channel 5"]
            #[inline]
            pub fn ch5_en(&mut self) -> _CH5_ENW {
                _CH5_ENW { w: self }
            }
            #[doc = "Bit 5 - Enable channel 6"]
            #[inline]
            pub fn ch6_en(&mut self) -> _CH6_ENW {
                _CH6_ENW { w: self }
            }
            #[doc = "Bit 8 - Write enable channel 1"]
            #[inline]
            pub fn ch1_en_we(&mut self) -> _CH1_EN_WEW {
                _CH1_EN_WEW { w: self }
            }
            #[doc = "Bit 9 - Write enable channel 2"]
            #[inline]
            pub fn ch2_en_we(&mut self) -> _CH2_EN_WEW {
                _CH2_EN_WEW { w: self }
            }
            #[doc = "Bit 10 - Write enable channel 3"]
            #[inline]
            pub fn ch3_en_we(&mut self) -> _CH3_EN_WEW {
                _CH3_EN_WEW { w: self }
            }
            #[doc = "Bit 11 - Write enable channel 4"]
            #[inline]
            pub fn ch4_en_we(&mut self) -> _CH4_EN_WEW {
                _CH4_EN_WEW { w: self }
            }
            #[doc = "Bit 12 - Write enable channel 5"]
            #[inline]
            pub fn ch5_en_we(&mut self) -> _CH5_EN_WEW {
                _CH5_EN_WEW { w: self }
            }
            #[doc = "Bit 13 - Write enable channel 6"]
            #[inline]
            pub fn ch6_en_we(&mut self) -> _CH6_EN_WEW {
                _CH6_EN_WEW { w: self }
            }
            #[doc = "Bit 16 - Suspend request channel 1"]
            #[inline]
            pub fn ch1_susp(&mut self) -> _CH1_SUSPW {
                _CH1_SUSPW { w: self }
            }
            #[doc = "Bit 17 - Suspend request channel 2"]
            #[inline]
            pub fn ch2_susp(&mut self) -> _CH2_SUSPW {
                _CH2_SUSPW { w: self }
            }
            #[doc = "Bit 18 - Suspend request channel 3"]
            #[inline]
            pub fn ch3_susp(&mut self) -> _CH3_SUSPW {
                _CH3_SUSPW { w: self }
            }
            #[doc = "Bit 19 - Suspend request channel 4"]
            #[inline]
            pub fn ch4_susp(&mut self) -> _CH4_SUSPW {
                _CH4_SUSPW { w: self }
            }
            #[doc = "Bit 20 - Suspend request channel 5"]
            #[inline]
            pub fn ch5_susp(&mut self) -> _CH5_SUSPW {
                _CH5_SUSPW { w: self }
            }
            #[doc = "Bit 21 - Suspend request channel 6"]
            #[inline]
            pub fn ch6_susp(&mut self) -> _CH6_SUSPW {
                _CH6_SUSPW { w: self }
            }
            #[doc = "Bit 24 - Enable write to ch1_susp bit"]
            #[inline]
            pub fn ch1_susp_we(&mut self) -> _CH1_SUSP_WEW {
                _CH1_SUSP_WEW { w: self }
            }
            #[doc = "Bit 25 - Enable write to ch2_susp bit"]
            #[inline]
            pub fn ch2_susp_we(&mut self) -> _CH2_SUSP_WEW {
                _CH2_SUSP_WEW { w: self }
            }
            #[doc = "Bit 26 - Enable write to ch3_susp bit"]
            #[inline]
            pub fn ch3_susp_we(&mut self) -> _CH3_SUSP_WEW {
                _CH3_SUSP_WEW { w: self }
            }
            #[doc = "Bit 27 - Enable write to ch4_susp bit"]
            #[inline]
            pub fn ch4_susp_we(&mut self) -> _CH4_SUSP_WEW {
                _CH4_SUSP_WEW { w: self }
            }
            #[doc = "Bit 28 - Enable write to ch5_susp bit"]
            #[inline]
            pub fn ch5_susp_we(&mut self) -> _CH5_SUSP_WEW {
                _CH5_SUSP_WEW { w: self }
            }
            #[doc = "Bit 29 - Enable write to ch6_susp bit"]
            #[inline]
            pub fn ch6_susp_we(&mut self) -> _CH6_SUSP_WEW {
                _CH6_SUSP_WEW { w: self }
            }
            #[doc = "Bit 32 - Abort request channel 1"]
            #[inline]
            pub fn ch1_abort(&mut self) -> _CH1_ABORTW {
                _CH1_ABORTW { w: self }
            }
            #[doc = "Bit 33 - Abort request channel 2"]
            #[inline]
            pub fn ch2_abort(&mut self) -> _CH2_ABORTW {
                _CH2_ABORTW { w: self }
            }
            #[doc = "Bit 34 - Abort request channel 3"]
            #[inline]
            pub fn ch3_abort(&mut self) -> _CH3_ABORTW {
                _CH3_ABORTW { w: self }
            }
            #[doc = "Bit 35 - Abort request channel 4"]
            #[inline]
            pub fn ch4_abort(&mut self) -> _CH4_ABORTW {
                _CH4_ABORTW { w: self }
            }
            #[doc = "Bit 36 - Abort request channel 5"]
            #[inline]
            pub fn ch5_abort(&mut self) -> _CH5_ABORTW {
                _CH5_ABORTW { w: self }
            }
            #[doc = "Bit 37 - Abort request channel 6"]
            #[inline]
            pub fn ch6_abort(&mut self) -> _CH6_ABORTW {
                _CH6_ABORTW { w: self }
            }
            #[doc = "Bit 40 - Enable write to ch1_abort bit"]
            #[inline]
            pub fn ch1_abort_we(&mut self) -> _CH1_ABORT_WEW {
                _CH1_ABORT_WEW { w: self }
            }
            #[doc = "Bit 41 - Enable write to ch2_abort bit"]
            #[inline]
            pub fn ch2_abort_we(&mut self) -> _CH2_ABORT_WEW {
                _CH2_ABORT_WEW { w: self }
            }
            #[doc = "Bit 42 - Enable write to ch3_abort bit"]
            #[inline]
            pub fn ch3_abort_we(&mut self) -> _CH3_ABORT_WEW {
                _CH3_ABORT_WEW { w: self }
            }
            #[doc = "Bit 43 - Enable write to ch4_abort bit"]
            #[inline]
            pub fn ch4_abort_we(&mut self) -> _CH4_ABORT_WEW {
                _CH4_ABORT_WEW { w: self }
            }
            #[doc = "Bit 44 - Enable write to ch5_abort bit"]
            #[inline]
            pub fn ch5_abort_we(&mut self) -> _CH5_ABORT_WEW {
                _CH5_ABORT_WEW { w: self }
            }
            #[doc = "Bit 45 - Enable write to ch6_abort bit"]
            #[inline]
            pub fn ch6_abort_we(&mut self) -> _CH6_ABORT_WEW {
                _CH6_ABORT_WEW { w: self }
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct INTSTATUS {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod intstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::INTSTATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH1_INTSTATR {
            bits: bool,
        }
        impl CH1_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH2_INTSTATR {
            bits: bool,
        }
        impl CH2_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH3_INTSTATR {
            bits: bool,
        }
        impl CH3_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH4_INTSTATR {
            bits: bool,
        }
        impl CH4_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH5_INTSTATR {
            bits: bool,
        }
        impl CH5_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH6_INTSTATR {
            bits: bool,
        }
        impl CH6_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMMONREG_INTSTATR {
            bits: bool,
        }
        impl COMMONREG_INTSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMMONREG_INTSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMMONREG_INTSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 1 interrupt bit"]
            #[inline]
            pub fn ch1_intstat(&self) -> CH1_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH1_INTSTATR { bits }
            }
            #[doc = "Bit 1 - Channel 2 interrupt bit"]
            #[inline]
            pub fn ch2_intstat(&self) -> CH2_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH2_INTSTATR { bits }
            }
            #[doc = "Bit 2 - Channel 3 interrupt bit"]
            #[inline]
            pub fn ch3_intstat(&self) -> CH3_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH3_INTSTATR { bits }
            }
            #[doc = "Bit 3 - Channel 4 interrupt bit"]
            #[inline]
            pub fn ch4_intstat(&self) -> CH4_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH4_INTSTATR { bits }
            }
            #[doc = "Bit 4 - Channel 5 interrupt bit"]
            #[inline]
            pub fn ch5_intstat(&self) -> CH5_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH5_INTSTATR { bits }
            }
            #[doc = "Bit 5 - Channel 6 interrupt bit"]
            #[inline]
            pub fn ch6_intstat(&self) -> CH6_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                CH6_INTSTATR { bits }
            }
            #[doc = "Bit 16 - Common register status bit"]
            #[inline]
            pub fn commonreg_intstat(&self) -> COMMONREG_INTSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                COMMONREG_INTSTATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 1 interrupt bit"]
            #[inline]
            pub fn ch1_intstat(&mut self) -> _CH1_INTSTATW {
                _CH1_INTSTATW { w: self }
            }
            #[doc = "Bit 1 - Channel 2 interrupt bit"]
            #[inline]
            pub fn ch2_intstat(&mut self) -> _CH2_INTSTATW {
                _CH2_INTSTATW { w: self }
            }
            #[doc = "Bit 2 - Channel 3 interrupt bit"]
            #[inline]
            pub fn ch3_intstat(&mut self) -> _CH3_INTSTATW {
                _CH3_INTSTATW { w: self }
            }
            #[doc = "Bit 3 - Channel 4 interrupt bit"]
            #[inline]
            pub fn ch4_intstat(&mut self) -> _CH4_INTSTATW {
                _CH4_INTSTATW { w: self }
            }
            #[doc = "Bit 4 - Channel 5 interrupt bit"]
            #[inline]
            pub fn ch5_intstat(&mut self) -> _CH5_INTSTATW {
                _CH5_INTSTATW { w: self }
            }
            #[doc = "Bit 5 - Channel 6 interrupt bit"]
            #[inline]
            pub fn ch6_intstat(&mut self) -> _CH6_INTSTATW {
                _CH6_INTSTATW { w: self }
            }
            #[doc = "Bit 16 - Common register status bit"]
            #[inline]
            pub fn commonreg_intstat(&mut self) -> _COMMONREG_INTSTATW {
                _COMMONREG_INTSTATW { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Clear Register"]
    pub struct COM_INTCLEAR {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Common Interrupt Clear Register"]
    pub mod com_intclear {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::COM_INTCLEAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WR2RO_ERRR {
            bits: bool,
        }
        impl SLVIF_WR2RO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_RD2WO_ERRR {
            bits: bool,
        }
        impl SLVIF_RD2WO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WRONHOLD_ERRR {
            bits: bool,
        }
        impl SLVIF_WRONHOLD_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_UNDEFINEDREG_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WR2RO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WR2RO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_RD2WO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_RD2WO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WRONHOLD_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WRONHOLD_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Clear slvif_dec_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_DEC_ERRR { bits }
            }
            #[doc = "Bit 1 - Clear slvif_wr2ro_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WR2RO_ERRR { bits }
            }
            #[doc = "Bit 2 - Clear slvif_rd2wo_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_RD2WO_ERRR { bits }
            }
            #[doc = "Bit 3 - Clear slvif_wronhold_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WRONHOLD_ERRR { bits }
            }
            #[doc = "Bit 8 - Clear slvif_undefinedreg_dec_err in com_intstatus"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_UNDEFINEDREG_DEC_ERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Clear slvif_dec_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_dec_err(&mut self) -> _SLVIF_DEC_ERRW {
                _SLVIF_DEC_ERRW { w: self }
            }
            #[doc = "Bit 1 - Clear slvif_wr2ro_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_wr2ro_err(&mut self) -> _SLVIF_WR2RO_ERRW {
                _SLVIF_WR2RO_ERRW { w: self }
            }
            #[doc = "Bit 2 - Clear slvif_rd2wo_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_rd2wo_err(&mut self) -> _SLVIF_RD2WO_ERRW {
                _SLVIF_RD2WO_ERRW { w: self }
            }
            #[doc = "Bit 3 - Clear slvif_wronhold_err interrupt in com_intstatus"]
            #[inline]
            pub fn slvif_wronhold_err(&mut self) -> _SLVIF_WRONHOLD_ERRW {
                _SLVIF_WRONHOLD_ERRW { w: self }
            }
            #[doc = "Bit 8 - Clear slvif_undefinedreg_dec_err in com_intstatus"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> _SLVIF_UNDEFINEDREG_DEC_ERRW {
                _SLVIF_UNDEFINEDREG_DEC_ERRW { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Status Enable Register"]
    pub struct COM_INTSTATUS_EN {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Common Interrupt Status Enable Register"]
    pub mod com_intstatus_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::COM_INTSTATUS_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WR2RO_ERRR {
            bits: bool,
        }
        impl SLVIF_WR2RO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_RD2WO_ERRR {
            bits: bool,
        }
        impl SLVIF_RD2WO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WRONHOLD_ERRR {
            bits: bool,
        }
        impl SLVIF_WRONHOLD_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_UNDEFINEDREG_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WR2RO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WR2RO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_RD2WO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_RD2WO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WRONHOLD_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WRONHOLD_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_DEC_ERRR { bits }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WR2RO_ERRR { bits }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_RD2WO_ERRR { bits }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WRONHOLD_ERRR { bits }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_UNDEFINEDREG_DEC_ERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline]
            pub fn slvif_dec_err(&mut self) -> _SLVIF_DEC_ERRW {
                _SLVIF_DEC_ERRW { w: self }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline]
            pub fn slvif_wr2ro_err(&mut self) -> _SLVIF_WR2RO_ERRW {
                _SLVIF_WR2RO_ERRW { w: self }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline]
            pub fn slvif_rd2wo_err(&mut self) -> _SLVIF_RD2WO_ERRW {
                _SLVIF_RD2WO_ERRW { w: self }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline]
            pub fn slvif_wronhold_err(&mut self) -> _SLVIF_WRONHOLD_ERRW {
                _SLVIF_WRONHOLD_ERRW { w: self }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> _SLVIF_UNDEFINEDREG_DEC_ERRW {
                _SLVIF_UNDEFINEDREG_DEC_ERRW { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Signal Enable Register"]
    pub struct COM_INTSIGNAL_EN {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Common Interrupt Signal Enable Register"]
    pub mod com_intsignal_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::COM_INTSIGNAL_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WR2RO_ERRR {
            bits: bool,
        }
        impl SLVIF_WR2RO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_RD2WO_ERRR {
            bits: bool,
        }
        impl SLVIF_RD2WO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WRONHOLD_ERRR {
            bits: bool,
        }
        impl SLVIF_WRONHOLD_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_UNDEFINEDREG_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WR2RO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WR2RO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_RD2WO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_RD2WO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WRONHOLD_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WRONHOLD_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_DEC_ERRR { bits }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WR2RO_ERRR { bits }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_RD2WO_ERRR { bits }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WRONHOLD_ERRR { bits }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_UNDEFINEDREG_DEC_ERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline]
            pub fn slvif_dec_err(&mut self) -> _SLVIF_DEC_ERRW {
                _SLVIF_DEC_ERRW { w: self }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline]
            pub fn slvif_wr2ro_err(&mut self) -> _SLVIF_WR2RO_ERRW {
                _SLVIF_WR2RO_ERRW { w: self }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline]
            pub fn slvif_rd2wo_err(&mut self) -> _SLVIF_RD2WO_ERRW {
                _SLVIF_RD2WO_ERRW { w: self }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline]
            pub fn slvif_wronhold_err(&mut self) -> _SLVIF_WRONHOLD_ERRW {
                _SLVIF_WRONHOLD_ERRW { w: self }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> _SLVIF_UNDEFINEDREG_DEC_ERRW {
                _SLVIF_UNDEFINEDREG_DEC_ERRW { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Status"]
    pub struct COM_INTSTATUS {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Common Interrupt Status"]
    pub mod com_intstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::COM_INTSTATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WR2RO_ERRR {
            bits: bool,
        }
        impl SLVIF_WR2RO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_RD2WO_ERRR {
            bits: bool,
        }
        impl SLVIF_RD2WO_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_WRONHOLD_ERRR {
            bits: bool,
        }
        impl SLVIF_WRONHOLD_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERRR {
            bits: bool,
        }
        impl SLVIF_UNDEFINEDREG_DEC_ERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WR2RO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WR2RO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_RD2WO_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_RD2WO_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_WRONHOLD_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_WRONHOLD_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIF_UNDEFINEDREG_DEC_ERRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_DEC_ERRR { bits }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WR2RO_ERRR { bits }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_RD2WO_ERRR { bits }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_WRONHOLD_ERRR { bits }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                SLVIF_UNDEFINEDREG_DEC_ERRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline]
            pub fn slvif_dec_err(&mut self) -> _SLVIF_DEC_ERRW {
                _SLVIF_DEC_ERRW { w: self }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline]
            pub fn slvif_wr2ro_err(&mut self) -> _SLVIF_WR2RO_ERRW {
                _SLVIF_WR2RO_ERRW { w: self }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline]
            pub fn slvif_rd2wo_err(&mut self) -> _SLVIF_RD2WO_ERRW {
                _SLVIF_RD2WO_ERRW { w: self }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline]
            pub fn slvif_wronhold_err(&mut self) -> _SLVIF_WRONHOLD_ERRW {
                _SLVIF_WRONHOLD_ERRW { w: self }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> _SLVIF_UNDEFINEDREG_DEC_ERRW {
                _SLVIF_UNDEFINEDREG_DEC_ERRW { w: self }
            }
        }
    }
    #[doc = "Reset register"]
    pub struct RESET {
        register: ::vcell::VolatileCell<u64>,
    }
    #[doc = "Reset register"]
    pub mod reset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u64,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u64,
        }
        impl super::RESET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RSTR {
            bits: bool,
        }
        impl RSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u64) << OFFSET);
                self.w.bits |= ((value & MASK) as u64) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u64 {
                self.bits
            }
            #[doc = "Bit 0 - DMAC reset request bit"]
            #[inline]
            pub fn rst(&self) -> RSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u64) != 0
                };
                RSTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u64) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DMAC reset request bit"]
            #[inline]
            pub fn rst(&mut self) -> _RSTW {
                _RSTW { w: self }
            }
        }
    }
}
#[doc = "General Purpose Input/Output Interface"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio::RegisterBlock {
        0x5020_0000 as *const _
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    fn deref(&self) -> &gpio::RegisterBlock {
        unsafe { &*GPIO::ptr() }
    }
}
#[doc = "General Purpose Input/Output Interface"]
pub mod gpio {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data (output) registers"]
        pub data_output: DATA_OUTPUT,
        #[doc = "0x04 - Data direction registers"]
        pub direction: DIRECTION,
        #[doc = "0x08 - Data source registers"]
        pub source: SOURCE,
        _reserved0: [u8; 36usize],
        #[doc = "0x30 - Interrupt enable/disable registers"]
        pub interrupt_enable: INTERRUPT_ENABLE,
        #[doc = "0x34 - Interrupt mask registers"]
        pub interrupt_mask: INTERRUPT_MASK,
        #[doc = "0x38 - Interrupt level registers"]
        pub interrupt_level: INTERRUPT_LEVEL,
        #[doc = "0x3c - Interrupt polarity registers"]
        pub interrupt_polarity: INTERRUPT_POLARITY,
        #[doc = "0x40 - Interrupt status registers"]
        pub interrupt_status: INTERRUPT_STATUS,
        #[doc = "0x44 - Raw interrupt status registers"]
        pub interrupt_status_raw: INTERRUPT_STATUS_RAW,
        #[doc = "0x48 - Interrupt debounce registers"]
        pub interrupt_debounce: INTERRUPT_DEBOUNCE,
        #[doc = "0x4c - Registers for clearing interrupts"]
        pub interrupt_clear: INTERRUPT_CLEAR,
        #[doc = "0x50 - External port (data input) registers"]
        pub data_input: DATA_INPUT,
        _reserved1: [u8; 12usize],
        #[doc = "0x60 - Sync level registers"]
        pub sync_level: SYNC_LEVEL,
        #[doc = "0x64 - ID code"]
        pub id_code: ID_CODE,
        #[doc = "0x68 - Interrupt both edge type"]
        pub interrupt_bothedge: INTERRUPT_BOTHEDGE,
    }
    #[doc = "Data (output) registers"]
    pub struct DATA_OUTPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data (output) registers"]
    pub mod data_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA_OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
        }
    }
    #[doc = "Data direction registers"]
    pub struct DIRECTION {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data direction registers"]
    pub mod direction {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRECTION {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `pin0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin is input"]
            INPUT,
            #[doc = "Pin is output"]
            OUTPUT,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::INPUT => false,
                    PIN0R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::INPUT,
                    true => PIN0R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN0R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN0R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `pin1`"]
        pub type PIN1R = PIN0R;
        #[doc = "Possible values of the field `pin2`"]
        pub type PIN2R = PIN0R;
        #[doc = "Possible values of the field `pin3`"]
        pub type PIN3R = PIN0R;
        #[doc = "Possible values of the field `pin4`"]
        pub type PIN4R = PIN0R;
        #[doc = "Possible values of the field `pin5`"]
        pub type PIN5R = PIN0R;
        #[doc = "Possible values of the field `pin6`"]
        pub type PIN6R = PIN0R;
        #[doc = "Possible values of the field `pin7`"]
        pub type PIN7R = PIN0R;
        #[doc = "Values that can be written to the field `pin0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0W {
            #[doc = "Pin is input"]
            INPUT,
            #[doc = "Pin is output"]
            OUTPUT,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::INPUT => false,
                    PIN0W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin1`"]
        pub type PIN1W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin2`"]
        pub type PIN2W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin3`"]
        pub type PIN3W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin4`"]
        pub type PIN4W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin5`"]
        pub type PIN5W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin6`"]
        pub type PIN6W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `pin7`"]
        pub type PIN7W = PIN0W;
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin is input"]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
        }
    }
    #[doc = "Data source registers"]
    pub struct SOURCE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data source registers"]
    pub mod source {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SOURCE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable/disable registers"]
    pub struct INTERRUPT_ENABLE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt enable/disable registers"]
    pub mod interrupt_enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt mask registers"]
    pub struct INTERRUPT_MASK {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt mask registers"]
    pub mod interrupt_mask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_MASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt level registers"]
    pub struct INTERRUPT_LEVEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt level registers"]
    pub mod interrupt_level {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_LEVEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt polarity registers"]
    pub struct INTERRUPT_POLARITY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt polarity registers"]
    pub mod interrupt_polarity {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_POLARITY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt status registers"]
    pub struct INTERRUPT_STATUS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt status registers"]
    pub mod interrupt_status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Raw interrupt status registers"]
    pub struct INTERRUPT_STATUS_RAW {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw interrupt status registers"]
    pub mod interrupt_status_raw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_STATUS_RAW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt debounce registers"]
    pub struct INTERRUPT_DEBOUNCE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt debounce registers"]
    pub mod interrupt_debounce {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_DEBOUNCE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Registers for clearing interrupts"]
    pub struct INTERRUPT_CLEAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Registers for clearing interrupts"]
    pub mod interrupt_clear {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_CLEAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "External port (data input) registers"]
    pub struct DATA_INPUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External port (data input) registers"]
    pub mod data_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA_INPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN0R {
            bits: bool,
        }
        impl PIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN1R {
            bits: bool,
        }
        impl PIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN2R {
            bits: bool,
        }
        impl PIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN3R {
            bits: bool,
        }
        impl PIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN4R {
            bits: bool,
        }
        impl PIN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN5R {
            bits: bool,
        }
        impl PIN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN6R {
            bits: bool,
        }
        impl PIN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN7R {
            bits: bool,
        }
        impl PIN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
        }
    }
    #[doc = "Sync level registers"]
    pub struct SYNC_LEVEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Sync level registers"]
    pub mod sync_level {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYNC_LEVEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ID code"]
    pub struct ID_CODE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "ID code"]
    pub mod id_code {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ID_CODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt both edge type"]
    pub struct INTERRUPT_BOTHEDGE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt both edge type"]
    pub mod interrupt_bothedge {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_BOTHEDGE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 1"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart1::RegisterBlock {
        0x5021_0000 as *const _
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    fn deref(&self) -> &uart1::RegisterBlock {
        unsafe { &*UART1::ptr() }
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 1"]
pub mod uart1 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Receive Buffer Register / Divisor Latch (Low) / Transmit Holding Register (depending on context and R/W)"]
        pub rbr_dll_thr: RBR_DLL_THR,
        #[doc = "0x04 - Divisor Latch (High) / Interrupt Enable Register"]
        pub dlh_ier: DLH_IER,
        #[doc = "0x08 - FIFO Control Register / Interrupt Identification Register"]
        pub fcr_iir: FCR_IIR,
        #[doc = "0x0c - Line Control Register"]
        pub lcr: LCR,
        #[doc = "0x10 - Modem Control Register"]
        pub mcr: MCR,
        #[doc = "0x14 - Line Status Register"]
        pub lsr: LSR,
        #[doc = "0x18 - Modem Status Register"]
        pub msr: MSR,
        #[doc = "0x1c - Scratchpad Register"]
        pub scr: SCR,
        #[doc = "0x20 - Low Power Divisor Latch (Low) Register"]
        pub lpdll: LPDLL,
        #[doc = "0x24 - Low Power Divisor Latch (High) Register"]
        pub lpdlh: LPDLH,
        _reserved0: [u8; 8usize],
        #[doc = "0x30 - Shadow Receive Buffer Register / Shadow Transmit Holding Register (depending on R/W)"]
        pub srbr_sthr: [SRBR_STHR; 16],
        #[doc = "0x70 - FIFO Access Register"]
        pub far: FAR,
        #[doc = "0x74 - Transmit FIFO Read Register"]
        pub tfr: TFR,
        #[doc = "0x78 - Receive FIFO Write Register"]
        pub rfw: RFW,
        #[doc = "0x7c - UART Status Register"]
        pub usr: USR,
        #[doc = "0x80 - Transmit FIFO Level"]
        pub tfl: TFL,
        #[doc = "0x84 - Receive FIFO Level"]
        pub rfl: RFL,
        #[doc = "0x88 - Software Reset Register"]
        pub srr: SRR,
        #[doc = "0x8c - Shadow Request to Send Register"]
        pub srts: SRTS,
        #[doc = "0x90 - Shadow Break Control Register"]
        pub sbcr: SBCR,
        #[doc = "0x94 - Shadow DMA Mode"]
        pub sdmam: SDMAM,
        #[doc = "0x98 - Shadow FIFO Enable"]
        pub sfe: SFE,
        #[doc = "0x9c - Shadow RCVR Trigger Register"]
        pub srt: SRT,
        #[doc = "0xa0 - Shadow TX Empty Trigger Register"]
        pub stet: STET,
        #[doc = "0xa4 - Halt TX Regster"]
        pub htx: HTX,
        #[doc = "0xa8 - DMA Software Acknowledge Register"]
        pub dmasa: DMASA,
        #[doc = "0xac - Transfer Control Register"]
        pub tcr: TCR,
        #[doc = "0xb0 - DE Enable Register"]
        pub de_en: DE_EN,
        #[doc = "0xb4 - RE Enable Register"]
        pub re_en: RE_EN,
        #[doc = "0xb8 - DE Assertion Time Register"]
        pub det: DET,
        #[doc = "0xbc - Turn-Around Time Register"]
        pub tat: TAT,
        #[doc = "0xc0 - Divisor Latch (Fractional) Register"]
        pub dlf: DLF,
        #[doc = "0xc4 - Receive-Mode Address Register"]
        pub rar: RAR,
        #[doc = "0xc8 - Transmit-Mode Address Register"]
        pub tar: TAR,
        #[doc = "0xcc - Line Control Register (Extended)"]
        pub lcr_ext: LCR_EXT,
        _reserved1: [u8; 36usize],
        #[doc = "0xf4 - Component Parameter Register"]
        pub cpr: CPR,
        #[doc = "0xf8 - UART Component Version"]
        pub ucv: UCV,
        #[doc = "0xfc - Component Type Register"]
        pub ctr: CTR,
    }
    #[doc = "Receive Buffer Register / Divisor Latch (Low) / Transmit Holding Register (depending on context and R/W)"]
    pub struct RBR_DLL_THR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive Buffer Register / Divisor Latch (Low) / Transmit Holding Register (depending on context and R/W)"]
    pub mod rbr_dll_thr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RBR_DLL_THR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Divisor Latch (High) / Interrupt Enable Register"]
    pub struct DLH_IER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Divisor Latch (High) / Interrupt Enable Register"]
    pub mod dlh_ier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DLH_IER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "FIFO Control Register / Interrupt Identification Register"]
    pub struct FCR_IIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIFO Control Register / Interrupt Identification Register"]
    pub mod fcr_iir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FCR_IIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Line Control Register"]
    pub struct LCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Line Control Register"]
    pub mod lcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Modem Control Register"]
    pub struct MCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Modem Control Register"]
    pub mod mcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Line Status Register"]
    pub struct LSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Line Status Register"]
    pub mod lsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Modem Status Register"]
    pub struct MSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Modem Status Register"]
    pub mod msr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Scratchpad Register"]
    pub struct SCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Scratchpad Register"]
    pub mod scr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Low Power Divisor Latch (Low) Register"]
    pub struct LPDLL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Low Power Divisor Latch (Low) Register"]
    pub mod lpdll {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LPDLL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Low Power Divisor Latch (High) Register"]
    pub struct LPDLH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Low Power Divisor Latch (High) Register"]
    pub mod lpdlh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LPDLH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow Receive Buffer Register / Shadow Transmit Holding Register (depending on R/W)"]
    pub struct SRBR_STHR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow Receive Buffer Register / Shadow Transmit Holding Register (depending on R/W)"]
    pub mod srbr_sthr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SRBR_STHR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "FIFO Access Register"]
    pub struct FAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIFO Access Register"]
    pub mod far {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Read Register"]
    pub struct TFR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Read Register"]
    pub mod tfr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TFR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Write Register"]
    pub struct RFW {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Write Register"]
    pub mod rfw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RFW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "UART Status Register"]
    pub struct USR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "UART Status Register"]
    pub mod usr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Level"]
    pub struct TFL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Level"]
    pub mod tfl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TFL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Level"]
    pub struct RFL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Level"]
    pub mod rfl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RFL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Software Reset Register"]
    pub struct SRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Software Reset Register"]
    pub mod srr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SRR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow Request to Send Register"]
    pub struct SRTS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow Request to Send Register"]
    pub mod srts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SRTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow Break Control Register"]
    pub struct SBCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow Break Control Register"]
    pub mod sbcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SBCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow DMA Mode"]
    pub struct SDMAM {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow DMA Mode"]
    pub mod sdmam {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SDMAM {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow FIFO Enable"]
    pub struct SFE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow FIFO Enable"]
    pub mod sfe {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SFE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow RCVR Trigger Register"]
    pub struct SRT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow RCVR Trigger Register"]
    pub mod srt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SRT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shadow TX Empty Trigger Register"]
    pub struct STET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Shadow TX Empty Trigger Register"]
    pub mod stet {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Halt TX Regster"]
    pub struct HTX {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Halt TX Regster"]
    pub mod htx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::HTX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Software Acknowledge Register"]
    pub struct DMASA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Software Acknowledge Register"]
    pub mod dmasa {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMASA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transfer Control Register"]
    pub struct TCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transfer Control Register"]
    pub mod tcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DE Enable Register"]
    pub struct DE_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DE Enable Register"]
    pub mod de_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DE_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RE Enable Register"]
    pub struct RE_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RE Enable Register"]
    pub mod re_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RE_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DE Assertion Time Register"]
    pub struct DET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DE Assertion Time Register"]
    pub mod det {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Turn-Around Time Register"]
    pub struct TAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Turn-Around Time Register"]
    pub mod tat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Divisor Latch (Fractional) Register"]
    pub struct DLF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Divisor Latch (Fractional) Register"]
    pub mod dlf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DLF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive-Mode Address Register"]
    pub struct RAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive-Mode Address Register"]
    pub mod rar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit-Mode Address Register"]
    pub struct TAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit-Mode Address Register"]
    pub mod tar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Line Control Register (Extended)"]
    pub struct LCR_EXT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Line Control Register (Extended)"]
    pub mod lcr_ext {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LCR_EXT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Parameter Register"]
    pub struct CPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameter Register"]
    pub mod cpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CPR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "UART Component Version"]
    pub struct UCV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "UART Component Version"]
    pub mod ucv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UCV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Type Register"]
    pub struct CTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Type Register"]
    pub mod ctr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 2"]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart1::RegisterBlock {
        0x5022_0000 as *const _
    }
}
impl Deref for UART2 {
    type Target = uart1::RegisterBlock;
    fn deref(&self) -> &uart1::RegisterBlock {
        unsafe { &*UART2::ptr() }
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 3"]
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart1::RegisterBlock {
        0x5023_0000 as *const _
    }
}
impl Deref for UART3 {
    type Target = uart1::RegisterBlock;
    fn deref(&self) -> &uart1::RegisterBlock {
        unsafe { &*UART3::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 0 (master)"]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi0::RegisterBlock {
        0x5200_0000 as *const _
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        unsafe { &*SPI0::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 0 (master)"]
pub mod spi0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register 0"]
        pub ctrlr0: CTRLR0,
        #[doc = "0x04 - Control Register 1"]
        pub ctrlr1: CTRLR1,
        #[doc = "0x08 - Enable Register"]
        pub ssienr: SSIENR,
        #[doc = "0x0c - Microwire Control Register"]
        pub mwcr: MWCR,
        #[doc = "0x10 - Slave Enable Register"]
        pub ser: SER,
        #[doc = "0x14 - Baud Rate Select"]
        pub baudr: BAUDR,
        #[doc = "0x18 - Transmit FIFO Threshold Level"]
        pub txftlr: TXFTLR,
        #[doc = "0x1c - Receive FIFO Threshold Level"]
        pub rxftlr: RXFTLR,
        #[doc = "0x20 - Transmit FIFO Level Register"]
        pub txflr: TXFLR,
        #[doc = "0x24 - Receive FIFO Level Register"]
        pub rxflr: RXFLR,
        #[doc = "0x28 - Status Register"]
        pub sr: SR,
        #[doc = "0x2c - Interrupt Mask Register"]
        pub imr: IMR,
        #[doc = "0x30 - Interrupt Status Register"]
        pub isr: ISR,
        #[doc = "0x34 - Raw Interrupt Status Register"]
        pub risr: RISR,
        #[doc = "0x38 - Transmit FIFO Overflow Interrupt Clear Register"]
        pub txoicr: TXOICR,
        #[doc = "0x3c - Receive FIFO Overflow Interrupt Clear Register"]
        pub rxoicr: RXOICR,
        #[doc = "0x40 - Receive FIFO Underflow Interrupt Clear Register"]
        pub rxuicr: RXUICR,
        #[doc = "0x44 - Multi-Master Interrupt Clear Register"]
        pub msticr: MSTICR,
        #[doc = "0x48 - Interrupt Clear Register"]
        pub icr: ICR,
        #[doc = "0x4c - DMA Control Register"]
        pub dmacr: DMACR,
        #[doc = "0x50 - DMA Transmit Data Level"]
        pub dmatdlr: DMATDLR,
        #[doc = "0x54 - DMA Receive Data Level"]
        pub dmardlr: DMARDLR,
        #[doc = "0x58 - Identification Register"]
        pub idr: IDR,
        #[doc = "0x5c - DWC_ssi component version"]
        pub ssic_version_id: SSIC_VERSION_ID,
        #[doc = "0x60 - Data Register"]
        pub dr: [DR; 36],
        #[doc = "0xf0 - RX Sample Delay Register"]
        pub rx_sample_delay: RX_SAMPLE_DELAY,
        #[doc = "0xf4 - SPI Control Register"]
        pub spi_ctrlr0: SPI_CTRLR0,
        _reserved0: [u8; 4usize],
        #[doc = "0xfc - XIP Mode bits"]
        pub xip_mode_bits: XIP_MODE_BITS,
        #[doc = "0x100 - XIP INCR transfer opcode"]
        pub xip_incr_inst: XIP_INCR_INST,
        #[doc = "0x104 - XIP WRAP transfer opcode"]
        pub xip_wrap_inst: XIP_WRAP_INST,
        #[doc = "0x108 - XIP Control Register"]
        pub xip_ctrl: XIP_CTRL,
        #[doc = "0x10c - XIP Slave Enable Register"]
        pub xip_ser: XIP_SER,
        #[doc = "0x110 - XIP Receive FIFO Overflow Interrupt Clear Register"]
        pub xrxoicr: XRXOICR,
        #[doc = "0x114 - XIP time out register for continuous transfers"]
        pub xip_cnt_time_out: XIP_CNT_TIME_OUT,
        #[doc = "0x118 - ENDIAN"]
        pub endian: ENDIAN,
    }
    #[doc = "Control Register 0"]
    pub struct CTRLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register 0"]
    pub mod ctrlr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `work_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WORK_MODER {
            #[doc = "MODE_0"]
            MODE0,
            #[doc = "MODE_1"]
            MODE1,
            #[doc = "MODE_2"]
            MODE2,
            #[doc = "MODE_3"]
            MODE3,
        }
        impl WORK_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WORK_MODER::MODE0 => 0,
                    WORK_MODER::MODE1 => 0x01,
                    WORK_MODER::MODE2 => 0x02,
                    WORK_MODER::MODE3 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WORK_MODER {
                match value {
                    0 => WORK_MODER::MODE0,
                    1 => WORK_MODER::MODE1,
                    2 => WORK_MODER::MODE2,
                    3 => WORK_MODER::MODE3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MODE0`"]
            #[inline]
            pub fn is_mode0(&self) -> bool {
                *self == WORK_MODER::MODE0
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline]
            pub fn is_mode1(&self) -> bool {
                *self == WORK_MODER::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline]
            pub fn is_mode2(&self) -> bool {
                *self == WORK_MODER::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline]
            pub fn is_mode3(&self) -> bool {
                *self == WORK_MODER::MODE3
            }
        }
        #[doc = "Possible values of the field `tmod`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TMODR {
            #[doc = "TRANS_RECV"]
            TRANS_RECV,
            #[doc = "TRANS"]
            TRANS,
            #[doc = "RECV"]
            RECV,
            #[doc = "EEROM"]
            EEROM,
        }
        impl TMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TMODR::TRANS_RECV => 0,
                    TMODR::TRANS => 0x01,
                    TMODR::RECV => 0x02,
                    TMODR::EEROM => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TMODR {
                match value {
                    0 => TMODR::TRANS_RECV,
                    1 => TMODR::TRANS,
                    2 => TMODR::RECV,
                    3 => TMODR::EEROM,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TRANS_RECV`"]
            #[inline]
            pub fn is_trans_recv(&self) -> bool {
                *self == TMODR::TRANS_RECV
            }
            #[doc = "Checks if the value of the field is `TRANS`"]
            #[inline]
            pub fn is_trans(&self) -> bool {
                *self == TMODR::TRANS
            }
            #[doc = "Checks if the value of the field is `RECV`"]
            #[inline]
            pub fn is_recv(&self) -> bool {
                *self == TMODR::RECV
            }
            #[doc = "Checks if the value of the field is `EEROM`"]
            #[inline]
            pub fn is_eerom(&self) -> bool {
                *self == TMODR::EEROM
            }
        }
        #[doc = "Possible values of the field `frame_format`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRAME_FORMATR {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "DUAL"]
            DUAL,
            #[doc = "QUAD"]
            QUAD,
            #[doc = "OCTAL"]
            OCTAL,
        }
        impl FRAME_FORMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FRAME_FORMATR::STANDARD => 0,
                    FRAME_FORMATR::DUAL => 0x01,
                    FRAME_FORMATR::QUAD => 0x02,
                    FRAME_FORMATR::OCTAL => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FRAME_FORMATR {
                match value {
                    0 => FRAME_FORMATR::STANDARD,
                    1 => FRAME_FORMATR::DUAL,
                    2 => FRAME_FORMATR::QUAD,
                    3 => FRAME_FORMATR::OCTAL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == FRAME_FORMATR::STANDARD
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline]
            pub fn is_dual(&self) -> bool {
                *self == FRAME_FORMATR::DUAL
            }
            #[doc = "Checks if the value of the field is `QUAD`"]
            #[inline]
            pub fn is_quad(&self) -> bool {
                *self == FRAME_FORMATR::QUAD
            }
            #[doc = "Checks if the value of the field is `OCTAL`"]
            #[inline]
            pub fn is_octal(&self) -> bool {
                *self == FRAME_FORMATR::OCTAL
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA_LENGTHR {
            bits: u8,
        }
        impl DATA_LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `work_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WORK_MODEW {
            #[doc = "MODE_0"]
            MODE0,
            #[doc = "MODE_1"]
            MODE1,
            #[doc = "MODE_2"]
            MODE2,
            #[doc = "MODE_3"]
            MODE3,
        }
        impl WORK_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WORK_MODEW::MODE0 => 0,
                    WORK_MODEW::MODE1 => 1,
                    WORK_MODEW::MODE2 => 2,
                    WORK_MODEW::MODE3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WORK_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WORK_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WORK_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "MODE_0"]
            #[inline]
            pub fn mode0(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE0)
            }
            #[doc = "MODE_1"]
            #[inline]
            pub fn mode1(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE1)
            }
            #[doc = "MODE_2"]
            #[inline]
            pub fn mode2(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE2)
            }
            #[doc = "MODE_3"]
            #[inline]
            pub fn mode3(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `tmod`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TMODW {
            #[doc = "TRANS_RECV"]
            TRANS_RECV,
            #[doc = "TRANS"]
            TRANS,
            #[doc = "RECV"]
            RECV,
            #[doc = "EEROM"]
            EEROM,
        }
        impl TMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TMODW::TRANS_RECV => 0,
                    TMODW::TRANS => 1,
                    TMODW::RECV => 2,
                    TMODW::EEROM => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "TRANS_RECV"]
            #[inline]
            pub fn trans_recv(self) -> &'a mut W {
                self.variant(TMODW::TRANS_RECV)
            }
            #[doc = "TRANS"]
            #[inline]
            pub fn trans(self) -> &'a mut W {
                self.variant(TMODW::TRANS)
            }
            #[doc = "RECV"]
            #[inline]
            pub fn recv(self) -> &'a mut W {
                self.variant(TMODW::RECV)
            }
            #[doc = "EEROM"]
            #[inline]
            pub fn eerom(self) -> &'a mut W {
                self.variant(TMODW::EEROM)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `frame_format`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRAME_FORMATW {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "DUAL"]
            DUAL,
            #[doc = "QUAD"]
            QUAD,
            #[doc = "OCTAL"]
            OCTAL,
        }
        impl FRAME_FORMATW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FRAME_FORMATW::STANDARD => 0,
                    FRAME_FORMATW::DUAL => 1,
                    FRAME_FORMATW::QUAD => 2,
                    FRAME_FORMATW::OCTAL => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_FORMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_FORMATW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FRAME_FORMATW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "STANDARD"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::STANDARD)
            }
            #[doc = "DUAL"]
            #[inline]
            pub fn dual(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::DUAL)
            }
            #[doc = "QUAD"]
            #[inline]
            pub fn quad(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::QUAD)
            }
            #[doc = "OCTAL"]
            #[inline]
            pub fn octal(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::OCTAL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - WORK_MODE"]
            #[inline]
            pub fn work_mode(&self) -> WORK_MODER {
                WORK_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - TRANSFER_MODE"]
            #[inline]
            pub fn tmod(&self) -> TMODR {
                TMODR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 21:22 - FRAME_FORMAT"]
            #[inline]
            pub fn frame_format(&self) -> FRAME_FORMATR {
                FRAME_FORMATR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:20 - DATA_BIT_LENGTH"]
            #[inline]
            pub fn data_length(&self) -> DATA_LENGTHR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATA_LENGTHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - WORK_MODE"]
            #[inline]
            pub fn work_mode(&mut self) -> _WORK_MODEW {
                _WORK_MODEW { w: self }
            }
            #[doc = "Bits 8:9 - TRANSFER_MODE"]
            #[inline]
            pub fn tmod(&mut self) -> _TMODW {
                _TMODW { w: self }
            }
            #[doc = "Bits 21:22 - FRAME_FORMAT"]
            #[inline]
            pub fn frame_format(&mut self) -> _FRAME_FORMATW {
                _FRAME_FORMATW { w: self }
            }
            #[doc = "Bits 16:20 - DATA_BIT_LENGTH"]
            #[inline]
            pub fn data_length(&mut self) -> _DATA_LENGTHW {
                _DATA_LENGTHW { w: self }
            }
        }
    }
    #[doc = "Control Register 1"]
    pub struct CTRLR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register 1"]
    pub mod ctrlr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Enable Register"]
    pub struct SSIENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Enable Register"]
    pub mod ssienr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SSIENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Microwire Control Register"]
    pub struct MWCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Microwire Control Register"]
    pub mod mwcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MWCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Slave Enable Register"]
    pub struct SER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Slave Enable Register"]
    pub mod ser {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Baud Rate Select"]
    pub struct BAUDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud Rate Select"]
    pub mod baudr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BAUDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Threshold Level"]
    pub struct TXFTLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Threshold Level"]
    pub mod txftlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXFTLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Threshold Level"]
    pub struct RXFTLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Threshold Level"]
    pub mod rxftlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXFTLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Level Register"]
    pub struct TXFLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Level Register"]
    pub mod txflr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXFLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Level Register"]
    pub struct RXFLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Level Register"]
    pub mod rxflr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXFLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Status Register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status Register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Mask Register"]
    pub struct IMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Mask Register"]
    pub mod imr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct ISR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ISR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Raw Interrupt Status Register"]
    pub struct RISR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw Interrupt Status Register"]
    pub mod risr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RISR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register"]
    pub struct TXOICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register"]
    pub mod txoicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXOICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Overflow Interrupt Clear Register"]
    pub struct RXOICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Overflow Interrupt Clear Register"]
    pub mod rxoicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXOICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Underflow Interrupt Clear Register"]
    pub struct RXUICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Underflow Interrupt Clear Register"]
    pub mod rxuicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXUICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Multi-Master Interrupt Clear Register"]
    pub struct MSTICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Multi-Master Interrupt Clear Register"]
    pub mod msticr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Clear Register"]
    pub struct ICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Clear Register"]
    pub mod icr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Control Register"]
    pub struct DMACR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Control Register"]
    pub mod dmacr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMACR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Transmit Data Level"]
    pub struct DMATDLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Transmit Data Level"]
    pub mod dmatdlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMATDLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Receive Data Level"]
    pub struct DMARDLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Receive Data Level"]
    pub mod dmardlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMARDLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Identification Register"]
    pub struct IDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Identification Register"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DWC_ssi component version"]
    pub struct SSIC_VERSION_ID {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DWC_ssi component version"]
    pub mod ssic_version_id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SSIC_VERSION_ID {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Data Register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data Register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RX Sample Delay Register"]
    pub struct RX_SAMPLE_DELAY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RX Sample Delay Register"]
    pub mod rx_sample_delay {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RX_SAMPLE_DELAY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "SPI Control Register"]
    pub struct SPI_CTRLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Control Register"]
    pub mod spi_ctrlr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SPI_CTRLR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `aitm`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AITMR {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "ADDR_STANDARD"]
            ADDR_STANDARD,
            #[doc = "AS_FRAME_FORMAT"]
            AS_FRAME_FORMAT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl AITMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    AITMR::STANDARD => 0,
                    AITMR::ADDR_STANDARD => 0x01,
                    AITMR::AS_FRAME_FORMAT => 0x02,
                    AITMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> AITMR {
                match value {
                    0 => AITMR::STANDARD,
                    1 => AITMR::ADDR_STANDARD,
                    2 => AITMR::AS_FRAME_FORMAT,
                    i => AITMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == AITMR::STANDARD
            }
            #[doc = "Checks if the value of the field is `ADDR_STANDARD`"]
            #[inline]
            pub fn is_addr_standard(&self) -> bool {
                *self == AITMR::ADDR_STANDARD
            }
            #[doc = "Checks if the value of the field is `AS_FRAME_FORMAT`"]
            #[inline]
            pub fn is_as_frame_format(&self) -> bool {
                *self == AITMR::AS_FRAME_FORMAT
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR_LENGTHR {
            bits: u8,
        }
        impl ADDR_LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct INST_LENGTHR {
            bits: u8,
        }
        impl INST_LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAIT_CYCLESR {
            bits: u8,
        }
        impl WAIT_CYCLESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `aitm`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AITMW {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "ADDR_STANDARD"]
            ADDR_STANDARD,
            #[doc = "AS_FRAME_FORMAT"]
            AS_FRAME_FORMAT,
        }
        impl AITMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AITMW::STANDARD => 0,
                    AITMW::ADDR_STANDARD => 1,
                    AITMW::AS_FRAME_FORMAT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AITMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AITMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AITMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "STANDARD"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(AITMW::STANDARD)
            }
            #[doc = "ADDR_STANDARD"]
            #[inline]
            pub fn addr_standard(self) -> &'a mut W {
                self.variant(AITMW::ADDR_STANDARD)
            }
            #[doc = "AS_FRAME_FORMAT"]
            #[inline]
            pub fn as_frame_format(self) -> &'a mut W {
                self.variant(AITMW::AS_FRAME_FORMAT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR_LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR_LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INST_LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INST_LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAIT_CYCLESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAIT_CYCLESW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline]
            pub fn aitm(&self) -> AITMR {
                AITMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline]
            pub fn addr_length(&self) -> ADDR_LENGTHR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDR_LENGTHR { bits }
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline]
            pub fn inst_length(&self) -> INST_LENGTHR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INST_LENGTHR { bits }
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline]
            pub fn wait_cycles(&self) -> WAIT_CYCLESR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WAIT_CYCLESR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline]
            pub fn aitm(&mut self) -> _AITMW {
                _AITMW { w: self }
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline]
            pub fn addr_length(&mut self) -> _ADDR_LENGTHW {
                _ADDR_LENGTHW { w: self }
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline]
            pub fn inst_length(&mut self) -> _INST_LENGTHW {
                _INST_LENGTHW { w: self }
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline]
            pub fn wait_cycles(&mut self) -> _WAIT_CYCLESW {
                _WAIT_CYCLESW { w: self }
            }
        }
    }
    #[doc = "XIP Mode bits"]
    pub struct XIP_MODE_BITS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Mode bits"]
    pub mod xip_mode_bits {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_MODE_BITS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP INCR transfer opcode"]
    pub struct XIP_INCR_INST {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP INCR transfer opcode"]
    pub mod xip_incr_inst {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_INCR_INST {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP WRAP transfer opcode"]
    pub struct XIP_WRAP_INST {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP WRAP transfer opcode"]
    pub mod xip_wrap_inst {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_WRAP_INST {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP Control Register"]
    pub struct XIP_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Control Register"]
    pub mod xip_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP Slave Enable Register"]
    pub struct XIP_SER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Slave Enable Register"]
    pub mod xip_ser {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_SER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register"]
    pub struct XRXOICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register"]
    pub mod xrxoicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XRXOICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP time out register for continuous transfers"]
    pub struct XIP_CNT_TIME_OUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP time out register for continuous transfers"]
    pub mod xip_cnt_time_out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_CNT_TIME_OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ENDIAN"]
    pub struct ENDIAN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "ENDIAN"]
    pub mod endian {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENDIAN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Serial Peripheral Interface 1 (master)"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi0::RegisterBlock {
        0x5300_0000 as *const _
    }
}
impl Deref for SPI1 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 2 (slave)"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi2::RegisterBlock {
        0x5024_0000 as *const _
    }
}
impl Deref for SPI2 {
    type Target = spi2::RegisterBlock;
    fn deref(&self) -> &spi2::RegisterBlock {
        unsafe { &*SPI2::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 2 (slave)"]
pub mod spi2 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Dummy register: this peripheral is not implemented yet"]
        pub dummy: DUMMY,
    }
    #[doc = "Dummy register: this peripheral is not implemented yet"]
    pub struct DUMMY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Dummy register: this peripheral is not implemented yet"]
    pub mod dummy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DUMMY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Serial Peripheral Interface 3 (master)"]
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI3 {}
impl SPI3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi3::RegisterBlock {
        0x5400_0000 as *const _
    }
}
impl Deref for SPI3 {
    type Target = spi3::RegisterBlock;
    fn deref(&self) -> &spi3::RegisterBlock {
        unsafe { &*SPI3::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 3 (master)"]
pub mod spi3 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register 0"]
        pub ctrlr0: CTRLR0,
        #[doc = "0x04 - Control Register 1"]
        pub ctrlr1: CTRLR1,
        #[doc = "0x08 - Enable Register"]
        pub ssienr: SSIENR,
        #[doc = "0x0c - Microwire Control Register"]
        pub mwcr: MWCR,
        #[doc = "0x10 - Slave Enable Register"]
        pub ser: SER,
        #[doc = "0x14 - Baud Rate Select"]
        pub baudr: BAUDR,
        #[doc = "0x18 - Transmit FIFO Threshold Level"]
        pub txftlr: TXFTLR,
        #[doc = "0x1c - Receive FIFO Threshold Level"]
        pub rxftlr: RXFTLR,
        #[doc = "0x20 - Transmit FIFO Level Register"]
        pub txflr: TXFLR,
        #[doc = "0x24 - Receive FIFO Level Register"]
        pub rxflr: RXFLR,
        #[doc = "0x28 - Status Register"]
        pub sr: SR,
        #[doc = "0x2c - Interrupt Mask Register"]
        pub imr: IMR,
        #[doc = "0x30 - Interrupt Status Register"]
        pub isr: ISR,
        #[doc = "0x34 - Raw Interrupt Status Register"]
        pub risr: RISR,
        #[doc = "0x38 - Transmit FIFO Overflow Interrupt Clear Register"]
        pub txoicr: TXOICR,
        #[doc = "0x3c - Receive FIFO Overflow Interrupt Clear Register"]
        pub rxoicr: RXOICR,
        #[doc = "0x40 - Receive FIFO Underflow Interrupt Clear Register"]
        pub rxuicr: RXUICR,
        #[doc = "0x44 - Multi-Master Interrupt Clear Register"]
        pub msticr: MSTICR,
        #[doc = "0x48 - Interrupt Clear Register"]
        pub icr: ICR,
        #[doc = "0x4c - DMA Control Register"]
        pub dmacr: DMACR,
        #[doc = "0x50 - DMA Transmit Data Level"]
        pub dmatdlr: DMATDLR,
        #[doc = "0x54 - DMA Receive Data Level"]
        pub dmardlr: DMARDLR,
        #[doc = "0x58 - Identification Register"]
        pub idr: IDR,
        #[doc = "0x5c - DWC_ssi component version"]
        pub ssic_version_id: SSIC_VERSION_ID,
        #[doc = "0x60 - Data Register"]
        pub dr: [DR; 36],
        #[doc = "0xf0 - RX Sample Delay Register"]
        pub rx_sample_delay: RX_SAMPLE_DELAY,
        #[doc = "0xf4 - SPI Control Register"]
        pub spi_ctrlr0: SPI_CTRLR0,
        _reserved0: [u8; 4usize],
        #[doc = "0xfc - XIP Mode bits"]
        pub xip_mode_bits: XIP_MODE_BITS,
        #[doc = "0x100 - XIP INCR transfer opcode"]
        pub xip_incr_inst: XIP_INCR_INST,
        #[doc = "0x104 - XIP WRAP transfer opcode"]
        pub xip_wrap_inst: XIP_WRAP_INST,
        #[doc = "0x108 - XIP Control Register"]
        pub xip_ctrl: XIP_CTRL,
        #[doc = "0x10c - XIP Slave Enable Register"]
        pub xip_ser: XIP_SER,
        #[doc = "0x110 - XIP Receive FIFO Overflow Interrupt Clear Register"]
        pub xrxoicr: XRXOICR,
        #[doc = "0x114 - XIP time out register for continuous transfers"]
        pub xip_cnt_time_out: XIP_CNT_TIME_OUT,
        #[doc = "0x118 - ENDIAN"]
        pub endian: ENDIAN,
    }
    #[doc = "Control Register 0"]
    pub struct CTRLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register 0"]
    pub mod ctrlr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA_LENGTHR {
            bits: u8,
        }
        impl DATA_LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `work_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WORK_MODER {
            #[doc = "MODE_0"]
            MODE0,
            #[doc = "MODE_1"]
            MODE1,
            #[doc = "MODE_2"]
            MODE2,
            #[doc = "MODE_3"]
            MODE3,
        }
        impl WORK_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WORK_MODER::MODE0 => 0,
                    WORK_MODER::MODE1 => 0x01,
                    WORK_MODER::MODE2 => 0x02,
                    WORK_MODER::MODE3 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WORK_MODER {
                match value {
                    0 => WORK_MODER::MODE0,
                    1 => WORK_MODER::MODE1,
                    2 => WORK_MODER::MODE2,
                    3 => WORK_MODER::MODE3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MODE0`"]
            #[inline]
            pub fn is_mode0(&self) -> bool {
                *self == WORK_MODER::MODE0
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline]
            pub fn is_mode1(&self) -> bool {
                *self == WORK_MODER::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline]
            pub fn is_mode2(&self) -> bool {
                *self == WORK_MODER::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline]
            pub fn is_mode3(&self) -> bool {
                *self == WORK_MODER::MODE3
            }
        }
        #[doc = "Possible values of the field `tmod`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TMODR {
            #[doc = "TRANS_RECV"]
            TRANS_RECV,
            #[doc = "TRANS"]
            TRANS,
            #[doc = "RECV"]
            RECV,
            #[doc = "EEROM"]
            EEROM,
        }
        impl TMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TMODR::TRANS_RECV => 0,
                    TMODR::TRANS => 0x01,
                    TMODR::RECV => 0x02,
                    TMODR::EEROM => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TMODR {
                match value {
                    0 => TMODR::TRANS_RECV,
                    1 => TMODR::TRANS,
                    2 => TMODR::RECV,
                    3 => TMODR::EEROM,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TRANS_RECV`"]
            #[inline]
            pub fn is_trans_recv(&self) -> bool {
                *self == TMODR::TRANS_RECV
            }
            #[doc = "Checks if the value of the field is `TRANS`"]
            #[inline]
            pub fn is_trans(&self) -> bool {
                *self == TMODR::TRANS
            }
            #[doc = "Checks if the value of the field is `RECV`"]
            #[inline]
            pub fn is_recv(&self) -> bool {
                *self == TMODR::RECV
            }
            #[doc = "Checks if the value of the field is `EEROM`"]
            #[inline]
            pub fn is_eerom(&self) -> bool {
                *self == TMODR::EEROM
            }
        }
        #[doc = "Possible values of the field `frame_format`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRAME_FORMATR {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "DUAL"]
            DUAL,
            #[doc = "QUAD"]
            QUAD,
            #[doc = "OCTAL"]
            OCTAL,
        }
        impl FRAME_FORMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FRAME_FORMATR::STANDARD => 0,
                    FRAME_FORMATR::DUAL => 0x01,
                    FRAME_FORMATR::QUAD => 0x02,
                    FRAME_FORMATR::OCTAL => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FRAME_FORMATR {
                match value {
                    0 => FRAME_FORMATR::STANDARD,
                    1 => FRAME_FORMATR::DUAL,
                    2 => FRAME_FORMATR::QUAD,
                    3 => FRAME_FORMATR::OCTAL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == FRAME_FORMATR::STANDARD
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline]
            pub fn is_dual(&self) -> bool {
                *self == FRAME_FORMATR::DUAL
            }
            #[doc = "Checks if the value of the field is `QUAD`"]
            #[inline]
            pub fn is_quad(&self) -> bool {
                *self == FRAME_FORMATR::QUAD
            }
            #[doc = "Checks if the value of the field is `OCTAL`"]
            #[inline]
            pub fn is_octal(&self) -> bool {
                *self == FRAME_FORMATR::OCTAL
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `work_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WORK_MODEW {
            #[doc = "MODE_0"]
            MODE0,
            #[doc = "MODE_1"]
            MODE1,
            #[doc = "MODE_2"]
            MODE2,
            #[doc = "MODE_3"]
            MODE3,
        }
        impl WORK_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WORK_MODEW::MODE0 => 0,
                    WORK_MODEW::MODE1 => 1,
                    WORK_MODEW::MODE2 => 2,
                    WORK_MODEW::MODE3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WORK_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WORK_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WORK_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "MODE_0"]
            #[inline]
            pub fn mode0(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE0)
            }
            #[doc = "MODE_1"]
            #[inline]
            pub fn mode1(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE1)
            }
            #[doc = "MODE_2"]
            #[inline]
            pub fn mode2(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE2)
            }
            #[doc = "MODE_3"]
            #[inline]
            pub fn mode3(self) -> &'a mut W {
                self.variant(WORK_MODEW::MODE3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `tmod`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TMODW {
            #[doc = "TRANS_RECV"]
            TRANS_RECV,
            #[doc = "TRANS"]
            TRANS,
            #[doc = "RECV"]
            RECV,
            #[doc = "EEROM"]
            EEROM,
        }
        impl TMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TMODW::TRANS_RECV => 0,
                    TMODW::TRANS => 1,
                    TMODW::RECV => 2,
                    TMODW::EEROM => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TMODW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "TRANS_RECV"]
            #[inline]
            pub fn trans_recv(self) -> &'a mut W {
                self.variant(TMODW::TRANS_RECV)
            }
            #[doc = "TRANS"]
            #[inline]
            pub fn trans(self) -> &'a mut W {
                self.variant(TMODW::TRANS)
            }
            #[doc = "RECV"]
            #[inline]
            pub fn recv(self) -> &'a mut W {
                self.variant(TMODW::RECV)
            }
            #[doc = "EEROM"]
            #[inline]
            pub fn eerom(self) -> &'a mut W {
                self.variant(TMODW::EEROM)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `frame_format`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRAME_FORMATW {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "DUAL"]
            DUAL,
            #[doc = "QUAD"]
            QUAD,
            #[doc = "OCTAL"]
            OCTAL,
        }
        impl FRAME_FORMATW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FRAME_FORMATW::STANDARD => 0,
                    FRAME_FORMATW::DUAL => 1,
                    FRAME_FORMATW::QUAD => 2,
                    FRAME_FORMATW::OCTAL => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_FORMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_FORMATW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FRAME_FORMATW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "STANDARD"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::STANDARD)
            }
            #[doc = "DUAL"]
            #[inline]
            pub fn dual(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::DUAL)
            }
            #[doc = "QUAD"]
            #[inline]
            pub fn quad(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::QUAD)
            }
            #[doc = "OCTAL"]
            #[inline]
            pub fn octal(self) -> &'a mut W {
                self.variant(FRAME_FORMATW::OCTAL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - DATA_BIT_LENGTH"]
            #[inline]
            pub fn data_length(&self) -> DATA_LENGTHR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATA_LENGTHR { bits }
            }
            #[doc = "Bits 8:9 - WORK_MODE"]
            #[inline]
            pub fn work_mode(&self) -> WORK_MODER {
                WORK_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - TRANSFER_MODE"]
            #[inline]
            pub fn tmod(&self) -> TMODR {
                TMODR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 22:23 - FRAME_FORMAT"]
            #[inline]
            pub fn frame_format(&self) -> FRAME_FORMATR {
                FRAME_FORMATR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - DATA_BIT_LENGTH"]
            #[inline]
            pub fn data_length(&mut self) -> _DATA_LENGTHW {
                _DATA_LENGTHW { w: self }
            }
            #[doc = "Bits 8:9 - WORK_MODE"]
            #[inline]
            pub fn work_mode(&mut self) -> _WORK_MODEW {
                _WORK_MODEW { w: self }
            }
            #[doc = "Bits 10:11 - TRANSFER_MODE"]
            #[inline]
            pub fn tmod(&mut self) -> _TMODW {
                _TMODW { w: self }
            }
            #[doc = "Bits 22:23 - FRAME_FORMAT"]
            #[inline]
            pub fn frame_format(&mut self) -> _FRAME_FORMATW {
                _FRAME_FORMATW { w: self }
            }
        }
    }
    #[doc = "Control Register 1"]
    pub struct CTRLR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register 1"]
    pub mod ctrlr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRLR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Enable Register"]
    pub struct SSIENR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Enable Register"]
    pub mod ssienr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SSIENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Microwire Control Register"]
    pub struct MWCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Microwire Control Register"]
    pub mod mwcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MWCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Slave Enable Register"]
    pub struct SER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Slave Enable Register"]
    pub mod ser {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Baud Rate Select"]
    pub struct BAUDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Baud Rate Select"]
    pub mod baudr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BAUDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Threshold Level"]
    pub struct TXFTLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Threshold Level"]
    pub mod txftlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXFTLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Threshold Level"]
    pub struct RXFTLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Threshold Level"]
    pub mod rxftlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXFTLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Level Register"]
    pub struct TXFLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Level Register"]
    pub mod txflr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXFLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Level Register"]
    pub struct RXFLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Level Register"]
    pub mod rxflr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXFLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Status Register"]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status Register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Mask Register"]
    pub struct IMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Mask Register"]
    pub mod imr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct ISR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ISR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Raw Interrupt Status Register"]
    pub struct RISR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw Interrupt Status Register"]
    pub mod risr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RISR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register"]
    pub struct TXOICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register"]
    pub mod txoicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXOICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Overflow Interrupt Clear Register"]
    pub struct RXOICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Overflow Interrupt Clear Register"]
    pub mod rxoicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXOICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receive FIFO Underflow Interrupt Clear Register"]
    pub struct RXUICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Underflow Interrupt Clear Register"]
    pub mod rxuicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXUICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Multi-Master Interrupt Clear Register"]
    pub struct MSTICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Multi-Master Interrupt Clear Register"]
    pub mod msticr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Clear Register"]
    pub struct ICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Clear Register"]
    pub mod icr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Control Register"]
    pub struct DMACR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Control Register"]
    pub mod dmacr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMACR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Transmit Data Level"]
    pub struct DMATDLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Transmit Data Level"]
    pub mod dmatdlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMATDLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DMA Receive Data Level"]
    pub struct DMARDLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Receive Data Level"]
    pub mod dmardlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMARDLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Identification Register"]
    pub struct IDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Identification Register"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "DWC_ssi component version"]
    pub struct SSIC_VERSION_ID {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DWC_ssi component version"]
    pub mod ssic_version_id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SSIC_VERSION_ID {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Data Register"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data Register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RX Sample Delay Register"]
    pub struct RX_SAMPLE_DELAY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RX Sample Delay Register"]
    pub mod rx_sample_delay {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RX_SAMPLE_DELAY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "SPI Control Register"]
    pub struct SPI_CTRLR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI Control Register"]
    pub mod spi_ctrlr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SPI_CTRLR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `aitm`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AITMR {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "ADDR_STANDARD"]
            ADDR_STANDARD,
            #[doc = "AS_FRAME_FORMAT"]
            AS_FRAME_FORMAT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl AITMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    AITMR::STANDARD => 0,
                    AITMR::ADDR_STANDARD => 0x01,
                    AITMR::AS_FRAME_FORMAT => 0x02,
                    AITMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> AITMR {
                match value {
                    0 => AITMR::STANDARD,
                    1 => AITMR::ADDR_STANDARD,
                    2 => AITMR::AS_FRAME_FORMAT,
                    i => AITMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == AITMR::STANDARD
            }
            #[doc = "Checks if the value of the field is `ADDR_STANDARD`"]
            #[inline]
            pub fn is_addr_standard(&self) -> bool {
                *self == AITMR::ADDR_STANDARD
            }
            #[doc = "Checks if the value of the field is `AS_FRAME_FORMAT`"]
            #[inline]
            pub fn is_as_frame_format(&self) -> bool {
                *self == AITMR::AS_FRAME_FORMAT
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR_LENGTHR {
            bits: u8,
        }
        impl ADDR_LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct INST_LENGTHR {
            bits: u8,
        }
        impl INST_LENGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WAIT_CYCLESR {
            bits: u8,
        }
        impl WAIT_CYCLESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `aitm`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AITMW {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "ADDR_STANDARD"]
            ADDR_STANDARD,
            #[doc = "AS_FRAME_FORMAT"]
            AS_FRAME_FORMAT,
        }
        impl AITMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AITMW::STANDARD => 0,
                    AITMW::ADDR_STANDARD => 1,
                    AITMW::AS_FRAME_FORMAT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AITMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AITMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AITMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "STANDARD"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(AITMW::STANDARD)
            }
            #[doc = "ADDR_STANDARD"]
            #[inline]
            pub fn addr_standard(self) -> &'a mut W {
                self.variant(AITMW::ADDR_STANDARD)
            }
            #[doc = "AS_FRAME_FORMAT"]
            #[inline]
            pub fn as_frame_format(self) -> &'a mut W {
                self.variant(AITMW::AS_FRAME_FORMAT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR_LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR_LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INST_LENGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INST_LENGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAIT_CYCLESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAIT_CYCLESW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline]
            pub fn aitm(&self) -> AITMR {
                AITMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline]
            pub fn addr_length(&self) -> ADDR_LENGTHR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDR_LENGTHR { bits }
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline]
            pub fn inst_length(&self) -> INST_LENGTHR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INST_LENGTHR { bits }
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline]
            pub fn wait_cycles(&self) -> WAIT_CYCLESR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WAIT_CYCLESR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline]
            pub fn aitm(&mut self) -> _AITMW {
                _AITMW { w: self }
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline]
            pub fn addr_length(&mut self) -> _ADDR_LENGTHW {
                _ADDR_LENGTHW { w: self }
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline]
            pub fn inst_length(&mut self) -> _INST_LENGTHW {
                _INST_LENGTHW { w: self }
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline]
            pub fn wait_cycles(&mut self) -> _WAIT_CYCLESW {
                _WAIT_CYCLESW { w: self }
            }
        }
    }
    #[doc = "XIP Mode bits"]
    pub struct XIP_MODE_BITS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Mode bits"]
    pub mod xip_mode_bits {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_MODE_BITS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP INCR transfer opcode"]
    pub struct XIP_INCR_INST {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP INCR transfer opcode"]
    pub mod xip_incr_inst {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_INCR_INST {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP WRAP transfer opcode"]
    pub struct XIP_WRAP_INST {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP WRAP transfer opcode"]
    pub mod xip_wrap_inst {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_WRAP_INST {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP Control Register"]
    pub struct XIP_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Control Register"]
    pub mod xip_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP Slave Enable Register"]
    pub struct XIP_SER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Slave Enable Register"]
    pub mod xip_ser {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_SER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register"]
    pub struct XRXOICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register"]
    pub mod xrxoicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XRXOICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "XIP time out register for continuous transfers"]
    pub struct XIP_CNT_TIME_OUT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "XIP time out register for continuous transfers"]
    pub mod xip_cnt_time_out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XIP_CNT_TIME_OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ENDIAN"]
    pub struct ENDIAN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "ENDIAN"]
    pub mod endian {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENDIAN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Inter-Integrated Sound Interface 0"]
pub struct I2S0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S0 {}
impl I2S0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2s0::RegisterBlock {
        0x5025_0000 as *const _
    }
}
impl Deref for I2S0 {
    type Target = i2s0::RegisterBlock;
    fn deref(&self) -> &i2s0::RegisterBlock {
        unsafe { &*I2S0::ptr() }
    }
}
#[doc = "Inter-Integrated Sound Interface 0"]
pub mod i2s0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Enable Register"]
        pub ier: IER,
        #[doc = "0x04 - Receiver Block Enable Register"]
        pub irer: IRER,
        #[doc = "0x08 - Transmitter Block Enable Register"]
        pub iter: ITER,
        #[doc = "0x0c - Clock Generation enable"]
        pub cer: CER,
        #[doc = "0x10 - Clock Configuration Register"]
        pub ccr: CCR,
        #[doc = "0x14 - Receiver Block FIFO Reset Register"]
        pub rxffr: RXFFR,
        #[doc = "0x18 - Transmitter Block FIFO Reset Register"]
        pub txffr: TXFFR,
        _reserved0: [u8; 4usize],
        #[doc = "0x20 - Channel cluster"]
        pub channel: [CHANNEL; 4],
        _reserved1: [u8; 160usize],
        #[doc = "0x1c0 - Receiver Block DMA Register"]
        pub rxdma: RXDMA,
        #[doc = "0x1c4 - Reset Receiver Block DMA Register"]
        pub rrxdma: RRXDMA,
        #[doc = "0x1c8 - Transmitter Block DMA Register"]
        pub txdma: TXDMA,
        #[doc = "0x1cc - Reset Transmitter Block DMA Register"]
        pub rtxdma: RTXDMA,
        _reserved2: [u8; 32usize],
        #[doc = "0x1f0 - Component Parameter Register 2"]
        pub i2s_comp_param_2: I2S_COMP_PARAM_2,
        #[doc = "0x1f4 - Component Parameter Register 1"]
        pub i2s_comp_param_1: I2S_COMP_PARAM_1,
        #[doc = "0x1f8 - Component Version Register"]
        pub i2s_comp_version_1: I2S_COMP_VERSION_1,
        #[doc = "0x1fc - Component Type Register"]
        pub i2s_comp_type: I2S_COMP_TYPE,
    }
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct CHANNEL {
        #[doc = "0x00 - Left Receive or Left Transmit Register"]
        pub left_rxtx: self::channel::LEFT_RXTX,
        #[doc = "0x04 - Right Receive or Right Transmit Register"]
        pub right_rxtx: self::channel::RIGHT_RXTX,
        #[doc = "0x08 - Receive Enable Register"]
        pub rer: self::channel::RER,
        #[doc = "0x0c - Transmit Enable Register"]
        pub ter: self::channel::TER,
        #[doc = "0x10 - Receive Configuration Register"]
        pub rcr: self::channel::RCR,
        #[doc = "0x14 - Transmit Configuration Register"]
        pub tcr: self::channel::TCR,
        #[doc = "0x18 - Interrupt Status Register"]
        pub isr: self::channel::ISR,
        #[doc = "0x1c - Interrupt Mask Register"]
        pub imr: self::channel::IMR,
        #[doc = "0x20 - Receive Overrun Register"]
        pub ror: self::channel::ROR,
        #[doc = "0x24 - Transmit Overrun Register"]
        pub tor: self::channel::TOR,
        #[doc = "0x28 - Receive FIFO Configuration Register"]
        pub rfcr: self::channel::RFCR,
        #[doc = "0x2c - Transmit FIFO Configuration Register"]
        pub tfcr: self::channel::TFCR,
        #[doc = "0x30 - Receive FIFO Flush Register"]
        pub rff: self::channel::RFF,
        #[doc = "0x34 - Transmit FIFO Flush Register"]
        pub tff: self::channel::TFF,
        #[doc = "0x38 - _RESERVED0"]
        pub _reserved: [self::channel::_RESERVED; 2],
    }
    #[doc = r" Register block"]
    #[doc = "Channel cluster"]
    pub mod channel {
        #[doc = "Left Receive or Left Transmit Register"]
        pub struct LEFT_RXTX {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Left Receive or Left Transmit Register"]
        pub mod left_rxtx {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::LEFT_RXTX {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Right Receive or Right Transmit Register"]
        pub struct RIGHT_RXTX {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Right Receive or Right Transmit Register"]
        pub mod right_rxtx {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::RIGHT_RXTX {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Receive Enable Register"]
        pub struct RER {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Receive Enable Register"]
        pub mod rer {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::RER {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct RXCHENXR {
                bits: bool,
            }
            impl RXCHENXR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _RXCHENXW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RXCHENXW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Receive channel enable/disable"]
                #[inline]
                pub fn rxchenx(&self) -> RXCHENXR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    RXCHENXR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Receive channel enable/disable"]
                #[inline]
                pub fn rxchenx(&mut self) -> _RXCHENXW {
                    _RXCHENXW { w: self }
                }
            }
        }
        #[doc = "Transmit Enable Register"]
        pub struct TER {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Transmit Enable Register"]
        pub mod ter {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::TER {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct TXCHENXR {
                bits: bool,
            }
            impl TXCHENXR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _TXCHENXW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TXCHENXW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Transmit channel enable/disable"]
                #[inline]
                pub fn txchenx(&self) -> TXCHENXR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    TXCHENXR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Transmit channel enable/disable"]
                #[inline]
                pub fn txchenx(&mut self) -> _TXCHENXW {
                    _TXCHENXW { w: self }
                }
            }
        }
        #[doc = "Receive Configuration Register"]
        pub struct RCR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Receive Configuration Register"]
        pub mod rcr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::RCR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `wlen`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum WLENR {
                #[doc = "Ignore the word length"]
                IGNORE,
                #[doc = "12-bit data resolution of the receiver"]
                RESOLUTION12,
                #[doc = "16-bit data resolution of the receiver"]
                RESOLUTION16,
                #[doc = "20-bit data resolution of the receiver"]
                RESOLUTION20,
                #[doc = "24-bit data resolution of the receiver"]
                RESOLUTION24,
                #[doc = "32-bit data resolution of the receiver"]
                RESOLUTION32,
                #[doc = r" Reserved"]
                _Reserved(u8),
            }
            impl WLENR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        WLENR::IGNORE => 0,
                        WLENR::RESOLUTION12 => 0x01,
                        WLENR::RESOLUTION16 => 0x02,
                        WLENR::RESOLUTION20 => 0x03,
                        WLENR::RESOLUTION24 => 0x04,
                        WLENR::RESOLUTION32 => 0x05,
                        WLENR::_Reserved(bits) => bits,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> WLENR {
                    match value {
                        0 => WLENR::IGNORE,
                        1 => WLENR::RESOLUTION12,
                        2 => WLENR::RESOLUTION16,
                        3 => WLENR::RESOLUTION20,
                        4 => WLENR::RESOLUTION24,
                        5 => WLENR::RESOLUTION32,
                        i => WLENR::_Reserved(i),
                    }
                }
                #[doc = "Checks if the value of the field is `IGNORE`"]
                #[inline]
                pub fn is_ignore(&self) -> bool {
                    *self == WLENR::IGNORE
                }
                #[doc = "Checks if the value of the field is `RESOLUTION12`"]
                #[inline]
                pub fn is_resolution12(&self) -> bool {
                    *self == WLENR::RESOLUTION12
                }
                #[doc = "Checks if the value of the field is `RESOLUTION16`"]
                #[inline]
                pub fn is_resolution16(&self) -> bool {
                    *self == WLENR::RESOLUTION16
                }
                #[doc = "Checks if the value of the field is `RESOLUTION20`"]
                #[inline]
                pub fn is_resolution20(&self) -> bool {
                    *self == WLENR::RESOLUTION20
                }
                #[doc = "Checks if the value of the field is `RESOLUTION24`"]
                #[inline]
                pub fn is_resolution24(&self) -> bool {
                    *self == WLENR::RESOLUTION24
                }
                #[doc = "Checks if the value of the field is `RESOLUTION32`"]
                #[inline]
                pub fn is_resolution32(&self) -> bool {
                    *self == WLENR::RESOLUTION32
                }
            }
            #[doc = "Values that can be written to the field `wlen`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum WLENW {
                #[doc = "Ignore the word length"]
                IGNORE,
                #[doc = "12-bit data resolution of the receiver"]
                RESOLUTION12,
                #[doc = "16-bit data resolution of the receiver"]
                RESOLUTION16,
                #[doc = "20-bit data resolution of the receiver"]
                RESOLUTION20,
                #[doc = "24-bit data resolution of the receiver"]
                RESOLUTION24,
                #[doc = "32-bit data resolution of the receiver"]
                RESOLUTION32,
            }
            impl WLENW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        WLENW::IGNORE => 0,
                        WLENW::RESOLUTION12 => 1,
                        WLENW::RESOLUTION16 => 2,
                        WLENW::RESOLUTION20 => 3,
                        WLENW::RESOLUTION24 => 4,
                        WLENW::RESOLUTION32 => 5,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _WLENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _WLENW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: WLENW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "Ignore the word length"]
                #[inline]
                pub fn ignore(self) -> &'a mut W {
                    self.variant(WLENW::IGNORE)
                }
                #[doc = "12-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution12(self) -> &'a mut W {
                    self.variant(WLENW::RESOLUTION12)
                }
                #[doc = "16-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution16(self) -> &'a mut W {
                    self.variant(WLENW::RESOLUTION16)
                }
                #[doc = "20-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution20(self) -> &'a mut W {
                    self.variant(WLENW::RESOLUTION20)
                }
                #[doc = "24-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution24(self) -> &'a mut W {
                    self.variant(WLENW::RESOLUTION24)
                }
                #[doc = "32-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution32(self) -> &'a mut W {
                    self.variant(WLENW::RESOLUTION32)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:2 - Desired data resolution of receiver"]
                #[inline]
                pub fn wlen(&self) -> WLENR {
                    WLENR::_from({
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:2 - Desired data resolution of receiver"]
                #[inline]
                pub fn wlen(&mut self) -> _WLENW {
                    _WLENW { w: self }
                }
            }
        }
        #[doc = "Transmit Configuration Register"]
        pub struct TCR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Transmit Configuration Register"]
        pub mod tcr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::TCR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `wlen`"]
            pub type WLENR = super::rcr::WLENR;
            #[doc = "Values that can be written to the field `wlen`"]
            pub type WLENW = super::rcr::WLENW;
            #[doc = r" Proxy"]
            pub struct _WLENW<'a> {
                w: &'a mut W,
            }
            impl<'a> _WLENW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: WLENW) -> &'a mut W {
                    unsafe { self.bits(variant._bits()) }
                }
                #[doc = "Ignore the word length"]
                #[inline]
                pub fn ignore(self) -> &'a mut W {
                    self.variant(super::rcr::WLENW::IGNORE)
                }
                #[doc = "12-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution12(self) -> &'a mut W {
                    self.variant(super::rcr::WLENW::RESOLUTION12)
                }
                #[doc = "16-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution16(self) -> &'a mut W {
                    self.variant(super::rcr::WLENW::RESOLUTION16)
                }
                #[doc = "20-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution20(self) -> &'a mut W {
                    self.variant(super::rcr::WLENW::RESOLUTION20)
                }
                #[doc = "24-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution24(self) -> &'a mut W {
                    self.variant(super::rcr::WLENW::RESOLUTION24)
                }
                #[doc = "32-bit data resolution of the receiver"]
                #[inline]
                pub fn resolution32(self) -> &'a mut W {
                    self.variant(super::rcr::WLENW::RESOLUTION32)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:2 - Desired data resolution of transmitter"]
                #[inline]
                pub fn wlen(&self) -> WLENR {
                    WLENR::_from({
                        const MASK: u8 = 0x07;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:2 - Desired data resolution of transmitter"]
                #[inline]
                pub fn wlen(&mut self) -> _WLENW {
                    _WLENW { w: self }
                }
            }
        }
        #[doc = "Interrupt Status Register"]
        pub struct ISR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Interrupt Status Register"]
        pub mod isr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            impl super::ISR {
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
            }
            #[doc = r" Value of the field"]
            pub struct RXDAR {
                bits: bool,
            }
            impl RXDAR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct RXFOR {
                bits: bool,
            }
            impl RXFOR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TXFER {
                bits: bool,
            }
            impl TXFER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TXFOR {
                bits: bool,
            }
            impl TXFOR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Status of receiver data avaliable interrupt"]
                #[inline]
                pub fn rxda(&self) -> RXDAR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    RXDAR { bits }
                }
                #[doc = "Bit 1 - Status of data overrun interrupt for RX channel"]
                #[inline]
                pub fn rxfo(&self) -> RXFOR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    RXFOR { bits }
                }
                #[doc = "Bit 4 - Status of transmit empty triger interrupt"]
                #[inline]
                pub fn txfe(&self) -> TXFER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    TXFER { bits }
                }
                #[doc = "Bit 5 - Status of data overrun interrupt for the TX channel"]
                #[inline]
                pub fn txfo(&self) -> TXFOR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    TXFOR { bits }
                }
            }
        }
        #[doc = "Interrupt Mask Register"]
        pub struct IMR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Interrupt Mask Register"]
        pub mod imr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::IMR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct RXDAMR {
                bits: bool,
            }
            impl RXDAMR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct RXFOMR {
                bits: bool,
            }
            impl RXFOMR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TXFEMR {
                bits: bool,
            }
            impl TXFEMR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct TXFOMR {
                bits: bool,
            }
            impl TXFOMR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _RXDAMW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RXDAMW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _RXFOMW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RXFOMW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _TXFEMW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TXFEMW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _TXFOMW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TXFOMW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Mask RX FIFO data avaliable interrupt"]
                #[inline]
                pub fn rxdam(&self) -> RXDAMR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    RXDAMR { bits }
                }
                #[doc = "Bit 1 - Mask RX FIFO overrun interrupt"]
                #[inline]
                pub fn rxfom(&self) -> RXFOMR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    RXFOMR { bits }
                }
                #[doc = "Bit 4 - Mask TX FIFO empty interrupt"]
                #[inline]
                pub fn txfem(&self) -> TXFEMR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 4;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    TXFEMR { bits }
                }
                #[doc = "Bit 5 - Mask TX FIFO overrun interrupt"]
                #[inline]
                pub fn txfom(&self) -> TXFOMR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 5;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    TXFOMR { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Mask RX FIFO data avaliable interrupt"]
                #[inline]
                pub fn rxdam(&mut self) -> _RXDAMW {
                    _RXDAMW { w: self }
                }
                #[doc = "Bit 1 - Mask RX FIFO overrun interrupt"]
                #[inline]
                pub fn rxfom(&mut self) -> _RXFOMW {
                    _RXFOMW { w: self }
                }
                #[doc = "Bit 4 - Mask TX FIFO empty interrupt"]
                #[inline]
                pub fn txfem(&mut self) -> _TXFEMW {
                    _TXFEMW { w: self }
                }
                #[doc = "Bit 5 - Mask TX FIFO overrun interrupt"]
                #[inline]
                pub fn txfom(&mut self) -> _TXFOMW {
                    _TXFOMW { w: self }
                }
            }
        }
        #[doc = "Receive Overrun Register"]
        pub struct ROR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Receive Overrun Register"]
        pub mod ror {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            impl super::ROR {
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
            }
            #[doc = r" Value of the field"]
            pub struct RXCHOR {
                bits: bool,
            }
            impl RXCHOR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Read this bit to clear RX FIFO data overrun interrupt. 0x0 for RX FIFO write valid, 0x1 for RX FIFO write overrun"]
                #[inline]
                pub fn rxcho(&self) -> RXCHOR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    RXCHOR { bits }
                }
            }
        }
        #[doc = "Transmit Overrun Register"]
        pub struct TOR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Transmit Overrun Register"]
        pub mod tor {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            impl super::TOR {
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
            }
            #[doc = r" Value of the field"]
            pub struct TXCHOR {
                bits: bool,
            }
            impl TXCHOR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Read this bit to clear TX FIFO data overrun interrupt. 0x0 for TX FIFO write valid, 0x1 for TX FIFO write overrun"]
                #[inline]
                pub fn txcho(&self) -> TXCHOR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    TXCHOR { bits }
                }
            }
        }
        #[doc = "Receive FIFO Configuration Register"]
        pub struct RFCR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Receive FIFO Configuration Register"]
        pub mod rfcr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::RFCR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `rxchdt`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum RXCHDTR {
                #[doc = "Interrupt trigger when FIFO level is 1"]
                LEVEL1,
                #[doc = "Interrupt trigger when FIFO level is 2"]
                LEVEL2,
                #[doc = "Interrupt trigger when FIFO level is 3"]
                LEVEL3,
                #[doc = "Interrupt trigger when FIFO level is 4"]
                LEVEL4,
                #[doc = "Interrupt trigger when FIFO level is 5"]
                LEVEL5,
                #[doc = "Interrupt trigger when FIFO level is 6"]
                LEVEL6,
                #[doc = "Interrupt trigger when FIFO level is 7"]
                LEVEL7,
                #[doc = "Interrupt trigger when FIFO level is 8"]
                LEVEL8,
                #[doc = "Interrupt trigger when FIFO level is 9"]
                LEVEL9,
                #[doc = "Interrupt trigger when FIFO level is 10"]
                LEVEL10,
                #[doc = "Interrupt trigger when FIFO level is 11"]
                LEVEL11,
                #[doc = "Interrupt trigger when FIFO level is 12"]
                LEVEL12,
                #[doc = "Interrupt trigger when FIFO level is 13"]
                LEVEL13,
                #[doc = "Interrupt trigger when FIFO level is 14"]
                LEVEL14,
                #[doc = "Interrupt trigger when FIFO level is 15"]
                LEVEL15,
                #[doc = "Interrupt trigger when FIFO level is 16"]
                LEVEL16,
            }
            impl RXCHDTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bits(&self) -> u8 {
                    match *self {
                        RXCHDTR::LEVEL1 => 0,
                        RXCHDTR::LEVEL2 => 0x01,
                        RXCHDTR::LEVEL3 => 0x02,
                        RXCHDTR::LEVEL4 => 0x03,
                        RXCHDTR::LEVEL5 => 0x04,
                        RXCHDTR::LEVEL6 => 0x05,
                        RXCHDTR::LEVEL7 => 0x06,
                        RXCHDTR::LEVEL8 => 0x07,
                        RXCHDTR::LEVEL9 => 0x08,
                        RXCHDTR::LEVEL10 => 0x09,
                        RXCHDTR::LEVEL11 => 0x0a,
                        RXCHDTR::LEVEL12 => 0x0b,
                        RXCHDTR::LEVEL13 => 0x0c,
                        RXCHDTR::LEVEL14 => 0x0d,
                        RXCHDTR::LEVEL15 => 0x0e,
                        RXCHDTR::LEVEL16 => 0x0f,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: u8) -> RXCHDTR {
                    match value {
                        0 => RXCHDTR::LEVEL1,
                        1 => RXCHDTR::LEVEL2,
                        2 => RXCHDTR::LEVEL3,
                        3 => RXCHDTR::LEVEL4,
                        4 => RXCHDTR::LEVEL5,
                        5 => RXCHDTR::LEVEL6,
                        6 => RXCHDTR::LEVEL7,
                        7 => RXCHDTR::LEVEL8,
                        8 => RXCHDTR::LEVEL9,
                        9 => RXCHDTR::LEVEL10,
                        10 => RXCHDTR::LEVEL11,
                        11 => RXCHDTR::LEVEL12,
                        12 => RXCHDTR::LEVEL13,
                        13 => RXCHDTR::LEVEL14,
                        14 => RXCHDTR::LEVEL15,
                        15 => RXCHDTR::LEVEL16,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `LEVEL1`"]
                #[inline]
                pub fn is_level1(&self) -> bool {
                    *self == RXCHDTR::LEVEL1
                }
                #[doc = "Checks if the value of the field is `LEVEL2`"]
                #[inline]
                pub fn is_level2(&self) -> bool {
                    *self == RXCHDTR::LEVEL2
                }
                #[doc = "Checks if the value of the field is `LEVEL3`"]
                #[inline]
                pub fn is_level3(&self) -> bool {
                    *self == RXCHDTR::LEVEL3
                }
                #[doc = "Checks if the value of the field is `LEVEL4`"]
                #[inline]
                pub fn is_level4(&self) -> bool {
                    *self == RXCHDTR::LEVEL4
                }
                #[doc = "Checks if the value of the field is `LEVEL5`"]
                #[inline]
                pub fn is_level5(&self) -> bool {
                    *self == RXCHDTR::LEVEL5
                }
                #[doc = "Checks if the value of the field is `LEVEL6`"]
                #[inline]
                pub fn is_level6(&self) -> bool {
                    *self == RXCHDTR::LEVEL6
                }
                #[doc = "Checks if the value of the field is `LEVEL7`"]
                #[inline]
                pub fn is_level7(&self) -> bool {
                    *self == RXCHDTR::LEVEL7
                }
                #[doc = "Checks if the value of the field is `LEVEL8`"]
                #[inline]
                pub fn is_level8(&self) -> bool {
                    *self == RXCHDTR::LEVEL8
                }
                #[doc = "Checks if the value of the field is `LEVEL9`"]
                #[inline]
                pub fn is_level9(&self) -> bool {
                    *self == RXCHDTR::LEVEL9
                }
                #[doc = "Checks if the value of the field is `LEVEL10`"]
                #[inline]
                pub fn is_level10(&self) -> bool {
                    *self == RXCHDTR::LEVEL10
                }
                #[doc = "Checks if the value of the field is `LEVEL11`"]
                #[inline]
                pub fn is_level11(&self) -> bool {
                    *self == RXCHDTR::LEVEL11
                }
                #[doc = "Checks if the value of the field is `LEVEL12`"]
                #[inline]
                pub fn is_level12(&self) -> bool {
                    *self == RXCHDTR::LEVEL12
                }
                #[doc = "Checks if the value of the field is `LEVEL13`"]
                #[inline]
                pub fn is_level13(&self) -> bool {
                    *self == RXCHDTR::LEVEL13
                }
                #[doc = "Checks if the value of the field is `LEVEL14`"]
                #[inline]
                pub fn is_level14(&self) -> bool {
                    *self == RXCHDTR::LEVEL14
                }
                #[doc = "Checks if the value of the field is `LEVEL15`"]
                #[inline]
                pub fn is_level15(&self) -> bool {
                    *self == RXCHDTR::LEVEL15
                }
                #[doc = "Checks if the value of the field is `LEVEL16`"]
                #[inline]
                pub fn is_level16(&self) -> bool {
                    *self == RXCHDTR::LEVEL16
                }
            }
            #[doc = "Values that can be written to the field `rxchdt`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum RXCHDTW {
                #[doc = "Interrupt trigger when FIFO level is 1"]
                LEVEL1,
                #[doc = "Interrupt trigger when FIFO level is 2"]
                LEVEL2,
                #[doc = "Interrupt trigger when FIFO level is 3"]
                LEVEL3,
                #[doc = "Interrupt trigger when FIFO level is 4"]
                LEVEL4,
                #[doc = "Interrupt trigger when FIFO level is 5"]
                LEVEL5,
                #[doc = "Interrupt trigger when FIFO level is 6"]
                LEVEL6,
                #[doc = "Interrupt trigger when FIFO level is 7"]
                LEVEL7,
                #[doc = "Interrupt trigger when FIFO level is 8"]
                LEVEL8,
                #[doc = "Interrupt trigger when FIFO level is 9"]
                LEVEL9,
                #[doc = "Interrupt trigger when FIFO level is 10"]
                LEVEL10,
                #[doc = "Interrupt trigger when FIFO level is 11"]
                LEVEL11,
                #[doc = "Interrupt trigger when FIFO level is 12"]
                LEVEL12,
                #[doc = "Interrupt trigger when FIFO level is 13"]
                LEVEL13,
                #[doc = "Interrupt trigger when FIFO level is 14"]
                LEVEL14,
                #[doc = "Interrupt trigger when FIFO level is 15"]
                LEVEL15,
                #[doc = "Interrupt trigger when FIFO level is 16"]
                LEVEL16,
            }
            impl RXCHDTW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> u8 {
                    match *self {
                        RXCHDTW::LEVEL1 => 0,
                        RXCHDTW::LEVEL2 => 1,
                        RXCHDTW::LEVEL3 => 2,
                        RXCHDTW::LEVEL4 => 3,
                        RXCHDTW::LEVEL5 => 4,
                        RXCHDTW::LEVEL6 => 5,
                        RXCHDTW::LEVEL7 => 6,
                        RXCHDTW::LEVEL8 => 7,
                        RXCHDTW::LEVEL9 => 8,
                        RXCHDTW::LEVEL10 => 9,
                        RXCHDTW::LEVEL11 => 10,
                        RXCHDTW::LEVEL12 => 11,
                        RXCHDTW::LEVEL13 => 12,
                        RXCHDTW::LEVEL14 => 13,
                        RXCHDTW::LEVEL15 => 14,
                        RXCHDTW::LEVEL16 => 15,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _RXCHDTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RXCHDTW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: RXCHDTW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Interrupt trigger when FIFO level is 1"]
                #[inline]
                pub fn level1(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL1)
                }
                #[doc = "Interrupt trigger when FIFO level is 2"]
                #[inline]
                pub fn level2(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL2)
                }
                #[doc = "Interrupt trigger when FIFO level is 3"]
                #[inline]
                pub fn level3(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL3)
                }
                #[doc = "Interrupt trigger when FIFO level is 4"]
                #[inline]
                pub fn level4(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL4)
                }
                #[doc = "Interrupt trigger when FIFO level is 5"]
                #[inline]
                pub fn level5(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL5)
                }
                #[doc = "Interrupt trigger when FIFO level is 6"]
                #[inline]
                pub fn level6(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL6)
                }
                #[doc = "Interrupt trigger when FIFO level is 7"]
                #[inline]
                pub fn level7(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL7)
                }
                #[doc = "Interrupt trigger when FIFO level is 8"]
                #[inline]
                pub fn level8(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL8)
                }
                #[doc = "Interrupt trigger when FIFO level is 9"]
                #[inline]
                pub fn level9(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL9)
                }
                #[doc = "Interrupt trigger when FIFO level is 10"]
                #[inline]
                pub fn level10(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL10)
                }
                #[doc = "Interrupt trigger when FIFO level is 11"]
                #[inline]
                pub fn level11(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL11)
                }
                #[doc = "Interrupt trigger when FIFO level is 12"]
                #[inline]
                pub fn level12(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL12)
                }
                #[doc = "Interrupt trigger when FIFO level is 13"]
                #[inline]
                pub fn level13(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL13)
                }
                #[doc = "Interrupt trigger when FIFO level is 14"]
                #[inline]
                pub fn level14(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL14)
                }
                #[doc = "Interrupt trigger when FIFO level is 15"]
                #[inline]
                pub fn level15(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL15)
                }
                #[doc = "Interrupt trigger when FIFO level is 16"]
                #[inline]
                pub fn level16(self) -> &'a mut W {
                    self.variant(RXCHDTW::LEVEL16)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:3 - Trigger level in the RX FIFO at which the receiver data available interrupt generate"]
                #[inline]
                pub fn rxchdt(&self) -> RXCHDTR {
                    RXCHDTR::_from({
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:3 - Trigger level in the RX FIFO at which the receiver data available interrupt generate"]
                #[inline]
                pub fn rxchdt(&mut self) -> _RXCHDTW {
                    _RXCHDTW { w: self }
                }
            }
        }
        #[doc = "Transmit FIFO Configuration Register"]
        pub struct TFCR {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Transmit FIFO Configuration Register"]
        pub mod tfcr {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::TFCR {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `txchet`"]
            pub type TXCHETR = super::rfcr::RXCHDTR;
            #[doc = "Values that can be written to the field `txchet`"]
            pub type TXCHETW = super::rfcr::RXCHDTW;
            #[doc = r" Proxy"]
            pub struct _TXCHETW<'a> {
                w: &'a mut W,
            }
            impl<'a> _TXCHETW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: TXCHETW) -> &'a mut W {
                    {
                        self.bits(variant._bits())
                    }
                }
                #[doc = "Interrupt trigger when FIFO level is 1"]
                #[inline]
                pub fn level1(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL1)
                }
                #[doc = "Interrupt trigger when FIFO level is 2"]
                #[inline]
                pub fn level2(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL2)
                }
                #[doc = "Interrupt trigger when FIFO level is 3"]
                #[inline]
                pub fn level3(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL3)
                }
                #[doc = "Interrupt trigger when FIFO level is 4"]
                #[inline]
                pub fn level4(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL4)
                }
                #[doc = "Interrupt trigger when FIFO level is 5"]
                #[inline]
                pub fn level5(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL5)
                }
                #[doc = "Interrupt trigger when FIFO level is 6"]
                #[inline]
                pub fn level6(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL6)
                }
                #[doc = "Interrupt trigger when FIFO level is 7"]
                #[inline]
                pub fn level7(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL7)
                }
                #[doc = "Interrupt trigger when FIFO level is 8"]
                #[inline]
                pub fn level8(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL8)
                }
                #[doc = "Interrupt trigger when FIFO level is 9"]
                #[inline]
                pub fn level9(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL9)
                }
                #[doc = "Interrupt trigger when FIFO level is 10"]
                #[inline]
                pub fn level10(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL10)
                }
                #[doc = "Interrupt trigger when FIFO level is 11"]
                #[inline]
                pub fn level11(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL11)
                }
                #[doc = "Interrupt trigger when FIFO level is 12"]
                #[inline]
                pub fn level12(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL12)
                }
                #[doc = "Interrupt trigger when FIFO level is 13"]
                #[inline]
                pub fn level13(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL13)
                }
                #[doc = "Interrupt trigger when FIFO level is 14"]
                #[inline]
                pub fn level14(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL14)
                }
                #[doc = "Interrupt trigger when FIFO level is 15"]
                #[inline]
                pub fn level15(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL15)
                }
                #[doc = "Interrupt trigger when FIFO level is 16"]
                #[inline]
                pub fn level16(self) -> &'a mut W {
                    self.variant(super::rfcr::RXCHDTW::LEVEL16)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bits(self, value: u8) -> &'a mut W {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bits 0:3 - Trigger level in the TX FIFO at which the transmitter data available interrupt generate"]
                #[inline]
                pub fn txchet(&self) -> TXCHETR {
                    TXCHETR::_from({
                        const MASK: u8 = 0x0f;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) as u8
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bits 0:3 - Trigger level in the TX FIFO at which the transmitter data available interrupt generate"]
                #[inline]
                pub fn txchet(&mut self) -> _TXCHETW {
                    _TXCHETW { w: self }
                }
            }
        }
        #[doc = "Receive FIFO Flush Register"]
        pub struct RFF {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Receive FIFO Flush Register"]
        pub mod rff {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::RFF {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `rxchfr`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum RXCHFRR {
                #[doc = "Not flush an individual FIFO"]
                NOT_FLUSH,
                #[doc = "Flush an indiviadual FIFO"]
                FLUSH,
            }
            impl RXCHFRR {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        RXCHFRR::NOT_FLUSH => false,
                        RXCHFRR::FLUSH => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> RXCHFRR {
                    match value {
                        false => RXCHFRR::NOT_FLUSH,
                        true => RXCHFRR::FLUSH,
                    }
                }
                #[doc = "Checks if the value of the field is `NOT_FLUSH`"]
                #[inline]
                pub fn is_not_flush(&self) -> bool {
                    *self == RXCHFRR::NOT_FLUSH
                }
                #[doc = "Checks if the value of the field is `FLUSH`"]
                #[inline]
                pub fn is_flush(&self) -> bool {
                    *self == RXCHFRR::FLUSH
                }
            }
            #[doc = "Values that can be written to the field `rxchfr`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum RXCHFRW {
                #[doc = "Not flush an individual FIFO"]
                NOT_FLUSH,
                #[doc = "Flush an indiviadual FIFO"]
                FLUSH,
            }
            impl RXCHFRW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        RXCHFRW::NOT_FLUSH => false,
                        RXCHFRW::FLUSH => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _RXCHFRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RXCHFRW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: RXCHFRW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Not flush an individual FIFO"]
                #[inline]
                pub fn not_flush(self) -> &'a mut W {
                    self.variant(RXCHFRW::NOT_FLUSH)
                }
                #[doc = "Flush an indiviadual FIFO"]
                #[inline]
                pub fn flush(self) -> &'a mut W {
                    self.variant(RXCHFRW::FLUSH)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Receiver channel FIFO reset"]
                #[inline]
                pub fn rxchfr(&self) -> RXCHFRR {
                    RXCHFRR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Receiver channel FIFO reset"]
                #[inline]
                pub fn rxchfr(&mut self) -> _RXCHFRW {
                    _RXCHFRW { w: self }
                }
            }
        }
        #[doc = "Transmit FIFO Flush Register"]
        pub struct TFF {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Transmit FIFO Flush Register"]
        pub mod tff {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::TFF {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = "Possible values of the field `rtxchfr`"]
            pub type RTXCHFRR = super::rff::RXCHFRR;
            #[doc = "Values that can be written to the field `rtxchfr`"]
            pub type RTXCHFRW = super::rff::RXCHFRW;
            #[doc = r" Proxy"]
            pub struct _RTXCHFRW<'a> {
                w: &'a mut W,
            }
            impl<'a> _RTXCHFRW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: RTXCHFRW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "Not flush an individual FIFO"]
                #[inline]
                pub fn not_flush(self) -> &'a mut W {
                    self.variant(super::rff::RXCHFRW::NOT_FLUSH)
                }
                #[doc = "Flush an indiviadual FIFO"]
                #[inline]
                pub fn flush(self) -> &'a mut W {
                    self.variant(super::rff::RXCHFRW::FLUSH)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - Transmit channel FIFO reset"]
                #[inline]
                pub fn rtxchfr(&self) -> RTXCHFRR {
                    RTXCHFRR::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - Transmit channel FIFO reset"]
                #[inline]
                pub fn rtxchfr(&mut self) -> _RTXCHFRW {
                    _RTXCHFRW { w: self }
                }
            }
        }
        #[doc = "_RESERVED0"]
        pub struct _RESERVED {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "_RESERVED0"]
        pub mod _reserved {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::_RESERVED {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
    }
    #[doc = "Enable Register"]
    pub struct IER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Enable Register"]
    pub mod ier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IENR {
            bits: bool,
        }
        impl IENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - I2S Enable"]
            #[inline]
            pub fn ien(&self) -> IENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - I2S Enable"]
            #[inline]
            pub fn ien(&mut self) -> _IENW {
                _IENW { w: self }
            }
        }
    }
    #[doc = "Receiver Block Enable Register"]
    pub struct IRER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receiver Block Enable Register"]
    pub mod irer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXENR {
            bits: bool,
        }
        impl RXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver block enable"]
            #[inline]
            pub fn rxen(&self) -> RXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receiver block enable"]
            #[inline]
            pub fn rxen(&mut self) -> _RXENW {
                _RXENW { w: self }
            }
        }
    }
    #[doc = "Transmitter Block Enable Register"]
    pub struct ITER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmitter Block Enable Register"]
    pub mod iter {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ITER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXENR {
            bits: bool,
        }
        impl TXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline]
            pub fn txen(&self) -> TXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline]
            pub fn txen(&mut self) -> _TXENW {
                _TXENW { w: self }
            }
        }
    }
    #[doc = "Clock Generation enable"]
    pub struct CER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock Generation enable"]
    pub mod cer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKENR {
            bits: bool,
        }
        impl CLKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline]
            pub fn clken(&self) -> CLKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLKENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline]
            pub fn clken(&mut self) -> _CLKENW {
                _CLKENW { w: self }
            }
        }
    }
    #[doc = "Clock Configuration Register"]
    pub struct CCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock Configuration Register"]
    pub mod ccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `clk_gate`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_GATER {
            #[doc = "Clock gating is disabled"]
            NO,
            #[doc = "Gating after 12 sclk cycles"]
            CYCLES12,
            #[doc = "Gating after 16 sclk cycles"]
            CYCLES16,
            #[doc = "Gating after 20 sclk cycles"]
            CYCLES20,
            #[doc = "Gating after 24 sclk cycles"]
            CYCLES24,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_GATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_GATER::NO => 0,
                    CLK_GATER::CYCLES12 => 0x01,
                    CLK_GATER::CYCLES16 => 0x02,
                    CLK_GATER::CYCLES20 => 0x03,
                    CLK_GATER::CYCLES24 => 0x04,
                    CLK_GATER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_GATER {
                match value {
                    0 => CLK_GATER::NO,
                    1 => CLK_GATER::CYCLES12,
                    2 => CLK_GATER::CYCLES16,
                    3 => CLK_GATER::CYCLES20,
                    4 => CLK_GATER::CYCLES24,
                    i => CLK_GATER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NO`"]
            #[inline]
            pub fn is_no(&self) -> bool {
                *self == CLK_GATER::NO
            }
            #[doc = "Checks if the value of the field is `CYCLES12`"]
            #[inline]
            pub fn is_cycles12(&self) -> bool {
                *self == CLK_GATER::CYCLES12
            }
            #[doc = "Checks if the value of the field is `CYCLES16`"]
            #[inline]
            pub fn is_cycles16(&self) -> bool {
                *self == CLK_GATER::CYCLES16
            }
            #[doc = "Checks if the value of the field is `CYCLES20`"]
            #[inline]
            pub fn is_cycles20(&self) -> bool {
                *self == CLK_GATER::CYCLES20
            }
            #[doc = "Checks if the value of the field is `CYCLES24`"]
            #[inline]
            pub fn is_cycles24(&self) -> bool {
                *self == CLK_GATER::CYCLES24
            }
        }
        #[doc = "Possible values of the field `clk_word_size`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_WORD_SIZER {
            #[doc = "16 sclk cycles"]
            CYCLES16,
            #[doc = "24 sclk cycles"]
            CYCLES24,
            #[doc = "32 sclk cycles"]
            CYCLES32,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_WORD_SIZER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_WORD_SIZER::CYCLES16 => 0,
                    CLK_WORD_SIZER::CYCLES24 => 0x01,
                    CLK_WORD_SIZER::CYCLES32 => 0x02,
                    CLK_WORD_SIZER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLK_WORD_SIZER {
                match value {
                    0 => CLK_WORD_SIZER::CYCLES16,
                    1 => CLK_WORD_SIZER::CYCLES24,
                    2 => CLK_WORD_SIZER::CYCLES32,
                    i => CLK_WORD_SIZER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CYCLES16`"]
            #[inline]
            pub fn is_cycles16(&self) -> bool {
                *self == CLK_WORD_SIZER::CYCLES16
            }
            #[doc = "Checks if the value of the field is `CYCLES24`"]
            #[inline]
            pub fn is_cycles24(&self) -> bool {
                *self == CLK_WORD_SIZER::CYCLES24
            }
            #[doc = "Checks if the value of the field is `CYCLES32`"]
            #[inline]
            pub fn is_cycles32(&self) -> bool {
                *self == CLK_WORD_SIZER::CYCLES32
            }
        }
        #[doc = "Possible values of the field `align_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALIGN_MODER {
            #[doc = "Standard I2S format"]
            STANDARD,
            #[doc = "Right aligned format"]
            RIGHT,
            #[doc = "Left aligned format"]
            LEFT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ALIGN_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ALIGN_MODER::STANDARD => 0x01,
                    ALIGN_MODER::RIGHT => 0x02,
                    ALIGN_MODER::LEFT => 0x04,
                    ALIGN_MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ALIGN_MODER {
                match value {
                    1 => ALIGN_MODER::STANDARD,
                    2 => ALIGN_MODER::RIGHT,
                    4 => ALIGN_MODER::LEFT,
                    i => ALIGN_MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == ALIGN_MODER::STANDARD
            }
            #[doc = "Checks if the value of the field is `RIGHT`"]
            #[inline]
            pub fn is_right(&self) -> bool {
                *self == ALIGN_MODER::RIGHT
            }
            #[doc = "Checks if the value of the field is `LEFT`"]
            #[inline]
            pub fn is_left(&self) -> bool {
                *self == ALIGN_MODER::LEFT
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_TX_ENR {
            bits: bool,
        }
        impl DMA_TX_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_RX_ENR {
            bits: bool,
        }
        impl DMA_RX_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_DIVIDE_16R {
            bits: bool,
        }
        impl DMA_DIVIDE_16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIGN_EXPAND_ENR {
            bits: bool,
        }
        impl SIGN_EXPAND_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `clk_gate`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_GATEW {
            #[doc = "Clock gating is disabled"]
            NO,
            #[doc = "Gating after 12 sclk cycles"]
            CYCLES12,
            #[doc = "Gating after 16 sclk cycles"]
            CYCLES16,
            #[doc = "Gating after 20 sclk cycles"]
            CYCLES20,
            #[doc = "Gating after 24 sclk cycles"]
            CYCLES24,
        }
        impl CLK_GATEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_GATEW::NO => 0,
                    CLK_GATEW::CYCLES12 => 1,
                    CLK_GATEW::CYCLES16 => 2,
                    CLK_GATEW::CYCLES20 => 3,
                    CLK_GATEW::CYCLES24 => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_GATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_GATEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_GATEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Clock gating is disabled"]
            #[inline]
            pub fn no(self) -> &'a mut W {
                self.variant(CLK_GATEW::NO)
            }
            #[doc = "Gating after 12 sclk cycles"]
            #[inline]
            pub fn cycles12(self) -> &'a mut W {
                self.variant(CLK_GATEW::CYCLES12)
            }
            #[doc = "Gating after 16 sclk cycles"]
            #[inline]
            pub fn cycles16(self) -> &'a mut W {
                self.variant(CLK_GATEW::CYCLES16)
            }
            #[doc = "Gating after 20 sclk cycles"]
            #[inline]
            pub fn cycles20(self) -> &'a mut W {
                self.variant(CLK_GATEW::CYCLES20)
            }
            #[doc = "Gating after 24 sclk cycles"]
            #[inline]
            pub fn cycles24(self) -> &'a mut W {
                self.variant(CLK_GATEW::CYCLES24)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `clk_word_size`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_WORD_SIZEW {
            #[doc = "16 sclk cycles"]
            CYCLES16,
            #[doc = "24 sclk cycles"]
            CYCLES24,
            #[doc = "32 sclk cycles"]
            CYCLES32,
        }
        impl CLK_WORD_SIZEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_WORD_SIZEW::CYCLES16 => 0,
                    CLK_WORD_SIZEW::CYCLES24 => 1,
                    CLK_WORD_SIZEW::CYCLES32 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_WORD_SIZEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_WORD_SIZEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLK_WORD_SIZEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "16 sclk cycles"]
            #[inline]
            pub fn cycles16(self) -> &'a mut W {
                self.variant(CLK_WORD_SIZEW::CYCLES16)
            }
            #[doc = "24 sclk cycles"]
            #[inline]
            pub fn cycles24(self) -> &'a mut W {
                self.variant(CLK_WORD_SIZEW::CYCLES24)
            }
            #[doc = "32 sclk cycles"]
            #[inline]
            pub fn cycles32(self) -> &'a mut W {
                self.variant(CLK_WORD_SIZEW::CYCLES32)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `align_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALIGN_MODEW {
            #[doc = "Standard I2S format"]
            STANDARD,
            #[doc = "Right aligned format"]
            RIGHT,
            #[doc = "Left aligned format"]
            LEFT,
        }
        impl ALIGN_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ALIGN_MODEW::STANDARD => 1,
                    ALIGN_MODEW::RIGHT => 2,
                    ALIGN_MODEW::LEFT => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALIGN_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALIGN_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ALIGN_MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Standard I2S format"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(ALIGN_MODEW::STANDARD)
            }
            #[doc = "Right aligned format"]
            #[inline]
            pub fn right(self) -> &'a mut W {
                self.variant(ALIGN_MODEW::RIGHT)
            }
            #[doc = "Left aligned format"]
            #[inline]
            pub fn left(self) -> &'a mut W {
                self.variant(ALIGN_MODEW::LEFT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_TX_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_TX_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_RX_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_RX_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_DIVIDE_16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_DIVIDE_16W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SIGN_EXPAND_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SIGN_EXPAND_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Gating of sclk"]
            #[inline]
            pub fn clk_gate(&self) -> CLK_GATER {
                CLK_GATER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - The number of sclk cycles for which the word select line stayd in the left aligned or right aligned mode"]
            #[inline]
            pub fn clk_word_size(&self) -> CLK_WORD_SIZER {
                CLK_WORD_SIZER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 5:7 - Alignment mode setting"]
            #[inline]
            pub fn align_mode(&self) -> ALIGN_MODER {
                ALIGN_MODER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 8 - DMA transmit enable control"]
            #[inline]
            pub fn dma_tx_en(&self) -> DMA_TX_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_TX_ENR { bits }
            }
            #[doc = "Bit 9 - DMA receive enable control"]
            #[inline]
            pub fn dma_rx_en(&self) -> DMA_RX_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_RX_ENR { bits }
            }
            #[doc = "Bit 10 - Split 32bit data to two 16 bit data and filled in left and right channel. Used with dma_tx_en or dma_rx_en"]
            #[inline]
            pub fn dma_divide_16(&self) -> DMA_DIVIDE_16R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_DIVIDE_16R { bits }
            }
            #[doc = "Bit 11 - SIGN_EXPAND_EN"]
            #[inline]
            pub fn sign_expand_en(&self) -> SIGN_EXPAND_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIGN_EXPAND_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Gating of sclk"]
            #[inline]
            pub fn clk_gate(&mut self) -> _CLK_GATEW {
                _CLK_GATEW { w: self }
            }
            #[doc = "Bits 3:4 - The number of sclk cycles for which the word select line stayd in the left aligned or right aligned mode"]
            #[inline]
            pub fn clk_word_size(&mut self) -> _CLK_WORD_SIZEW {
                _CLK_WORD_SIZEW { w: self }
            }
            #[doc = "Bits 5:7 - Alignment mode setting"]
            #[inline]
            pub fn align_mode(&mut self) -> _ALIGN_MODEW {
                _ALIGN_MODEW { w: self }
            }
            #[doc = "Bit 8 - DMA transmit enable control"]
            #[inline]
            pub fn dma_tx_en(&mut self) -> _DMA_TX_ENW {
                _DMA_TX_ENW { w: self }
            }
            #[doc = "Bit 9 - DMA receive enable control"]
            #[inline]
            pub fn dma_rx_en(&mut self) -> _DMA_RX_ENW {
                _DMA_RX_ENW { w: self }
            }
            #[doc = "Bit 10 - Split 32bit data to two 16 bit data and filled in left and right channel. Used with dma_tx_en or dma_rx_en"]
            #[inline]
            pub fn dma_divide_16(&mut self) -> _DMA_DIVIDE_16W {
                _DMA_DIVIDE_16W { w: self }
            }
            #[doc = "Bit 11 - SIGN_EXPAND_EN"]
            #[inline]
            pub fn sign_expand_en(&mut self) -> _SIGN_EXPAND_ENW {
                _SIGN_EXPAND_ENW { w: self }
            }
        }
    }
    #[doc = "Receiver Block FIFO Reset Register"]
    pub struct RXFFR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receiver Block FIFO Reset Register"]
    pub mod rxffr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXFFR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `rxffr`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXFFRR {
            #[doc = "Not flush FIFO"]
            NOT_FLUSH,
            #[doc = "Flush FIFO"]
            FLUSH,
        }
        impl RXFFRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXFFRR::NOT_FLUSH => false,
                    RXFFRR::FLUSH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXFFRR {
                match value {
                    false => RXFFRR::NOT_FLUSH,
                    true => RXFFRR::FLUSH,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_FLUSH`"]
            #[inline]
            pub fn is_not_flush(&self) -> bool {
                *self == RXFFRR::NOT_FLUSH
            }
            #[doc = "Checks if the value of the field is `FLUSH`"]
            #[inline]
            pub fn is_flush(&self) -> bool {
                *self == RXFFRR::FLUSH
            }
        }
        #[doc = "Values that can be written to the field `rxffr`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXFFRW {
            #[doc = "Not flush FIFO"]
            NOT_FLUSH,
            #[doc = "Flush FIFO"]
            FLUSH,
        }
        impl RXFFRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXFFRW::NOT_FLUSH => false,
                    RXFFRW::FLUSH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXFFRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXFFRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXFFRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not flush FIFO"]
            #[inline]
            pub fn not_flush(self) -> &'a mut W {
                self.variant(RXFFRW::NOT_FLUSH)
            }
            #[doc = "Flush FIFO"]
            #[inline]
            pub fn flush(self) -> &'a mut W {
                self.variant(RXFFRW::FLUSH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver FIFO reset"]
            #[inline]
            pub fn rxffr(&self) -> RXFFRR {
                RXFFRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receiver FIFO reset"]
            #[inline]
            pub fn rxffr(&mut self) -> _RXFFRW {
                _RXFFRW { w: self }
            }
        }
    }
    #[doc = "Transmitter Block FIFO Reset Register"]
    pub struct TXFFR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmitter Block FIFO Reset Register"]
    pub mod txffr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXFFR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `rxffr`"]
        pub type RXFFRR = super::rxffr::RXFFRR;
        #[doc = "Values that can be written to the field `rxffr`"]
        pub type RXFFRW = super::rxffr::RXFFRW;
        #[doc = r" Proxy"]
        pub struct _RXFFRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXFFRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXFFRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not flush FIFO"]
            #[inline]
            pub fn not_flush(self) -> &'a mut W {
                self.variant(super::rxffr::RXFFRW::NOT_FLUSH)
            }
            #[doc = "Flush FIFO"]
            #[inline]
            pub fn flush(self) -> &'a mut W {
                self.variant(super::rxffr::RXFFRW::FLUSH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmitter FIFO reset"]
            #[inline]
            pub fn rxffr(&self) -> RXFFRR {
                RXFFRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Transmitter FIFO reset"]
            #[inline]
            pub fn rxffr(&mut self) -> _RXFFRW {
                _RXFFRW { w: self }
            }
        }
    }
    #[doc = "Receiver Block DMA Register"]
    pub struct RXDMA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receiver Block DMA Register"]
    pub mod rxdma {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXDMA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Reset Receiver Block DMA Register"]
    pub struct RRXDMA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Reset Receiver Block DMA Register"]
    pub mod rrxdma {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RRXDMA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transmitter Block DMA Register"]
    pub struct TXDMA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmitter Block DMA Register"]
    pub mod txdma {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDMA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Reset Transmitter Block DMA Register"]
    pub struct RTXDMA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Reset Transmitter Block DMA Register"]
    pub mod rtxdma {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RTXDMA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Parameter Register 2"]
    pub struct I2S_COMP_PARAM_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameter Register 2"]
    pub mod i2s_comp_param_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::I2S_COMP_PARAM_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Parameter Register 1"]
    pub struct I2S_COMP_PARAM_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameter Register 1"]
    pub mod i2s_comp_param_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::I2S_COMP_PARAM_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Version Register"]
    pub struct I2S_COMP_VERSION_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Version Register"]
    pub mod i2s_comp_version_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::I2S_COMP_VERSION_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Type Register"]
    pub struct I2S_COMP_TYPE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Type Register"]
    pub mod i2s_comp_type {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::I2S_COMP_TYPE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Audio Processor"]
pub struct APU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for APU {}
impl APU {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const apu::RegisterBlock {
        0x5025_0200 as *const _
    }
}
impl Deref for APU {
    type Target = apu::RegisterBlock;
    fn deref(&self) -> &apu::RegisterBlock {
        unsafe { &*APU::ptr() }
    }
}
#[doc = "Audio Processor"]
pub mod apu {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Channel Config Register"]
        pub ch_cfg: CH_CFG,
        #[doc = "0x04 - Control Register"]
        pub ctl: CTL,
        #[doc = "0x08 - Direction Sample Buffer Read Index Configure Register (16 directions * 2 values * 4 indices)"]
        pub dir_bidx: [DIR_BIDX; 32],
        #[doc = "0x88 - FIR0 pre-filter coefficients"]
        pub pre_fir0_coef: [PRE_FIR0_COEF; 9],
        #[doc = "0xac - FIR0 post-filter coefficients"]
        pub post_fir0_coef: [POST_FIR0_COEF; 9],
        #[doc = "0xd0 - FIR1 pre-filter coeffecients"]
        pub pre_fir1_coef: [PRE_FIR1_COEF; 9],
        #[doc = "0xf4 - FIR1 post-filter coefficients"]
        pub post_fir1_coef: [POST_FIR1_COEF; 9],
        #[doc = "0x118 - Downsize Config Register"]
        pub dwsz_cfg: DWSZ_CFG,
        #[doc = "0x11c - FFT Config Register"]
        pub fft_cfg: FFT_CFG,
        #[doc = "0x120 - Read register for DMA to sample-out buffers"]
        pub sobuf_dma_rdata: SOBUF_DMA_RDATA,
        #[doc = "0x124 - Read register for DMA to voice-out buffers"]
        pub vobuf_dma_rdata: VOBUF_DMA_RDATA,
        #[doc = "0x128 - Interrupt Status Register"]
        pub int_stat: INT_STAT,
        #[doc = "0x12c - Interrupt Mask Register"]
        pub int_mask: INT_MASK,
        #[doc = "0x130 - Saturation Counter"]
        pub sat_counter: SAT_COUNTER,
        #[doc = "0x134 - Saturation Limits"]
        pub sat_limits: SAT_LIMITS,
    }
    #[doc = "Channel Config Register"]
    pub struct CH_CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Channel Config Register"]
    pub mod ch_cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CH_CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SOUND_CH_ENR {
            bits: u8,
        }
        impl SOUND_CH_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TARGET_DIRR {
            bits: u8,
        }
        impl TARGET_DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUDIO_GAINR {
            bits: u16,
        }
        impl AUDIO_GAINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA_SRC_MODER {
            bits: bool,
        }
        impl DATA_SRC_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SOUND_CH_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SOUND_CH_ENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TARGET_DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TARGET_DIRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUDIO_GAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUDIO_GAINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x07ff;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_SRC_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_SRC_MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_SOUND_CH_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_SOUND_CH_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_TARGET_DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_TARGET_DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_AUDIO_GAINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_AUDIO_GAINW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_DATA_SRC_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_DATA_SRC_MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - BF unit sound channel enable control bits"]
            #[inline]
            pub fn sound_ch_en(&self) -> SOUND_CH_ENR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SOUND_CH_ENR { bits }
            }
            #[doc = "Bits 8:11 - Target direction select for valid voice output"]
            #[inline]
            pub fn target_dir(&self) -> TARGET_DIRR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TARGET_DIRR { bits }
            }
            #[doc = "Bits 12:22 - Audio sample gain factor"]
            #[inline]
            pub fn audio_gain(&self) -> AUDIO_GAINR {
                let bits = {
                    const MASK: u16 = 0x07ff;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                AUDIO_GAINR { bits }
            }
            #[doc = "Bit 24 - Audio data source configure parameter"]
            #[inline]
            pub fn data_src_mode(&self) -> DATA_SRC_MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA_SRC_MODER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - BF unit sound channel enable control bits"]
            #[inline]
            pub fn sound_ch_en(&mut self) -> _SOUND_CH_ENW {
                _SOUND_CH_ENW { w: self }
            }
            #[doc = "Bits 8:11 - Target direction select for valid voice output"]
            #[inline]
            pub fn target_dir(&mut self) -> _TARGET_DIRW {
                _TARGET_DIRW { w: self }
            }
            #[doc = "Bits 12:22 - Audio sample gain factor"]
            #[inline]
            pub fn audio_gain(&mut self) -> _AUDIO_GAINW {
                _AUDIO_GAINW { w: self }
            }
            #[doc = "Bit 24 - Audio data source configure parameter"]
            #[inline]
            pub fn data_src_mode(&mut self) -> _DATA_SRC_MODEW {
                _DATA_SRC_MODEW { w: self }
            }
            #[doc = "Bit 28 - Write enable for sound_ch_en parameter"]
            #[inline]
            pub fn we_sound_ch_en(&mut self) -> _WE_SOUND_CH_ENW {
                _WE_SOUND_CH_ENW { w: self }
            }
            #[doc = "Bit 29 - Write enable for target_dir parameter"]
            #[inline]
            pub fn we_target_dir(&mut self) -> _WE_TARGET_DIRW {
                _WE_TARGET_DIRW { w: self }
            }
            #[doc = "Bit 30 - Write enable for audio_gain parameter"]
            #[inline]
            pub fn we_audio_gain(&mut self) -> _WE_AUDIO_GAINW {
                _WE_AUDIO_GAINW { w: self }
            }
            #[doc = "Bit 31 - Write enable for data_out_mode parameter"]
            #[inline]
            pub fn we_data_src_mode(&mut self) -> _WE_DATA_SRC_MODEW {
                _WE_DATA_SRC_MODEW { w: self }
            }
        }
    }
    #[doc = "Control Register"]
    pub struct CTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register"]
    pub mod ctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIR_SEARCH_ENR {
            bits: bool,
        }
        impl DIR_SEARCH_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SEARCH_PATH_RESETR {
            bits: bool,
        }
        impl SEARCH_PATH_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STREAM_GEN_ENR {
            bits: bool,
        }
        impl STREAM_GEN_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct VOICE_GEN_PATH_RESETR {
            bits: bool,
        }
        impl VOICE_GEN_PATH_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UPDATE_VOICE_DIRR {
            bits: bool,
        }
        impl UPDATE_VOICE_DIRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIR_SEARCH_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIR_SEARCH_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEARCH_PATH_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEARCH_PATH_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STREAM_GEN_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STREAM_GEN_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _VOICE_GEN_PATH_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VOICE_GEN_PATH_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UPDATE_VOICE_DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UPDATE_VOICE_DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_DIR_SEARCH_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_DIR_SEARCH_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_SEARCH_PATH_RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_SEARCH_PATH_RSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_STREAM_GENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_STREAM_GENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_VOICE_GEN_PATH_RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_VOICE_GEN_PATH_RSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WE_UPDATE_VOICE_DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WE_UPDATE_VOICE_DIRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Sound direction searching enable bit"]
            #[inline]
            pub fn dir_search_en(&self) -> DIR_SEARCH_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIR_SEARCH_ENR { bits }
            }
            #[doc = "Bit 1 - Reset all control logic on direction search processing path"]
            #[inline]
            pub fn search_path_reset(&self) -> SEARCH_PATH_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SEARCH_PATH_RESETR { bits }
            }
            #[doc = "Bit 4 - Valid voice sample stream generation enable bit"]
            #[inline]
            pub fn stream_gen_en(&self) -> STREAM_GEN_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STREAM_GEN_ENR { bits }
            }
            #[doc = "Bit 5 - Reset all control logic on voice stream generating path"]
            #[inline]
            pub fn voice_gen_path_reset(&self) -> VOICE_GEN_PATH_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                VOICE_GEN_PATH_RESETR { bits }
            }
            #[doc = "Bit 6 - Switch to a new voice source direction"]
            #[inline]
            pub fn update_voice_dir(&self) -> UPDATE_VOICE_DIRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UPDATE_VOICE_DIRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sound direction searching enable bit"]
            #[inline]
            pub fn dir_search_en(&mut self) -> _DIR_SEARCH_ENW {
                _DIR_SEARCH_ENW { w: self }
            }
            #[doc = "Bit 1 - Reset all control logic on direction search processing path"]
            #[inline]
            pub fn search_path_reset(&mut self) -> _SEARCH_PATH_RESETW {
                _SEARCH_PATH_RESETW { w: self }
            }
            #[doc = "Bit 4 - Valid voice sample stream generation enable bit"]
            #[inline]
            pub fn stream_gen_en(&mut self) -> _STREAM_GEN_ENW {
                _STREAM_GEN_ENW { w: self }
            }
            #[doc = "Bit 5 - Reset all control logic on voice stream generating path"]
            #[inline]
            pub fn voice_gen_path_reset(&mut self) -> _VOICE_GEN_PATH_RESETW {
                _VOICE_GEN_PATH_RESETW { w: self }
            }
            #[doc = "Bit 6 - Switch to a new voice source direction"]
            #[inline]
            pub fn update_voice_dir(&mut self) -> _UPDATE_VOICE_DIRW {
                _UPDATE_VOICE_DIRW { w: self }
            }
            #[doc = "Bit 8 - Write enable for we_dir_search_en parameter"]
            #[inline]
            pub fn we_dir_search_en(&mut self) -> _WE_DIR_SEARCH_ENW {
                _WE_DIR_SEARCH_ENW { w: self }
            }
            #[doc = "Bit 9 - Write enable for we_search_path_rst parameter"]
            #[inline]
            pub fn we_search_path_rst(&mut self) -> _WE_SEARCH_PATH_RSTW {
                _WE_SEARCH_PATH_RSTW { w: self }
            }
            #[doc = "Bit 10 - Write enable for we_stream_gen parameter"]
            #[inline]
            pub fn we_stream_gen(&mut self) -> _WE_STREAM_GENW {
                _WE_STREAM_GENW { w: self }
            }
            #[doc = "Bit 11 - Write enable for we_voice_gen_path_rst parameter"]
            #[inline]
            pub fn we_voice_gen_path_rst(&mut self) -> _WE_VOICE_GEN_PATH_RSTW {
                _WE_VOICE_GEN_PATH_RSTW { w: self }
            }
            #[doc = "Bit 12 - Write enable for we_update_voice_dir parameter"]
            #[inline]
            pub fn we_update_voice_dir(&mut self) -> _WE_UPDATE_VOICE_DIRW {
                _WE_UPDATE_VOICE_DIRW { w: self }
            }
        }
    }
    #[doc = "Direction Sample Buffer Read Index Configure Register (16 directions * 2 values * 4 indices)"]
    pub struct DIR_BIDX {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Direction Sample Buffer Read Index Configure Register (16 directions * 2 values * 4 indices)"]
    pub mod dir_bidx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR_BIDX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_IDX0R {
            bits: u8,
        }
        impl RD_IDX0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_IDX1R {
            bits: u8,
        }
        impl RD_IDX1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_IDX2R {
            bits: u8,
        }
        impl RD_IDX2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_IDX3R {
            bits: u8,
        }
        impl RD_IDX3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_IDX0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_IDX0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_IDX1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_IDX1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_IDX2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_IDX2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_IDX3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_IDX3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - rd_idx0"]
            #[inline]
            pub fn rd_idx0(&self) -> RD_IDX0R {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RD_IDX0R { bits }
            }
            #[doc = "Bits 8:13 - rd_idx1"]
            #[inline]
            pub fn rd_idx1(&self) -> RD_IDX1R {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RD_IDX1R { bits }
            }
            #[doc = "Bits 16:21 - rd_idx2"]
            #[inline]
            pub fn rd_idx2(&self) -> RD_IDX2R {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RD_IDX2R { bits }
            }
            #[doc = "Bits 24:29 - rd_idx3"]
            #[inline]
            pub fn rd_idx3(&self) -> RD_IDX3R {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RD_IDX3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - rd_idx0"]
            #[inline]
            pub fn rd_idx0(&mut self) -> _RD_IDX0W {
                _RD_IDX0W { w: self }
            }
            #[doc = "Bits 8:13 - rd_idx1"]
            #[inline]
            pub fn rd_idx1(&mut self) -> _RD_IDX1W {
                _RD_IDX1W { w: self }
            }
            #[doc = "Bits 16:21 - rd_idx2"]
            #[inline]
            pub fn rd_idx2(&mut self) -> _RD_IDX2W {
                _RD_IDX2W { w: self }
            }
            #[doc = "Bits 24:29 - rd_idx3"]
            #[inline]
            pub fn rd_idx3(&mut self) -> _RD_IDX3W {
                _RD_IDX3W { w: self }
            }
        }
    }
    #[doc = "FIR0 pre-filter coefficients"]
    pub struct PRE_FIR0_COEF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIR0 pre-filter coefficients"]
    pub mod pre_fir0_coef {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRE_FIR0_COEF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP0R {
            bits: u16,
        }
        impl TAP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP1R {
            bits: u16,
        }
        impl TAP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&self) -> TAP0R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP0R { bits }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&self) -> TAP1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&mut self) -> _TAP0W {
                _TAP0W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&mut self) -> _TAP1W {
                _TAP1W { w: self }
            }
        }
    }
    #[doc = "FIR0 post-filter coefficients"]
    pub struct POST_FIR0_COEF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIR0 post-filter coefficients"]
    pub mod post_fir0_coef {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POST_FIR0_COEF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP0R {
            bits: u16,
        }
        impl TAP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP1R {
            bits: u16,
        }
        impl TAP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&self) -> TAP0R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP0R { bits }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&self) -> TAP1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&mut self) -> _TAP0W {
                _TAP0W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&mut self) -> _TAP1W {
                _TAP1W { w: self }
            }
        }
    }
    #[doc = "FIR1 pre-filter coeffecients"]
    pub struct PRE_FIR1_COEF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIR1 pre-filter coeffecients"]
    pub mod pre_fir1_coef {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRE_FIR1_COEF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP0R {
            bits: u16,
        }
        impl TAP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP1R {
            bits: u16,
        }
        impl TAP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&self) -> TAP0R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP0R { bits }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&self) -> TAP1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&mut self) -> _TAP0W {
                _TAP0W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&mut self) -> _TAP1W {
                _TAP1W { w: self }
            }
        }
    }
    #[doc = "FIR1 post-filter coefficients"]
    pub struct POST_FIR1_COEF {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIR1 post-filter coefficients"]
    pub mod post_fir1_coef {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POST_FIR1_COEF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP0R {
            bits: u16,
        }
        impl TAP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TAP1R {
            bits: u16,
        }
        impl TAP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&self) -> TAP0R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP0R { bits }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&self) -> TAP1R {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TAP1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline]
            pub fn tap0(&mut self) -> _TAP0W {
                _TAP0W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline]
            pub fn tap1(&mut self) -> _TAP1W {
                _TAP1W { w: self }
            }
        }
    }
    #[doc = "Downsize Config Register"]
    pub struct DWSZ_CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Downsize Config Register"]
    pub mod dwsz_cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DWSZ_CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIR_DWN_SIZ_RATER {
            bits: u8,
        }
        impl DIR_DWN_SIZ_RATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct VOC_DWN_SIZ_RATER {
            bits: u8,
        }
        impl VOC_DWN_SIZ_RATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SMPL_SHIFT_BITSR {
            bits: u8,
        }
        impl SMPL_SHIFT_BITSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIR_DWN_SIZ_RATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIR_DWN_SIZ_RATEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _VOC_DWN_SIZ_RATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VOC_DWN_SIZ_RATEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SMPL_SHIFT_BITSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SMPL_SHIFT_BITSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Down-sizing ratio used for direction searching"]
            #[inline]
            pub fn dir_dwn_siz_rate(&self) -> DIR_DWN_SIZ_RATER {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIR_DWN_SIZ_RATER { bits }
            }
            #[doc = "Bits 4:7 - Down-sizing ratio used for voice stream generation"]
            #[inline]
            pub fn voc_dwn_siz_rate(&self) -> VOC_DWN_SIZ_RATER {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VOC_DWN_SIZ_RATER { bits }
            }
            #[doc = "Bits 8:12 - Sample precision reduction when the source sound sample precision is 20/24/32 bits"]
            #[inline]
            pub fn smpl_shift_bits(&self) -> SMPL_SHIFT_BITSR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SMPL_SHIFT_BITSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Down-sizing ratio used for direction searching"]
            #[inline]
            pub fn dir_dwn_siz_rate(&mut self) -> _DIR_DWN_SIZ_RATEW {
                _DIR_DWN_SIZ_RATEW { w: self }
            }
            #[doc = "Bits 4:7 - Down-sizing ratio used for voice stream generation"]
            #[inline]
            pub fn voc_dwn_siz_rate(&mut self) -> _VOC_DWN_SIZ_RATEW {
                _VOC_DWN_SIZ_RATEW { w: self }
            }
            #[doc = "Bits 8:12 - Sample precision reduction when the source sound sample precision is 20/24/32 bits"]
            #[inline]
            pub fn smpl_shift_bits(&mut self) -> _SMPL_SHIFT_BITSW {
                _SMPL_SHIFT_BITSW { w: self }
            }
        }
    }
    #[doc = "FFT Config Register"]
    pub struct FFT_CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FFT Config Register"]
    pub mod fft_cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FFT_CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Read register for DMA to sample-out buffers"]
    pub struct SOBUF_DMA_RDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Read register for DMA to sample-out buffers"]
    pub mod sobuf_dma_rdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SOBUF_DMA_RDATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Read register for DMA to voice-out buffers"]
    pub struct VOBUF_DMA_RDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Read register for DMA to voice-out buffers"]
    pub mod vobuf_dma_rdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::VOBUF_DMA_RDATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct INT_STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod int_stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INT_STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIR_SEARCH_DATA_RDYR {
            bits: bool,
        }
        impl DIR_SEARCH_DATA_RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct VOC_BUF_DATA_RDYR {
            bits: bool,
        }
        impl VOC_BUF_DATA_RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIR_SEARCH_DATA_RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIR_SEARCH_DATA_RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _VOC_BUF_DATA_RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VOC_BUF_DATA_RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline]
            pub fn dir_search_data_rdy(&self) -> DIR_SEARCH_DATA_RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIR_SEARCH_DATA_RDYR { bits }
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline]
            pub fn voc_buf_data_rdy(&self) -> VOC_BUF_DATA_RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                VOC_BUF_DATA_RDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline]
            pub fn dir_search_data_rdy(&mut self) -> _DIR_SEARCH_DATA_RDYW {
                _DIR_SEARCH_DATA_RDYW { w: self }
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline]
            pub fn voc_buf_data_rdy(&mut self) -> _VOC_BUF_DATA_RDYW {
                _VOC_BUF_DATA_RDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt Mask Register"]
    pub struct INT_MASK {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Mask Register"]
    pub mod int_mask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INT_MASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIR_SEARCH_DATA_RDYR {
            bits: bool,
        }
        impl DIR_SEARCH_DATA_RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct VOC_BUF_DATA_RDYR {
            bits: bool,
        }
        impl VOC_BUF_DATA_RDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIR_SEARCH_DATA_RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIR_SEARCH_DATA_RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _VOC_BUF_DATA_RDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VOC_BUF_DATA_RDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline]
            pub fn dir_search_data_rdy(&self) -> DIR_SEARCH_DATA_RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DIR_SEARCH_DATA_RDYR { bits }
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline]
            pub fn voc_buf_data_rdy(&self) -> VOC_BUF_DATA_RDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                VOC_BUF_DATA_RDYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline]
            pub fn dir_search_data_rdy(&mut self) -> _DIR_SEARCH_DATA_RDYW {
                _DIR_SEARCH_DATA_RDYW { w: self }
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline]
            pub fn voc_buf_data_rdy(&mut self) -> _VOC_BUF_DATA_RDYW {
                _VOC_BUF_DATA_RDYW { w: self }
            }
        }
    }
    #[doc = "Saturation Counter"]
    pub struct SAT_COUNTER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Saturation Counter"]
    pub mod sat_counter {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SAT_COUNTER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTERR {
            bits: u16,
        }
        impl COUNTERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOTALR {
            bits: u16,
        }
        impl TOTALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOTALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOTALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Counter"]
            #[inline]
            pub fn counter(&self) -> COUNTERR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                COUNTERR { bits }
            }
            #[doc = "Bits 16:31 - Total"]
            #[inline]
            pub fn total(&self) -> TOTALR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TOTALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Counter"]
            #[inline]
            pub fn counter(&mut self) -> _COUNTERW {
                _COUNTERW { w: self }
            }
            #[doc = "Bits 16:31 - Total"]
            #[inline]
            pub fn total(&mut self) -> _TOTALW {
                _TOTALW { w: self }
            }
        }
    }
    #[doc = "Saturation Limits"]
    pub struct SAT_LIMITS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Saturation Limits"]
    pub mod sat_limits {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SAT_LIMITS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct UPPERR {
            bits: u16,
        }
        impl UPPERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BOTTOMR {
            bits: u16,
        }
        impl BOTTOMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _UPPERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UPPERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOTTOMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOTTOMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Upper limit"]
            #[inline]
            pub fn upper(&self) -> UPPERR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                UPPERR { bits }
            }
            #[doc = "Bits 16:31 - Bottom limit"]
            #[inline]
            pub fn bottom(&self) -> BOTTOMR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                BOTTOMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Upper limit"]
            #[inline]
            pub fn upper(&mut self) -> _UPPERW {
                _UPPERW { w: self }
            }
            #[doc = "Bits 16:31 - Bottom limit"]
            #[inline]
            pub fn bottom(&mut self) -> _BOTTOMW {
                _BOTTOMW { w: self }
            }
        }
    }
}
#[doc = "Inter-Integrated Sound Interface 1"]
pub struct I2S1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S1 {}
impl I2S1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2s0::RegisterBlock {
        0x5026_0000 as *const _
    }
}
impl Deref for I2S1 {
    type Target = i2s0::RegisterBlock;
    fn deref(&self) -> &i2s0::RegisterBlock {
        unsafe { &*I2S1::ptr() }
    }
}
#[doc = "Inter-Integrated Sound Interface 2"]
pub struct I2S2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S2 {}
impl I2S2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2s0::RegisterBlock {
        0x5027_0000 as *const _
    }
}
impl Deref for I2S2 {
    type Target = i2s0::RegisterBlock;
    fn deref(&self) -> &i2s0::RegisterBlock {
        unsafe { &*I2S2::ptr() }
    }
}
#[doc = "Inter-Integrated Circuit Bus 0"]
pub struct I2C0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C0 {}
impl I2C0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x5028_0000 as *const _
    }
}
impl Deref for I2C0 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C0::ptr() }
    }
}
#[doc = "Inter-Integrated Circuit Bus 0"]
pub mod i2c0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register"]
        pub con: CON,
        #[doc = "0x04 - Target Address Register"]
        pub tar: TAR,
        #[doc = "0x08 - Slave Address Register"]
        pub sar: SAR,
        _reserved0: [u8; 4usize],
        #[doc = "0x10 - Data Buffer and Command Register"]
        pub data_cmd: DATA_CMD,
        #[doc = "0x14 - Standard Speed Clock SCL High Count Register"]
        pub ss_scl_hcnt: SS_SCL_HCNT,
        #[doc = "0x18 - Standard Speed Clock SCL Low Count Register"]
        pub ss_scl_lcnt: SS_SCL_LCNT,
        _reserved1: [u8; 16usize],
        #[doc = "0x2c - Interrupt Status Register"]
        pub intr_stat: INTR_STAT,
        #[doc = "0x30 - Interrupt Mask Register"]
        pub intr_mask: INTR_MASK,
        #[doc = "0x34 - Raw Interrupt Status Register"]
        pub raw_intr_stat: RAW_INTR_STAT,
        #[doc = "0x38 - Receive FIFO Threshold Register"]
        pub rx_tl: RX_TL,
        #[doc = "0x3c - Transmit FIFO Threshold Register"]
        pub tx_tl: TX_TL,
        #[doc = "0x40 - Clear Combined and Individual Interrupt Register"]
        pub clr_intr: CLR_INTR,
        #[doc = "0x44 - Clear RX_UNDER Interrupt Register"]
        pub clr_rx_under: CLR_RX_UNDER,
        #[doc = "0x48 - Clear RX_OVER Interrupt Register"]
        pub clr_rx_over: CLR_RX_OVER,
        #[doc = "0x4c - Clear TX_OVER Interrupt Register"]
        pub clr_tx_over: CLR_TX_OVER,
        #[doc = "0x50 - Clear RD_REQ Interrupt Register"]
        pub clr_rd_req: CLR_RD_REQ,
        #[doc = "0x54 - Clear TX_ABRT Interrupt Register"]
        pub clr_tx_abrt: CLR_TX_ABRT,
        #[doc = "0x58 - Clear RX_DONE Interrupt Register"]
        pub clr_rx_done: CLR_RX_DONE,
        #[doc = "0x5c - Clear ACTIVITY Interrupt Register"]
        pub clr_activity: CLR_ACTIVITY,
        #[doc = "0x60 - Clear STOP_DET Interrupt Register"]
        pub clr_stop_det: CLR_STOP_DET,
        #[doc = "0x64 - Clear START_DET Interrupt Register"]
        pub clr_start_det: CLR_START_DET,
        #[doc = "0x68 - I2C Clear GEN_CALL Interrupt Register"]
        pub clr_gen_call: CLR_GEN_CALL,
        #[doc = "0x6c - Enable Register"]
        pub enable: ENABLE,
        #[doc = "0x70 - Status Register"]
        pub status: STATUS,
        #[doc = "0x74 - Transmit FIFO Level Register"]
        pub txflr: TXFLR,
        #[doc = "0x78 - Receive FIFO Level Register"]
        pub rxflr: RXFLR,
        #[doc = "0x7c - SDA Hold Time Length Register"]
        pub sda_hold: SDA_HOLD,
        #[doc = "0x80 - Transmit Abort Source Register"]
        pub tx_abrt_source: TX_ABRT_SOURCE,
        _reserved2: [u8; 4usize],
        #[doc = "0x88 - I2C DMA Control Register"]
        pub dma_cr: DMA_CR,
        #[doc = "0x8c - DMA Transmit Data Level Register"]
        pub dma_tdlr: DMA_TDLR,
        #[doc = "0x90 - DMA Receive Data Level Register"]
        pub dma_rdlr: DMA_RDLR,
        #[doc = "0x94 - SDA Setup Register"]
        pub sda_setup: SDA_SETUP,
        #[doc = "0x98 - ACK General Call Register"]
        pub general_call: GENERAL_CALL,
        #[doc = "0x9c - Enable Status Register"]
        pub enable_status: ENABLE_STATUS,
        #[doc = "0xa0 - SS, FS or FM+ spike suppression limit"]
        pub fs_spklen: FS_SPKLEN,
        _reserved3: [u8; 80usize],
        #[doc = "0xf4 - Component Parameter Register 1"]
        pub comp_param_1: COMP_PARAM_1,
        #[doc = "0xf8 - Component Version Register"]
        pub comp_version: COMP_VERSION,
        #[doc = "0xfc - Component Type Register"]
        pub comp_type: COMP_TYPE,
    }
    #[doc = "Control Register"]
    pub struct CON {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register"]
    pub mod con {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CON {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASTER_MODER {
            bits: bool,
        }
        impl MASTER_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `speed`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPEEDR {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "FAST"]
            FAST,
            #[doc = "HIGHSPEED"]
            HIGHSPEED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SPEEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SPEEDR::STANDARD => 0,
                    SPEEDR::FAST => 0x01,
                    SPEEDR::HIGHSPEED => 0x02,
                    SPEEDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SPEEDR {
                match value {
                    0 => SPEEDR::STANDARD,
                    1 => SPEEDR::FAST,
                    2 => SPEEDR::HIGHSPEED,
                    i => SPEEDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline]
            pub fn is_standard(&self) -> bool {
                *self == SPEEDR::STANDARD
            }
            #[doc = "Checks if the value of the field is `FAST`"]
            #[inline]
            pub fn is_fast(&self) -> bool {
                *self == SPEEDR::FAST
            }
            #[doc = "Checks if the value of the field is `HIGHSPEED`"]
            #[inline]
            pub fn is_highspeed(&self) -> bool {
                *self == SPEEDR::HIGHSPEED
            }
        }
        #[doc = "Possible values of the field `addr_slave_width`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_SLAVE_WIDTHR {
            #[doc = "7-bit address"]
            B7,
            #[doc = "10-bit address"]
            B10,
        }
        impl ADDR_SLAVE_WIDTHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR_SLAVE_WIDTHR::B7 => false,
                    ADDR_SLAVE_WIDTHR::B10 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR_SLAVE_WIDTHR {
                match value {
                    false => ADDR_SLAVE_WIDTHR::B7,
                    true => ADDR_SLAVE_WIDTHR::B10,
                }
            }
            #[doc = "Checks if the value of the field is `B7`"]
            #[inline]
            pub fn is_b7(&self) -> bool {
                *self == ADDR_SLAVE_WIDTHR::B7
            }
            #[doc = "Checks if the value of the field is `B10`"]
            #[inline]
            pub fn is_b10(&self) -> bool {
                *self == ADDR_SLAVE_WIDTHR::B10
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESTART_ENR {
            bits: bool,
        }
        impl RESTART_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLAVE_DISABLER {
            bits: bool,
        }
        impl SLAVE_DISABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_DETR {
            bits: bool,
        }
        impl STOP_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_EMPTYR {
            bits: bool,
        }
        impl TX_EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASTER_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASTER_MODEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `speed`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPEEDW {
            #[doc = "STANDARD"]
            STANDARD,
            #[doc = "FAST"]
            FAST,
            #[doc = "HIGHSPEED"]
            HIGHSPEED,
        }
        impl SPEEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SPEEDW::STANDARD => 0,
                    SPEEDW::FAST => 1,
                    SPEEDW::HIGHSPEED => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPEEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SPEEDW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "STANDARD"]
            #[inline]
            pub fn standard(self) -> &'a mut W {
                self.variant(SPEEDW::STANDARD)
            }
            #[doc = "FAST"]
            #[inline]
            pub fn fast(self) -> &'a mut W {
                self.variant(SPEEDW::FAST)
            }
            #[doc = "HIGHSPEED"]
            #[inline]
            pub fn highspeed(self) -> &'a mut W {
                self.variant(SPEEDW::HIGHSPEED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `addr_slave_width`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_SLAVE_WIDTHW {
            #[doc = "7-bit address"]
            B7,
            #[doc = "10-bit address"]
            B10,
        }
        impl ADDR_SLAVE_WIDTHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR_SLAVE_WIDTHW::B7 => false,
                    ADDR_SLAVE_WIDTHW::B10 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR_SLAVE_WIDTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR_SLAVE_WIDTHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR_SLAVE_WIDTHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "7-bit address"]
            #[inline]
            pub fn b7(self) -> &'a mut W {
                self.variant(ADDR_SLAVE_WIDTHW::B7)
            }
            #[doc = "10-bit address"]
            #[inline]
            pub fn b10(self) -> &'a mut W {
                self.variant(ADDR_SLAVE_WIDTHW::B10)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESTART_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESTART_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLAVE_DISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLAVE_DISABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Mode"]
            #[inline]
            pub fn master_mode(&self) -> MASTER_MODER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASTER_MODER { bits }
            }
            #[doc = "Bits 1:2 - Speed"]
            #[inline]
            pub fn speed(&self) -> SPEEDR {
                SPEEDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - Slave address width"]
            #[inline]
            pub fn addr_slave_width(&self) -> ADDR_SLAVE_WIDTHR {
                ADDR_SLAVE_WIDTHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable Restart"]
            #[inline]
            pub fn restart_en(&self) -> RESTART_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESTART_ENR { bits }
            }
            #[doc = "Bit 6 - Disable Slave"]
            #[inline]
            pub fn slave_disable(&self) -> SLAVE_DISABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLAVE_DISABLER { bits }
            }
            #[doc = "Bit 7 - STOP_DET_IFADDRESSED"]
            #[inline]
            pub fn stop_det(&self) -> STOP_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_DETR { bits }
            }
            #[doc = "Bit 8 - TX_EMPTY_CTRL"]
            #[inline]
            pub fn tx_empty(&self) -> TX_EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_EMPTYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Mode"]
            #[inline]
            pub fn master_mode(&mut self) -> _MASTER_MODEW {
                _MASTER_MODEW { w: self }
            }
            #[doc = "Bits 1:2 - Speed"]
            #[inline]
            pub fn speed(&mut self) -> _SPEEDW {
                _SPEEDW { w: self }
            }
            #[doc = "Bit 3 - Slave address width"]
            #[inline]
            pub fn addr_slave_width(&mut self) -> _ADDR_SLAVE_WIDTHW {
                _ADDR_SLAVE_WIDTHW { w: self }
            }
            #[doc = "Bit 5 - Enable Restart"]
            #[inline]
            pub fn restart_en(&mut self) -> _RESTART_ENW {
                _RESTART_ENW { w: self }
            }
            #[doc = "Bit 6 - Disable Slave"]
            #[inline]
            pub fn slave_disable(&mut self) -> _SLAVE_DISABLEW {
                _SLAVE_DISABLEW { w: self }
            }
            #[doc = "Bit 7 - STOP_DET_IFADDRESSED"]
            #[inline]
            pub fn stop_det(&mut self) -> _STOP_DETW {
                _STOP_DETW { w: self }
            }
            #[doc = "Bit 8 - TX_EMPTY_CTRL"]
            #[inline]
            pub fn tx_empty(&mut self) -> _TX_EMPTYW {
                _TX_EMPTYW { w: self }
            }
        }
    }
    #[doc = "Target Address Register"]
    pub struct TAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Target Address Register"]
    pub mod tar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRESSR {
            bits: u16,
        }
        impl ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCR {
            bits: bool,
        }
        impl GCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPECIALR {
            bits: bool,
        }
        impl SPECIALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `addr_master_width`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_MASTER_WIDTHR {
            #[doc = "7-bit address"]
            B7,
            #[doc = "10-bit address"]
            B10,
        }
        impl ADDR_MASTER_WIDTHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR_MASTER_WIDTHR::B7 => false,
                    ADDR_MASTER_WIDTHR::B10 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR_MASTER_WIDTHR {
                match value {
                    false => ADDR_MASTER_WIDTHR::B7,
                    true => ADDR_MASTER_WIDTHR::B10,
                }
            }
            #[doc = "Checks if the value of the field is `B7`"]
            #[inline]
            pub fn is_b7(&self) -> bool {
                *self == ADDR_MASTER_WIDTHR::B7
            }
            #[doc = "Checks if the value of the field is `B10`"]
            #[inline]
            pub fn is_b10(&self) -> bool {
                *self == ADDR_MASTER_WIDTHR::B10
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPECIALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPECIALW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `addr_master_width`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_MASTER_WIDTHW {
            #[doc = "7-bit address"]
            B7,
            #[doc = "10-bit address"]
            B10,
        }
        impl ADDR_MASTER_WIDTHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR_MASTER_WIDTHW::B7 => false,
                    ADDR_MASTER_WIDTHW::B10 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR_MASTER_WIDTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR_MASTER_WIDTHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR_MASTER_WIDTHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "7-bit address"]
            #[inline]
            pub fn b7(self) -> &'a mut W {
                self.variant(ADDR_MASTER_WIDTHW::B7)
            }
            #[doc = "10-bit address"]
            #[inline]
            pub fn b10(self) -> &'a mut W {
                self.variant(ADDR_MASTER_WIDTHW::B10)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Target Address"]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ADDRESSR { bits }
            }
            #[doc = "Bit 10 - GC_OR_START"]
            #[inline]
            pub fn gc(&self) -> GCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCR { bits }
            }
            #[doc = "Bit 11 - SPECIAL"]
            #[inline]
            pub fn special(&self) -> SPECIALR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPECIALR { bits }
            }
            #[doc = "Bit 12 - Master Address"]
            #[inline]
            pub fn addr_master_width(&self) -> ADDR_MASTER_WIDTHR {
                ADDR_MASTER_WIDTHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Target Address"]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
            #[doc = "Bit 10 - GC_OR_START"]
            #[inline]
            pub fn gc(&mut self) -> _GCW {
                _GCW { w: self }
            }
            #[doc = "Bit 11 - SPECIAL"]
            #[inline]
            pub fn special(&mut self) -> _SPECIALW {
                _SPECIALW { w: self }
            }
            #[doc = "Bit 12 - Master Address"]
            #[inline]
            pub fn addr_master_width(&mut self) -> _ADDR_MASTER_WIDTHW {
                _ADDR_MASTER_WIDTHW { w: self }
            }
        }
    }
    #[doc = "Slave Address Register"]
    pub struct SAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Slave Address Register"]
    pub mod sar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRESSR {
            bits: u16,
        }
        impl ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Slave Address"]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ADDRESSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Slave Address"]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
        }
    }
    #[doc = "Data Buffer and Command Register"]
    pub struct DATA_CMD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data Buffer and Command Register"]
    pub mod data_cmd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA_CMD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMDR {
            bits: bool,
        }
        impl CMDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 8 - CMD"]
            #[inline]
            pub fn cmd(&self) -> CMDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMDR { bits }
            }
            #[doc = "Bits 0:7 - Data"]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - CMD"]
            #[inline]
            pub fn cmd(&mut self) -> _CMDW {
                _CMDW { w: self }
            }
            #[doc = "Bits 0:7 - Data"]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Standard Speed Clock SCL High Count Register"]
    pub struct SS_SCL_HCNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Standard Speed Clock SCL High Count Register"]
    pub mod ss_scl_hcnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SS_SCL_HCNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u16,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - COUNT"]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - COUNT"]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Standard Speed Clock SCL Low Count Register"]
    pub struct SS_SCL_LCNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Standard Speed Clock SCL Low Count Register"]
    pub mod ss_scl_lcnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SS_SCL_LCNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u16,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - COUNT"]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - COUNT"]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct INTR_STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod intr_stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTR_STAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_UNDERR {
            bits: bool,
        }
        impl RX_UNDERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_OVERR {
            bits: bool,
        }
        impl RX_OVERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_FULLR {
            bits: bool,
        }
        impl RX_FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_OVERR {
            bits: bool,
        }
        impl TX_OVERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_EMPTYR {
            bits: bool,
        }
        impl TX_EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_REQR {
            bits: bool,
        }
        impl RD_REQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_ABRTR {
            bits: bool,
        }
        impl TX_ABRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_DONER {
            bits: bool,
        }
        impl RX_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACTIVITYR {
            bits: bool,
        }
        impl ACTIVITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_DETR {
            bits: bool,
        }
        impl STOP_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct START_DETR {
            bits: bool,
        }
        impl START_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GEN_CALLR {
            bits: bool,
        }
        impl GEN_CALLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline]
            pub fn rx_under(&self) -> RX_UNDERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_UNDERR { bits }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline]
            pub fn rx_over(&self) -> RX_OVERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_OVERR { bits }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline]
            pub fn rx_full(&self) -> RX_FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_FULLR { bits }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline]
            pub fn tx_over(&self) -> TX_OVERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_OVERR { bits }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline]
            pub fn tx_empty(&self) -> TX_EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_EMPTYR { bits }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline]
            pub fn rd_req(&self) -> RD_REQR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RD_REQR { bits }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline]
            pub fn tx_abrt(&self) -> TX_ABRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_ABRTR { bits }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline]
            pub fn rx_done(&self) -> RX_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_DONER { bits }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline]
            pub fn activity(&self) -> ACTIVITYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACTIVITYR { bits }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline]
            pub fn stop_det(&self) -> STOP_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_DETR { bits }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline]
            pub fn start_det(&self) -> START_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                START_DETR { bits }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline]
            pub fn gen_call(&self) -> GEN_CALLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GEN_CALLR { bits }
            }
        }
    }
    #[doc = "Interrupt Mask Register"]
    pub struct INTR_MASK {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Mask Register"]
    pub mod intr_mask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTR_MASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_UNDERR {
            bits: bool,
        }
        impl RX_UNDERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_OVERR {
            bits: bool,
        }
        impl RX_OVERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_FULLR {
            bits: bool,
        }
        impl RX_FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_OVERR {
            bits: bool,
        }
        impl TX_OVERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_EMPTYR {
            bits: bool,
        }
        impl TX_EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_REQR {
            bits: bool,
        }
        impl RD_REQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_ABRTR {
            bits: bool,
        }
        impl TX_ABRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_DONER {
            bits: bool,
        }
        impl RX_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACTIVITYR {
            bits: bool,
        }
        impl ACTIVITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_DETR {
            bits: bool,
        }
        impl STOP_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct START_DETR {
            bits: bool,
        }
        impl START_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GEN_CALLR {
            bits: bool,
        }
        impl GEN_CALLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_UNDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_UNDERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_OVERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_OVERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_FULLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_FULLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_OVERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_OVERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_REQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_REQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_ABRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_ABRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACTIVITYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACTIVITYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _START_DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _START_DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GEN_CALLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GEN_CALLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline]
            pub fn rx_under(&self) -> RX_UNDERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_UNDERR { bits }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline]
            pub fn rx_over(&self) -> RX_OVERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_OVERR { bits }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline]
            pub fn rx_full(&self) -> RX_FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_FULLR { bits }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline]
            pub fn tx_over(&self) -> TX_OVERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_OVERR { bits }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline]
            pub fn tx_empty(&self) -> TX_EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_EMPTYR { bits }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline]
            pub fn rd_req(&self) -> RD_REQR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RD_REQR { bits }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline]
            pub fn tx_abrt(&self) -> TX_ABRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_ABRTR { bits }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline]
            pub fn rx_done(&self) -> RX_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_DONER { bits }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline]
            pub fn activity(&self) -> ACTIVITYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACTIVITYR { bits }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline]
            pub fn stop_det(&self) -> STOP_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_DETR { bits }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline]
            pub fn start_det(&self) -> START_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                START_DETR { bits }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline]
            pub fn gen_call(&self) -> GEN_CALLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GEN_CALLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline]
            pub fn rx_under(&mut self) -> _RX_UNDERW {
                _RX_UNDERW { w: self }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline]
            pub fn rx_over(&mut self) -> _RX_OVERW {
                _RX_OVERW { w: self }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline]
            pub fn rx_full(&mut self) -> _RX_FULLW {
                _RX_FULLW { w: self }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline]
            pub fn tx_over(&mut self) -> _TX_OVERW {
                _TX_OVERW { w: self }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline]
            pub fn tx_empty(&mut self) -> _TX_EMPTYW {
                _TX_EMPTYW { w: self }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline]
            pub fn rd_req(&mut self) -> _RD_REQW {
                _RD_REQW { w: self }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline]
            pub fn tx_abrt(&mut self) -> _TX_ABRTW {
                _TX_ABRTW { w: self }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline]
            pub fn rx_done(&mut self) -> _RX_DONEW {
                _RX_DONEW { w: self }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline]
            pub fn activity(&mut self) -> _ACTIVITYW {
                _ACTIVITYW { w: self }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline]
            pub fn stop_det(&mut self) -> _STOP_DETW {
                _STOP_DETW { w: self }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline]
            pub fn start_det(&mut self) -> _START_DETW {
                _START_DETW { w: self }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline]
            pub fn gen_call(&mut self) -> _GEN_CALLW {
                _GEN_CALLW { w: self }
            }
        }
    }
    #[doc = "Raw Interrupt Status Register"]
    pub struct RAW_INTR_STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw Interrupt Status Register"]
    pub mod raw_intr_stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RAW_INTR_STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_UNDERR {
            bits: bool,
        }
        impl RX_UNDERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_OVERR {
            bits: bool,
        }
        impl RX_OVERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_FULLR {
            bits: bool,
        }
        impl RX_FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_OVERR {
            bits: bool,
        }
        impl TX_OVERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_EMPTYR {
            bits: bool,
        }
        impl TX_EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_REQR {
            bits: bool,
        }
        impl RD_REQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_ABRTR {
            bits: bool,
        }
        impl TX_ABRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_DONER {
            bits: bool,
        }
        impl RX_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACTIVITYR {
            bits: bool,
        }
        impl ACTIVITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_DETR {
            bits: bool,
        }
        impl STOP_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct START_DETR {
            bits: bool,
        }
        impl START_DETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GEN_CALLR {
            bits: bool,
        }
        impl GEN_CALLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_UNDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_UNDERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_OVERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_OVERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_FULLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_FULLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_OVERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_OVERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_EMPTYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_EMPTYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_REQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_REQW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_ABRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_ABRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RX_DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RX_DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACTIVITYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACTIVITYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _START_DETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _START_DETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GEN_CALLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GEN_CALLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline]
            pub fn rx_under(&self) -> RX_UNDERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_UNDERR { bits }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline]
            pub fn rx_over(&self) -> RX_OVERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_OVERR { bits }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline]
            pub fn rx_full(&self) -> RX_FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_FULLR { bits }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline]
            pub fn tx_over(&self) -> TX_OVERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_OVERR { bits }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline]
            pub fn tx_empty(&self) -> TX_EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_EMPTYR { bits }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline]
            pub fn rd_req(&self) -> RD_REQR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RD_REQR { bits }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline]
            pub fn tx_abrt(&self) -> TX_ABRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_ABRTR { bits }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline]
            pub fn rx_done(&self) -> RX_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RX_DONER { bits }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline]
            pub fn activity(&self) -> ACTIVITYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACTIVITYR { bits }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline]
            pub fn stop_det(&self) -> STOP_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_DETR { bits }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline]
            pub fn start_det(&self) -> START_DETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                START_DETR { bits }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline]
            pub fn gen_call(&self) -> GEN_CALLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GEN_CALLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline]
            pub fn rx_under(&mut self) -> _RX_UNDERW {
                _RX_UNDERW { w: self }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline]
            pub fn rx_over(&mut self) -> _RX_OVERW {
                _RX_OVERW { w: self }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline]
            pub fn rx_full(&mut self) -> _RX_FULLW {
                _RX_FULLW { w: self }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline]
            pub fn tx_over(&mut self) -> _TX_OVERW {
                _TX_OVERW { w: self }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline]
            pub fn tx_empty(&mut self) -> _TX_EMPTYW {
                _TX_EMPTYW { w: self }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline]
            pub fn rd_req(&mut self) -> _RD_REQW {
                _RD_REQW { w: self }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline]
            pub fn tx_abrt(&mut self) -> _TX_ABRTW {
                _TX_ABRTW { w: self }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline]
            pub fn rx_done(&mut self) -> _RX_DONEW {
                _RX_DONEW { w: self }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline]
            pub fn activity(&mut self) -> _ACTIVITYW {
                _ACTIVITYW { w: self }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline]
            pub fn stop_det(&mut self) -> _STOP_DETW {
                _STOP_DETW { w: self }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline]
            pub fn start_det(&mut self) -> _START_DETW {
                _START_DETW { w: self }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline]
            pub fn gen_call(&mut self) -> _GEN_CALLW {
                _GEN_CALLW { w: self }
            }
        }
    }
    #[doc = "Receive FIFO Threshold Register"]
    pub struct RX_TL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Threshold Register"]
    pub mod rx_tl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RX_TL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "Transmit FIFO Threshold Register"]
    pub struct TX_TL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Threshold Register"]
    pub mod tx_tl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TX_TL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "Clear Combined and Individual Interrupt Register"]
    pub struct CLR_INTR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear Combined and Individual Interrupt Register"]
    pub mod clr_intr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_INTR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear RX_UNDER Interrupt Register"]
    pub struct CLR_RX_UNDER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear RX_UNDER Interrupt Register"]
    pub mod clr_rx_under {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_RX_UNDER {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear RX_OVER Interrupt Register"]
    pub struct CLR_RX_OVER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear RX_OVER Interrupt Register"]
    pub mod clr_rx_over {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_RX_OVER {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear TX_OVER Interrupt Register"]
    pub struct CLR_TX_OVER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear TX_OVER Interrupt Register"]
    pub mod clr_tx_over {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_TX_OVER {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear RD_REQ Interrupt Register"]
    pub struct CLR_RD_REQ {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear RD_REQ Interrupt Register"]
    pub mod clr_rd_req {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_RD_REQ {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear TX_ABRT Interrupt Register"]
    pub struct CLR_TX_ABRT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear TX_ABRT Interrupt Register"]
    pub mod clr_tx_abrt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_TX_ABRT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear RX_DONE Interrupt Register"]
    pub struct CLR_RX_DONE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear RX_DONE Interrupt Register"]
    pub mod clr_rx_done {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_RX_DONE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear ACTIVITY Interrupt Register"]
    pub struct CLR_ACTIVITY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear ACTIVITY Interrupt Register"]
    pub mod clr_activity {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_ACTIVITY {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear STOP_DET Interrupt Register"]
    pub struct CLR_STOP_DET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear STOP_DET Interrupt Register"]
    pub mod clr_stop_det {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_STOP_DET {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Clear START_DET Interrupt Register"]
    pub struct CLR_START_DET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clear START_DET Interrupt Register"]
    pub mod clr_start_det {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_START_DET {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "I2C Clear GEN_CALL Interrupt Register"]
    pub struct CLR_GEN_CALL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Clear GEN_CALL Interrupt Register"]
    pub mod clr_gen_call {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CLR_GEN_CALL {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: bool,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CLR"]
            #[inline]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRR { bits }
            }
        }
    }
    #[doc = "Enable Register"]
    pub struct ENABLE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Enable Register"]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABORTR {
            bits: bool,
        }
        impl ABORTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_CMD_BLOCKR {
            bits: bool,
        }
        impl TX_CMD_BLOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABORTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_CMD_BLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_CMD_BLOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - ENABLE"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 1 - ABORT"]
            #[inline]
            pub fn abort(&self) -> ABORTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABORTR { bits }
            }
            #[doc = "Bit 2 - TX_CMD_BLOCK"]
            #[inline]
            pub fn tx_cmd_block(&self) -> TX_CMD_BLOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_CMD_BLOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - ENABLE"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 1 - ABORT"]
            #[inline]
            pub fn abort(&mut self) -> _ABORTW {
                _ABORTW { w: self }
            }
            #[doc = "Bit 2 - TX_CMD_BLOCK"]
            #[inline]
            pub fn tx_cmd_block(&mut self) -> _TX_CMD_BLOCKW {
                _TX_CMD_BLOCKW { w: self }
            }
        }
    }
    #[doc = "Status Register"]
    pub struct STATUS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status Register"]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACTIVITYR {
            bits: bool,
        }
        impl ACTIVITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TFNFR {
            bits: bool,
        }
        impl TFNFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TFER {
            bits: bool,
        }
        impl TFER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RFNER {
            bits: bool,
        }
        impl RFNER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RFFR {
            bits: bool,
        }
        impl RFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MST_ACTIVITYR {
            bits: bool,
        }
        impl MST_ACTIVITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLV_ACTIVITYR {
            bits: bool,
        }
        impl SLV_ACTIVITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - ACTIVITY"]
            #[inline]
            pub fn activity(&self) -> ACTIVITYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACTIVITYR { bits }
            }
            #[doc = "Bit 1 - TFNF"]
            #[inline]
            pub fn tfnf(&self) -> TFNFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TFNFR { bits }
            }
            #[doc = "Bit 2 - TFE"]
            #[inline]
            pub fn tfe(&self) -> TFER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TFER { bits }
            }
            #[doc = "Bit 3 - RFNE"]
            #[inline]
            pub fn rfne(&self) -> RFNER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RFNER { bits }
            }
            #[doc = "Bit 4 - RFF"]
            #[inline]
            pub fn rff(&self) -> RFFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RFFR { bits }
            }
            #[doc = "Bit 5 - MST_ACTIVITY"]
            #[inline]
            pub fn mst_activity(&self) -> MST_ACTIVITYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MST_ACTIVITYR { bits }
            }
            #[doc = "Bit 6 - SLV_ACTIVITY"]
            #[inline]
            pub fn slv_activity(&self) -> SLV_ACTIVITYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLV_ACTIVITYR { bits }
            }
        }
    }
    #[doc = "Transmit FIFO Level Register"]
    pub struct TXFLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit FIFO Level Register"]
    pub mod txflr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXFLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "Receive FIFO Level Register"]
    pub struct RXFLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receive FIFO Level Register"]
    pub mod rxflr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXFLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "SDA Hold Time Length Register"]
    pub struct SDA_HOLD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SDA Hold Time Length Register"]
    pub mod sda_hold {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SDA_HOLD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXR {
            bits: u16,
        }
        impl TXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXR {
            bits: u8,
        }
        impl RXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - TX"]
            #[inline]
            pub fn tx(&self) -> TXR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TXR { bits }
            }
            #[doc = "Bits 16:23 - RX"]
            #[inline]
            pub fn rx(&self) -> RXR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - TX"]
            #[inline]
            pub fn tx(&mut self) -> _TXW {
                _TXW { w: self }
            }
            #[doc = "Bits 16:23 - RX"]
            #[inline]
            pub fn rx(&mut self) -> _RXW {
                _RXW { w: self }
            }
        }
    }
    #[doc = "Transmit Abort Source Register"]
    pub struct TX_ABRT_SOURCE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit Abort Source Register"]
    pub mod tx_abrt_source {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TX_ABRT_SOURCE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR7_NOACKR {
            bits: bool,
        }
        impl ADDR7_NOACKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR1_10_NOACKR {
            bits: bool,
        }
        impl ADDR1_10_NOACKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDR2_10_NOACKR {
            bits: bool,
        }
        impl ADDR2_10_NOACKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDATA_NOACKR {
            bits: bool,
        }
        impl TXDATA_NOACKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCALL_NOACKR {
            bits: bool,
        }
        impl GCALL_NOACKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCALL_READR {
            bits: bool,
        }
        impl GCALL_READR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HS_ACKDETR {
            bits: bool,
        }
        impl HS_ACKDETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBYTE_ACKDETR {
            bits: bool,
        }
        impl SBYTE_ACKDETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HS_NORSTRTR {
            bits: bool,
        }
        impl HS_NORSTRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SBYTE_NORSTRTR {
            bits: bool,
        }
        impl SBYTE_NORSTRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RD_10_NORSTRTR {
            bits: bool,
        }
        impl RD_10_NORSTRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASTER_DISR {
            bits: bool,
        }
        impl MASTER_DISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MST_ARBLOSTR {
            bits: bool,
        }
        impl MST_ARBLOSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVFLUSH_TXFIFOR {
            bits: bool,
        }
        impl SLVFLUSH_TXFIFOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLV_ARBLOSTR {
            bits: bool,
        }
        impl SLV_ARBLOSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVRD_INTXR {
            bits: bool,
        }
        impl SLVRD_INTXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USER_ABRTR {
            bits: bool,
        }
        impl USER_ABRTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR7_NOACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR7_NOACKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR1_10_NOACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR1_10_NOACKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR2_10_NOACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR2_10_NOACKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDATA_NOACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDATA_NOACKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCALL_NOACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCALL_NOACKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCALL_READW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCALL_READW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HS_ACKDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HS_ACKDETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBYTE_ACKDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBYTE_ACKDETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HS_NORSTRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HS_NORSTRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBYTE_NORSTRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBYTE_NORSTRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_10_NORSTRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_10_NORSTRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASTER_DISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASTER_DISW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MST_ARBLOSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MST_ARBLOSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVFLUSH_TXFIFOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVFLUSH_TXFIFOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLV_ARBLOSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLV_ARBLOSTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVRD_INTXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVRD_INTXW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USER_ABRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USER_ABRTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - 7B_ADDR_NOACK"]
            #[inline]
            pub fn addr7_noack(&self) -> ADDR7_NOACKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADDR7_NOACKR { bits }
            }
            #[doc = "Bit 1 - 10B_ADDR1_NOACK"]
            #[inline]
            pub fn addr1_10_noack(&self) -> ADDR1_10_NOACKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADDR1_10_NOACKR { bits }
            }
            #[doc = "Bit 2 - 10B_ADDR2_NOACK"]
            #[inline]
            pub fn addr2_10_noack(&self) -> ADDR2_10_NOACKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADDR2_10_NOACKR { bits }
            }
            #[doc = "Bit 3 - TXDATA_NOACK"]
            #[inline]
            pub fn txdata_noack(&self) -> TXDATA_NOACKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDATA_NOACKR { bits }
            }
            #[doc = "Bit 4 - GCALL_NOACK"]
            #[inline]
            pub fn gcall_noack(&self) -> GCALL_NOACKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCALL_NOACKR { bits }
            }
            #[doc = "Bit 5 - GCALL_READ"]
            #[inline]
            pub fn gcall_read(&self) -> GCALL_READR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCALL_READR { bits }
            }
            #[doc = "Bit 6 - HS_ACKDET"]
            #[inline]
            pub fn hs_ackdet(&self) -> HS_ACKDETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HS_ACKDETR { bits }
            }
            #[doc = "Bit 7 - SBYTE_ACKDET"]
            #[inline]
            pub fn sbyte_ackdet(&self) -> SBYTE_ACKDETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBYTE_ACKDETR { bits }
            }
            #[doc = "Bit 8 - HS_NORSTRT"]
            #[inline]
            pub fn hs_norstrt(&self) -> HS_NORSTRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HS_NORSTRTR { bits }
            }
            #[doc = "Bit 9 - SBYTE_NORSTRT"]
            #[inline]
            pub fn sbyte_norstrt(&self) -> SBYTE_NORSTRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SBYTE_NORSTRTR { bits }
            }
            #[doc = "Bit 10 - 10B_RD_NORSTRT"]
            #[inline]
            pub fn rd_10_norstrt(&self) -> RD_10_NORSTRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RD_10_NORSTRTR { bits }
            }
            #[doc = "Bit 11 - MASTER_DIS"]
            #[inline]
            pub fn master_dis(&self) -> MASTER_DISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASTER_DISR { bits }
            }
            #[doc = "Bit 12 - MST_ARBLOST"]
            #[inline]
            pub fn mst_arblost(&self) -> MST_ARBLOSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MST_ARBLOSTR { bits }
            }
            #[doc = "Bit 13 - SLVFLUSH_TXFIFO"]
            #[inline]
            pub fn slvflush_txfifo(&self) -> SLVFLUSH_TXFIFOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVFLUSH_TXFIFOR { bits }
            }
            #[doc = "Bit 14 - SLV_ARBLOST"]
            #[inline]
            pub fn slv_arblost(&self) -> SLV_ARBLOSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLV_ARBLOSTR { bits }
            }
            #[doc = "Bit 15 - SLVRD_INTX"]
            #[inline]
            pub fn slvrd_intx(&self) -> SLVRD_INTXR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVRD_INTXR { bits }
            }
            #[doc = "Bit 16 - USER_ABRT"]
            #[inline]
            pub fn user_abrt(&self) -> USER_ABRTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USER_ABRTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - 7B_ADDR_NOACK"]
            #[inline]
            pub fn addr7_noack(&mut self) -> _ADDR7_NOACKW {
                _ADDR7_NOACKW { w: self }
            }
            #[doc = "Bit 1 - 10B_ADDR1_NOACK"]
            #[inline]
            pub fn addr1_10_noack(&mut self) -> _ADDR1_10_NOACKW {
                _ADDR1_10_NOACKW { w: self }
            }
            #[doc = "Bit 2 - 10B_ADDR2_NOACK"]
            #[inline]
            pub fn addr2_10_noack(&mut self) -> _ADDR2_10_NOACKW {
                _ADDR2_10_NOACKW { w: self }
            }
            #[doc = "Bit 3 - TXDATA_NOACK"]
            #[inline]
            pub fn txdata_noack(&mut self) -> _TXDATA_NOACKW {
                _TXDATA_NOACKW { w: self }
            }
            #[doc = "Bit 4 - GCALL_NOACK"]
            #[inline]
            pub fn gcall_noack(&mut self) -> _GCALL_NOACKW {
                _GCALL_NOACKW { w: self }
            }
            #[doc = "Bit 5 - GCALL_READ"]
            #[inline]
            pub fn gcall_read(&mut self) -> _GCALL_READW {
                _GCALL_READW { w: self }
            }
            #[doc = "Bit 6 - HS_ACKDET"]
            #[inline]
            pub fn hs_ackdet(&mut self) -> _HS_ACKDETW {
                _HS_ACKDETW { w: self }
            }
            #[doc = "Bit 7 - SBYTE_ACKDET"]
            #[inline]
            pub fn sbyte_ackdet(&mut self) -> _SBYTE_ACKDETW {
                _SBYTE_ACKDETW { w: self }
            }
            #[doc = "Bit 8 - HS_NORSTRT"]
            #[inline]
            pub fn hs_norstrt(&mut self) -> _HS_NORSTRTW {
                _HS_NORSTRTW { w: self }
            }
            #[doc = "Bit 9 - SBYTE_NORSTRT"]
            #[inline]
            pub fn sbyte_norstrt(&mut self) -> _SBYTE_NORSTRTW {
                _SBYTE_NORSTRTW { w: self }
            }
            #[doc = "Bit 10 - 10B_RD_NORSTRT"]
            #[inline]
            pub fn rd_10_norstrt(&mut self) -> _RD_10_NORSTRTW {
                _RD_10_NORSTRTW { w: self }
            }
            #[doc = "Bit 11 - MASTER_DIS"]
            #[inline]
            pub fn master_dis(&mut self) -> _MASTER_DISW {
                _MASTER_DISW { w: self }
            }
            #[doc = "Bit 12 - MST_ARBLOST"]
            #[inline]
            pub fn mst_arblost(&mut self) -> _MST_ARBLOSTW {
                _MST_ARBLOSTW { w: self }
            }
            #[doc = "Bit 13 - SLVFLUSH_TXFIFO"]
            #[inline]
            pub fn slvflush_txfifo(&mut self) -> _SLVFLUSH_TXFIFOW {
                _SLVFLUSH_TXFIFOW { w: self }
            }
            #[doc = "Bit 14 - SLV_ARBLOST"]
            #[inline]
            pub fn slv_arblost(&mut self) -> _SLV_ARBLOSTW {
                _SLV_ARBLOSTW { w: self }
            }
            #[doc = "Bit 15 - SLVRD_INTX"]
            #[inline]
            pub fn slvrd_intx(&mut self) -> _SLVRD_INTXW {
                _SLVRD_INTXW { w: self }
            }
            #[doc = "Bit 16 - USER_ABRT"]
            #[inline]
            pub fn user_abrt(&mut self) -> _USER_ABRTW {
                _USER_ABRTW { w: self }
            }
        }
    }
    #[doc = "I2C DMA Control Register"]
    pub struct DMA_CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C DMA Control Register"]
    pub mod dma_cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RDMAER {
            bits: bool,
        }
        impl RDMAER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TDMAER {
            bits: bool,
        }
        impl TDMAER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RDMAEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RDMAEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TDMAEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TDMAEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RDMAE"]
            #[inline]
            pub fn rdmae(&self) -> RDMAER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RDMAER { bits }
            }
            #[doc = "Bit 1 - TDMAE"]
            #[inline]
            pub fn tdmae(&self) -> TDMAER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TDMAER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - RDMAE"]
            #[inline]
            pub fn rdmae(&mut self) -> _RDMAEW {
                _RDMAEW { w: self }
            }
            #[doc = "Bit 1 - TDMAE"]
            #[inline]
            pub fn tdmae(&mut self) -> _TDMAEW {
                _TDMAEW { w: self }
            }
        }
    }
    #[doc = "DMA Transmit Data Level Register"]
    pub struct DMA_TDLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Transmit Data Level Register"]
    pub mod dma_tdlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_TDLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "DMA Receive Data Level Register"]
    pub struct DMA_RDLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA Receive Data Level Register"]
    pub mod dma_rdlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_RDLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "SDA Setup Register"]
    pub struct SDA_SETUP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SDA Setup Register"]
    pub mod sda_setup {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SDA_SETUP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "ACK General Call Register"]
    pub struct GENERAL_CALL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "ACK General Call Register"]
    pub mod general_call {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GENERAL_CALL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALL_ENABLER {
            bits: bool,
        }
        impl CALL_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALL_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALL_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CALL_ENABLE"]
            #[inline]
            pub fn call_enable(&self) -> CALL_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CALL_ENABLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - CALL_ENABLE"]
            #[inline]
            pub fn call_enable(&mut self) -> _CALL_ENABLEW {
                _CALL_ENABLEW { w: self }
            }
        }
    }
    #[doc = "Enable Status Register"]
    pub struct ENABLE_STATUS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Enable Status Register"]
    pub mod enable_status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ENABLE_STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct IC_ENABLER {
            bits: bool,
        }
        impl IC_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLV_DIS_BUSYR {
            bits: bool,
        }
        impl SLV_DIS_BUSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLV_RX_DATA_LOSTR {
            bits: bool,
        }
        impl SLV_RX_DATA_LOSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IC_ENABLE"]
            #[inline]
            pub fn ic_enable(&self) -> IC_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IC_ENABLER { bits }
            }
            #[doc = "Bit 1 - SLV_DIS_BUSY"]
            #[inline]
            pub fn slv_dis_busy(&self) -> SLV_DIS_BUSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLV_DIS_BUSYR { bits }
            }
            #[doc = "Bit 2 - SLV_RX_DATA_LOST"]
            #[inline]
            pub fn slv_rx_data_lost(&self) -> SLV_RX_DATA_LOSTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLV_RX_DATA_LOSTR { bits }
            }
        }
    }
    #[doc = "SS, FS or FM+ spike suppression limit"]
    pub struct FS_SPKLEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SS, FS or FM+ spike suppression limit"]
    pub mod fs_spklen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FS_SPKLEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - VALUE"]
            #[inline]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
    #[doc = "Component Parameter Register 1"]
    pub struct COMP_PARAM_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameter Register 1"]
    pub mod comp_param_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::COMP_PARAM_1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB_DATA_WIDTHR {
            bits: u8,
        }
        impl APB_DATA_WIDTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MAX_SPEED_MODER {
            bits: u8,
        }
        impl MAX_SPEED_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HC_COUNT_VALUESR {
            bits: bool,
        }
        impl HC_COUNT_VALUESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTR_IOR {
            bits: bool,
        }
        impl INTR_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HAS_DMAR {
            bits: bool,
        }
        impl HAS_DMAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENCODED_PARAMSR {
            bits: bool,
        }
        impl ENCODED_PARAMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_BUFFER_DEPTHR {
            bits: u8,
        }
        impl RX_BUFFER_DEPTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_BUFFER_DEPTHR {
            bits: u8,
        }
        impl TX_BUFFER_DEPTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - APB_DATA_WIDTH"]
            #[inline]
            pub fn apb_data_width(&self) -> APB_DATA_WIDTHR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                APB_DATA_WIDTHR { bits }
            }
            #[doc = "Bits 2:3 - MAX_SPEED_MODE"]
            #[inline]
            pub fn max_speed_mode(&self) -> MAX_SPEED_MODER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MAX_SPEED_MODER { bits }
            }
            #[doc = "Bit 4 - HC_COUNT_VALUES"]
            #[inline]
            pub fn hc_count_values(&self) -> HC_COUNT_VALUESR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HC_COUNT_VALUESR { bits }
            }
            #[doc = "Bit 5 - INTR_IO"]
            #[inline]
            pub fn intr_io(&self) -> INTR_IOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INTR_IOR { bits }
            }
            #[doc = "Bit 6 - HAS_DMA"]
            #[inline]
            pub fn has_dma(&self) -> HAS_DMAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HAS_DMAR { bits }
            }
            #[doc = "Bit 7 - ENCODED_PARAMS"]
            #[inline]
            pub fn encoded_params(&self) -> ENCODED_PARAMSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENCODED_PARAMSR { bits }
            }
            #[doc = "Bits 8:15 - RX_BUFFER_DEPTH"]
            #[inline]
            pub fn rx_buffer_depth(&self) -> RX_BUFFER_DEPTHR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RX_BUFFER_DEPTHR { bits }
            }
            #[doc = "Bits 16:23 - TX_BUFFER_DEPTH"]
            #[inline]
            pub fn tx_buffer_depth(&self) -> TX_BUFFER_DEPTHR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TX_BUFFER_DEPTHR { bits }
            }
        }
    }
    #[doc = "Component Version Register"]
    pub struct COMP_VERSION {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Version Register"]
    pub mod comp_version {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::COMP_VERSION {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u32,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                VALUER { bits }
            }
        }
    }
    #[doc = "Component Type Register"]
    pub struct COMP_TYPE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Type Register"]
    pub mod comp_type {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::COMP_TYPE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u32,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - VALUE"]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                VALUER { bits }
            }
        }
    }
}
#[doc = "Inter-Integrated Circuit Bus 1"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x5029_0000 as *const _
    }
}
impl Deref for I2C1 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C1::ptr() }
    }
}
#[doc = "Inter-Integrated Circuit Bus 2"]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c0::RegisterBlock {
        0x502a_0000 as *const _
    }
}
impl Deref for I2C2 {
    type Target = i2c0::RegisterBlock;
    fn deref(&self) -> &i2c0::RegisterBlock {
        unsafe { &*I2C2::ptr() }
    }
}
#[doc = "Field Programmable IO Array"]
pub struct FPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FPIOA {}
impl FPIOA {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const fpioa::RegisterBlock {
        0x502b_0000 as *const _
    }
}
impl Deref for FPIOA {
    type Target = fpioa::RegisterBlock;
    fn deref(&self) -> &fpioa::RegisterBlock {
        unsafe { &*FPIOA::ptr() }
    }
}
#[doc = "Field Programmable IO Array"]
pub mod fpioa {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - FPIOA GPIO multiplexer io array"]
        pub io: [IO; 48],
        #[doc = "0xc0 - FPIOA GPIO multiplexer tie enable array"]
        pub tie_en: [TIE_EN; 8],
        #[doc = "0xe0 - FPIOA GPIO multiplexer tie value array"]
        pub tie_val: [TIE_VAL; 8],
    }
    #[doc = "FPIOA GPIO multiplexer io array"]
    pub struct IO {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FPIOA GPIO multiplexer io array"]
    pub mod io {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CH_SELR {
            bits: u8,
        }
        impl CH_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DSR {
            bits: u8,
        }
        impl DSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OE_ENR {
            bits: bool,
        }
        impl OE_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OE_INVR {
            bits: bool,
        }
        impl OE_INVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DO_SELR {
            bits: bool,
        }
        impl DO_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DO_INVR {
            bits: bool,
        }
        impl DO_INVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PUR {
            bits: bool,
        }
        impl PUR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PDR {
            bits: bool,
        }
        impl PDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLR {
            bits: bool,
        }
        impl SLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IE_ENR {
            bits: bool,
        }
        impl IE_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IE_INVR {
            bits: bool,
        }
        impl IE_INVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DI_INVR {
            bits: bool,
        }
        impl DI_INVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STR {
            bits: bool,
        }
        impl STR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAD_DIR {
            bits: bool,
        }
        impl PAD_DIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OE_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OE_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OE_INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OE_INVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DO_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DO_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DO_INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DO_INVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PUW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PUW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IE_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IE_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IE_INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IE_INVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DI_INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DI_INVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAD_DIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAD_DIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Channel select from 256 input"]
            #[inline]
            pub fn ch_sel(&self) -> CH_SELR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CH_SELR { bits }
            }
            #[doc = "Bits 8:11 - Driving selector"]
            #[inline]
            pub fn ds(&self) -> DSR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DSR { bits }
            }
            #[doc = "Bit 12 - Static output enable, will AND with OE_INV"]
            #[inline]
            pub fn oe_en(&self) -> OE_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OE_ENR { bits }
            }
            #[doc = "Bit 13 - Invert output enable"]
            #[inline]
            pub fn oe_inv(&self) -> OE_INVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OE_INVR { bits }
            }
            #[doc = "Bit 14 - Data output select: 0 for DO, 1 for OE"]
            #[inline]
            pub fn do_sel(&self) -> DO_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DO_SELR { bits }
            }
            #[doc = "Bit 15 - Invert the result of data output select (DO_SEL)"]
            #[inline]
            pub fn do_inv(&self) -> DO_INVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DO_INVR { bits }
            }
            #[doc = "Bit 16 - Pull up enable. 0 for nothing, 1 for pull up"]
            #[inline]
            pub fn pu(&self) -> PUR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PUR { bits }
            }
            #[doc = "Bit 17 - Pull down enable. 0 for nothing, 1 for pull down"]
            #[inline]
            pub fn pd(&self) -> PDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PDR { bits }
            }
            #[doc = "Bit 19 - Slew rate control enable"]
            #[inline]
            pub fn sl(&self) -> SLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLR { bits }
            }
            #[doc = "Bit 20 - Static input enable, will AND with IE_INV"]
            #[inline]
            pub fn ie_en(&self) -> IE_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IE_ENR { bits }
            }
            #[doc = "Bit 21 - Invert input enable"]
            #[inline]
            pub fn ie_inv(&self) -> IE_INVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IE_INVR { bits }
            }
            #[doc = "Bit 22 - Invert Data input"]
            #[inline]
            pub fn di_inv(&self) -> DI_INVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DI_INVR { bits }
            }
            #[doc = "Bit 23 - Schmitt trigger"]
            #[inline]
            pub fn st(&self) -> STR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STR { bits }
            }
            #[doc = "Bit 31 - Read current IO's data input"]
            #[inline]
            pub fn pad_di(&self) -> PAD_DIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAD_DIR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Channel select from 256 input"]
            #[inline]
            pub fn ch_sel(&mut self) -> _CH_SELW {
                _CH_SELW { w: self }
            }
            #[doc = "Bits 8:11 - Driving selector"]
            #[inline]
            pub fn ds(&mut self) -> _DSW {
                _DSW { w: self }
            }
            #[doc = "Bit 12 - Static output enable, will AND with OE_INV"]
            #[inline]
            pub fn oe_en(&mut self) -> _OE_ENW {
                _OE_ENW { w: self }
            }
            #[doc = "Bit 13 - Invert output enable"]
            #[inline]
            pub fn oe_inv(&mut self) -> _OE_INVW {
                _OE_INVW { w: self }
            }
            #[doc = "Bit 14 - Data output select: 0 for DO, 1 for OE"]
            #[inline]
            pub fn do_sel(&mut self) -> _DO_SELW {
                _DO_SELW { w: self }
            }
            #[doc = "Bit 15 - Invert the result of data output select (DO_SEL)"]
            #[inline]
            pub fn do_inv(&mut self) -> _DO_INVW {
                _DO_INVW { w: self }
            }
            #[doc = "Bit 16 - Pull up enable. 0 for nothing, 1 for pull up"]
            #[inline]
            pub fn pu(&mut self) -> _PUW {
                _PUW { w: self }
            }
            #[doc = "Bit 17 - Pull down enable. 0 for nothing, 1 for pull down"]
            #[inline]
            pub fn pd(&mut self) -> _PDW {
                _PDW { w: self }
            }
            #[doc = "Bit 19 - Slew rate control enable"]
            #[inline]
            pub fn sl(&mut self) -> _SLW {
                _SLW { w: self }
            }
            #[doc = "Bit 20 - Static input enable, will AND with IE_INV"]
            #[inline]
            pub fn ie_en(&mut self) -> _IE_ENW {
                _IE_ENW { w: self }
            }
            #[doc = "Bit 21 - Invert input enable"]
            #[inline]
            pub fn ie_inv(&mut self) -> _IE_INVW {
                _IE_INVW { w: self }
            }
            #[doc = "Bit 22 - Invert Data input"]
            #[inline]
            pub fn di_inv(&mut self) -> _DI_INVW {
                _DI_INVW { w: self }
            }
            #[doc = "Bit 23 - Schmitt trigger"]
            #[inline]
            pub fn st(&mut self) -> _STW {
                _STW { w: self }
            }
            #[doc = "Bit 31 - Read current IO's data input"]
            #[inline]
            pub fn pad_di(&mut self) -> _PAD_DIW {
                _PAD_DIW { w: self }
            }
        }
    }
    #[doc = "FPIOA GPIO multiplexer tie enable array"]
    pub struct TIE_EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FPIOA GPIO multiplexer tie enable array"]
    pub mod tie_en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TIE_EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "FPIOA GPIO multiplexer tie value array"]
    pub struct TIE_VAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FPIOA GPIO multiplexer tie value array"]
    pub mod tie_val {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TIE_VAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "SHA256 Accelerator"]
pub struct SHA256 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SHA256 {}
impl SHA256 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const sha256::RegisterBlock {
        0x502c_0000 as *const _
    }
}
impl Deref for SHA256 {
    type Target = sha256::RegisterBlock;
    fn deref(&self) -> &sha256::RegisterBlock {
        unsafe { &*SHA256::ptr() }
    }
}
#[doc = "SHA256 Accelerator"]
pub mod sha256 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Calculated SHA256 return value"]
        pub result: [RESULT; 8],
        #[doc = "0x20 - SHA256 input data is written to this register"]
        pub data_in: DATA_IN,
        _reserved0: [u8; 4usize],
        #[doc = "0x28 - Counters register"]
        pub num_reg: NUM_REG,
        #[doc = "0x2c - Function configuration register 0"]
        pub function_reg_0: FUNCTION_REG_0,
        _reserved1: [u8; 4usize],
        #[doc = "0x34 - Function configuration register 1"]
        pub function_reg_1: FUNCTION_REG_1,
    }
    #[doc = "Calculated SHA256 return value"]
    pub struct RESULT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Calculated SHA256 return value"]
    pub mod result {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RESULT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "SHA256 input data is written to this register"]
    pub struct DATA_IN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SHA256 input data is written to this register"]
    pub mod data_in {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA_IN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Counters register"]
    pub struct NUM_REG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Counters register"]
    pub mod num_reg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NUM_REG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA_CNTR {
            bits: u16,
        }
        impl DATA_CNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA_NUMR {
            bits: u16,
        }
        impl DATA_NUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_CNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_CNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_NUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_NUMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - The total amount of data calculated by SHA256 is set by this register, and the smallest unit is 512bit"]
            #[inline]
            pub fn data_cnt(&self) -> DATA_CNTR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DATA_CNTR { bits }
            }
            #[doc = "Bits 16:31 - Currently calculated block number. 512bit=1block"]
            #[inline]
            pub fn data_num(&self) -> DATA_NUMR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DATA_NUMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - The total amount of data calculated by SHA256 is set by this register, and the smallest unit is 512bit"]
            #[inline]
            pub fn data_cnt(&mut self) -> _DATA_CNTW {
                _DATA_CNTW { w: self }
            }
            #[doc = "Bits 16:31 - Currently calculated block number. 512bit=1block"]
            #[inline]
            pub fn data_num(&mut self) -> _DATA_NUMW {
                _DATA_NUMW { w: self }
            }
        }
    }
    #[doc = "Function configuration register 0"]
    pub struct FUNCTION_REG_0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Function configuration register 0"]
    pub mod function_reg_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FUNCTION_REG_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENR {
            bits: bool,
        }
        impl ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERFLOWR {
            bits: bool,
        }
        impl OVERFLOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `endian`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDIANR {
            #[doc = "Little endian"]
            LE,
            #[doc = "Big endian"]
            BE,
        }
        impl ENDIANR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDIANR::LE => false,
                    ENDIANR::BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDIANR {
                match value {
                    false => ENDIANR::LE,
                    true => ENDIANR::BE,
                }
            }
            #[doc = "Checks if the value of the field is `LE`"]
            #[inline]
            pub fn is_le(&self) -> bool {
                *self == ENDIANR::LE
            }
            #[doc = "Checks if the value of the field is `BE`"]
            #[inline]
            pub fn is_be(&self) -> bool {
                *self == ENDIANR::BE
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERFLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERFLOWW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `endian`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDIANW {
            #[doc = "Little endian"]
            LE,
            #[doc = "Big endian"]
            BE,
        }
        impl ENDIANW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDIANW::LE => false,
                    ENDIANW::BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDIANW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDIANW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDIANW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Little endian"]
            #[inline]
            pub fn le(self) -> &'a mut W {
                self.variant(ENDIANW::LE)
            }
            #[doc = "Big endian"]
            #[inline]
            pub fn be(self) -> &'a mut W {
                self.variant(ENDIANW::BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - write:SHA256 enable register. read:Calculation completed flag"]
            #[inline]
            pub fn en(&self) -> ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENR { bits }
            }
            #[doc = "Bit 8 - SHA256 calculation overflow flag"]
            #[inline]
            pub fn overflow(&self) -> OVERFLOWR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERFLOWR { bits }
            }
            #[doc = "Bit 16 - Endian setting"]
            #[inline]
            pub fn endian(&self) -> ENDIANR {
                ENDIANR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - write:SHA256 enable register. read:Calculation completed flag"]
            #[inline]
            pub fn en(&mut self) -> _ENW {
                _ENW { w: self }
            }
            #[doc = "Bit 8 - SHA256 calculation overflow flag"]
            #[inline]
            pub fn overflow(&mut self) -> _OVERFLOWW {
                _OVERFLOWW { w: self }
            }
            #[doc = "Bit 16 - Endian setting"]
            #[inline]
            pub fn endian(&mut self) -> _ENDIANW {
                _ENDIANW { w: self }
            }
        }
    }
    #[doc = "Function configuration register 1"]
    pub struct FUNCTION_REG_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Function configuration register 1"]
    pub mod function_reg_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FUNCTION_REG_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_ENR {
            bits: bool,
        }
        impl DMA_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIFO_IN_FULLR {
            bits: bool,
        }
        impl FIFO_IN_FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIFO_IN_FULLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIFO_IN_FULLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SHA and DMA handshake signals enable. 1:enable; 0:disable"]
            #[inline]
            pub fn dma_en(&self) -> DMA_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_ENR { bits }
            }
            #[doc = "Bit 8 - 1:SHA256 input fifo is full; 0:not full"]
            #[inline]
            pub fn fifo_in_full(&self) -> FIFO_IN_FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FIFO_IN_FULLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SHA and DMA handshake signals enable. 1:enable; 0:disable"]
            #[inline]
            pub fn dma_en(&mut self) -> _DMA_ENW {
                _DMA_ENW { w: self }
            }
            #[doc = "Bit 8 - 1:SHA256 input fifo is full; 0:not full"]
            #[inline]
            pub fn fifo_in_full(&mut self) -> _FIFO_IN_FULLW {
                _FIFO_IN_FULLW { w: self }
            }
        }
    }
}
#[doc = "Timer 0"]
pub struct TIMER0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER0 {}
impl TIMER0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const timer0::RegisterBlock {
        0x502d_0000 as *const _
    }
}
impl Deref for TIMER0 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        unsafe { &*TIMER0::ptr() }
    }
}
#[doc = "Timer 0"]
pub mod timer0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Channel cluster: load_count, current_value, control, eoi and intr_stat registers"]
        pub channel: [CHANNEL; 4],
        _reserved0: [u8; 80usize],
        #[doc = "0xa0 - Interrupt Status Register"]
        pub intr_stat: INTR_STAT,
        #[doc = "0xa4 - Interrupt Clear Register"]
        pub eoi: EOI,
        #[doc = "0xa8 - Raw Interrupt Status Register"]
        pub raw_intr_stat: RAW_INTR_STAT,
        #[doc = "0xac - Component Version Register"]
        pub comp_version: COMP_VERSION,
        #[doc = "0xb0 - Load Count2 Register"]
        pub load_count2: [LOAD_COUNT2; 4],
    }
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct CHANNEL {
        #[doc = "0x00 - Load Count Register"]
        pub load_count: self::channel::LOAD_COUNT,
        #[doc = "0x04 - Current Value Register"]
        pub current_value: self::channel::CURRENT_VALUE,
        #[doc = "0x08 - Control Register"]
        pub control: self::channel::CONTROL,
        #[doc = "0x0c - Interrupt Clear Register"]
        pub eoi: self::channel::EOI,
        #[doc = "0x10 - Interrupt Status Register"]
        pub intr_stat: self::channel::INTR_STAT,
    }
    #[doc = r" Register block"]
    #[doc = "Channel cluster: load_count, current_value, control, eoi and intr_stat registers"]
    pub mod channel {
        #[doc = "Load Count Register"]
        pub struct LOAD_COUNT {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Load Count Register"]
        pub mod load_count {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::LOAD_COUNT {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Current Value Register"]
        pub struct CURRENT_VALUE {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Current Value Register"]
        pub mod current_value {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::CURRENT_VALUE {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Control Register"]
        pub struct CONTROL {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Control Register"]
        pub mod control {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::CONTROL {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            #[doc = r" Value of the field"]
            pub struct ENABLER {
                bits: bool,
            }
            impl ENABLER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = "Possible values of the field `mode`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MODER {
                #[doc = "FREE_MODE"]
                FREE,
                #[doc = "USER_MODE"]
                USER,
            }
            impl MODER {
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    match *self {
                        MODER::FREE => false,
                        MODER::USER => true,
                    }
                }
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _from(value: bool) -> MODER {
                    match value {
                        false => MODER::FREE,
                        true => MODER::USER,
                    }
                }
                #[doc = "Checks if the value of the field is `FREE`"]
                #[inline]
                pub fn is_free(&self) -> bool {
                    *self == MODER::FREE
                }
                #[doc = "Checks if the value of the field is `USER`"]
                #[inline]
                pub fn is_user(&self) -> bool {
                    *self == MODER::USER
                }
            }
            #[doc = r" Value of the field"]
            pub struct INTERRUPTR {
                bits: bool,
            }
            impl INTERRUPTR {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Value of the field"]
            pub struct PWM_ENABLER {
                bits: bool,
            }
            impl PWM_ENABLER {
                #[doc = r" Value of the field as raw bits"]
                #[inline]
                pub fn bit(&self) -> bool {
                    self.bits
                }
                #[doc = r" Returns `true` if the bit is clear (0)"]
                #[inline]
                pub fn bit_is_clear(&self) -> bool {
                    !self.bit()
                }
                #[doc = r" Returns `true` if the bit is set (1)"]
                #[inline]
                pub fn bit_is_set(&self) -> bool {
                    self.bit()
                }
            }
            #[doc = r" Proxy"]
            pub struct _ENABLEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _ENABLEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = "Values that can be written to the field `mode`"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MODEW {
                #[doc = "FREE_MODE"]
                FREE,
                #[doc = "USER_MODE"]
                USER,
            }
            impl MODEW {
                #[allow(missing_docs)]
                #[doc(hidden)]
                #[inline]
                pub fn _bits(&self) -> bool {
                    match *self {
                        MODEW::FREE => false,
                        MODEW::USER => true,
                    }
                }
            }
            #[doc = r" Proxy"]
            pub struct _MODEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _MODEW<'a> {
                #[doc = r" Writes `variant` to the field"]
                #[inline]
                pub fn variant(self, variant: MODEW) -> &'a mut W {
                    {
                        self.bit(variant._bits())
                    }
                }
                #[doc = "FREE_MODE"]
                #[inline]
                pub fn free(self) -> &'a mut W {
                    self.variant(MODEW::FREE)
                }
                #[doc = "USER_MODE"]
                #[inline]
                pub fn user(self) -> &'a mut W {
                    self.variant(MODEW::USER)
                }
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _INTERRUPTW<'a> {
                w: &'a mut W,
            }
            impl<'a> _INTERRUPTW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            #[doc = r" Proxy"]
            pub struct _PWM_ENABLEW<'a> {
                w: &'a mut W,
            }
            impl<'a> _PWM_ENABLEW<'a> {
                #[doc = r" Sets the field bit"]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r" Clears the field bit"]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r" Writes raw bits to the field"]
                #[inline]
                pub fn bit(self, value: bool) -> &'a mut W {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    self.w.bits &= !((MASK as u32) << OFFSET);
                    self.w.bits |= ((value & MASK) as u32) << OFFSET;
                    self.w
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
                #[doc = "Bit 0 - ENABLE"]
                #[inline]
                pub fn enable(&self) -> ENABLER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 0;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    ENABLER { bits }
                }
                #[doc = "Bit 1 - MODE"]
                #[inline]
                pub fn mode(&self) -> MODER {
                    MODER::_from({
                        const MASK: bool = true;
                        const OFFSET: u8 = 1;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    })
                }
                #[doc = "Bit 2 - INTERRUPT_MASK"]
                #[inline]
                pub fn interrupt(&self) -> INTERRUPTR {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 2;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    INTERRUPTR { bits }
                }
                #[doc = "Bit 3 - PWM_ENABLE"]
                #[inline]
                pub fn pwm_enable(&self) -> PWM_ENABLER {
                    let bits = {
                        const MASK: bool = true;
                        const OFFSET: u8 = 3;
                        ((self.bits >> OFFSET) & MASK as u32) != 0
                    };
                    PWM_ENABLER { bits }
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
                #[doc = "Bit 0 - ENABLE"]
                #[inline]
                pub fn enable(&mut self) -> _ENABLEW {
                    _ENABLEW { w: self }
                }
                #[doc = "Bit 1 - MODE"]
                #[inline]
                pub fn mode(&mut self) -> _MODEW {
                    _MODEW { w: self }
                }
                #[doc = "Bit 2 - INTERRUPT_MASK"]
                #[inline]
                pub fn interrupt(&mut self) -> _INTERRUPTW {
                    _INTERRUPTW { w: self }
                }
                #[doc = "Bit 3 - PWM_ENABLE"]
                #[inline]
                pub fn pwm_enable(&mut self) -> _PWM_ENABLEW {
                    _PWM_ENABLEW { w: self }
                }
            }
        }
        #[doc = "Interrupt Clear Register"]
        pub struct EOI {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Interrupt Clear Register"]
        pub mod eoi {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::EOI {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
        #[doc = "Interrupt Status Register"]
        pub struct INTR_STAT {
            register: ::vcell::VolatileCell<u32>,
        }
        #[doc = "Interrupt Status Register"]
        pub mod intr_stat {
            #[doc = r" Value read from the register"]
            pub struct R {
                bits: u32,
            }
            #[doc = r" Value to write to the register"]
            pub struct W {
                bits: u32,
            }
            impl super::INTR_STAT {
                #[doc = r" Modifies the contents of the register"]
                #[inline]
                pub fn modify<F>(&self, f: F)
                where
                    for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
                {
                    let bits = self.register.get();
                    let r = R { bits };
                    let mut w = W { bits };
                    f(&r, &mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Reads the contents of the register"]
                #[inline]
                pub fn read(&self) -> R {
                    R {
                        bits: self.register.get(),
                    }
                }
                #[doc = r" Writes to the register"]
                #[inline]
                pub fn write<F>(&self, f: F)
                where
                    F: FnOnce(&mut W) -> &mut W,
                {
                    let mut w = W::reset_value();
                    f(&mut w);
                    self.register.set(w.bits);
                }
                #[doc = r" Writes the reset value to the register"]
                #[inline]
                pub fn reset(&self) {
                    self.write(|w| w)
                }
            }
            impl R {
                #[doc = r" Value of the register as raw bits"]
                #[inline]
                pub fn bits(&self) -> u32 {
                    self.bits
                }
            }
            impl W {
                #[doc = r" Reset value of the register"]
                #[inline]
                pub fn reset_value() -> W {
                    W { bits: 0 }
                }
                #[doc = r" Writes raw bits to the register"]
                #[inline]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct INTR_STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod intr_stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTR_STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Clear Register"]
    pub struct EOI {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Clear Register"]
    pub mod eoi {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EOI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Raw Interrupt Status Register"]
    pub struct RAW_INTR_STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw Interrupt Status Register"]
    pub mod raw_intr_stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RAW_INTR_STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Version Register"]
    pub struct COMP_VERSION {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Version Register"]
    pub mod comp_version {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_VERSION {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Load Count2 Register"]
    pub struct LOAD_COUNT2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Load Count2 Register"]
    pub mod load_count2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LOAD_COUNT2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Timer 1"]
pub struct TIMER1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER1 {}
impl TIMER1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const timer0::RegisterBlock {
        0x502e_0000 as *const _
    }
}
impl Deref for TIMER1 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        unsafe { &*TIMER1::ptr() }
    }
}
#[doc = "Timer 2"]
pub struct TIMER2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER2 {}
impl TIMER2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const timer0::RegisterBlock {
        0x502f_0000 as *const _
    }
}
impl Deref for TIMER2 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        unsafe { &*TIMER2::ptr() }
    }
}
#[doc = "Watchdog Timer 0"]
pub struct WDT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT0 {}
impl WDT0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wdt0::RegisterBlock {
        0x5040_0000 as *const _
    }
}
impl Deref for WDT0 {
    type Target = wdt0::RegisterBlock;
    fn deref(&self) -> &wdt0::RegisterBlock {
        unsafe { &*WDT0::ptr() }
    }
}
#[doc = "Watchdog Timer 0"]
pub mod wdt0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register"]
        pub cr: CR,
        #[doc = "0x04 - Timeout Range Register"]
        pub torr: TORR,
        #[doc = "0x08 - Current Counter Value Register"]
        pub ccvr: CCVR,
        #[doc = "0x0c - Counter Restart Register"]
        pub crr: CRR,
        #[doc = "0x10 - Interrupt Status Register"]
        pub stat: STAT,
        #[doc = "0x14 - Interrupt Clear Register"]
        pub eoi: EOI,
        _reserved0: [u8; 4usize],
        #[doc = "0x1c - Protection level Register"]
        pub prot_level: PROT_LEVEL,
        _reserved1: [u8; 196usize],
        #[doc = "0xe4 - Component Parameters Register 5"]
        pub comp_param_5: COMP_PARAM_5,
        #[doc = "0xe8 - Component Parameters Register 4"]
        pub comp_param_4: COMP_PARAM_4,
        #[doc = "0xec - Component Parameters Register 3"]
        pub comp_param_3: COMP_PARAM_3,
        #[doc = "0xf0 - Component Parameters Register 2"]
        pub comp_param_2: COMP_PARAM_2,
        #[doc = "0xf4 - Component Parameters Register 1"]
        pub comp_param_1: COMP_PARAM_1,
        #[doc = "0xf8 - Component Version Register"]
        pub comp_version: COMP_VERSION,
        #[doc = "0xfc - Component Type Register"]
        pub comp_type: COMP_TYPE,
    }
    #[doc = "Control Register"]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENABLER {
            bits: bool,
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `rmod`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMODR {
            #[doc = "RESET"]
            RESET,
            #[doc = "INTERRUPT"]
            INTERRUPT,
        }
        impl RMODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RMODR::RESET => false,
                    RMODR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RMODR {
                match value {
                    false => RMODR::RESET,
                    true => RMODR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == RMODR::RESET
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == RMODR::INTERRUPT
            }
        }
        #[doc = r" Value of the field"]
        pub struct RPLR {
            bits: u8,
        }
        impl RPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `rmod`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMODW {
            #[doc = "RESET"]
            RESET,
            #[doc = "INTERRUPT"]
            INTERRUPT,
        }
        impl RMODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RMODW::RESET => false,
                    RMODW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RMODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RMODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RESET"]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(RMODW::RESET)
            }
            #[doc = "INTERRUPT"]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(RMODW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RPLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - enable"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENABLER { bits }
            }
            #[doc = "Bit 1 - rmod"]
            #[inline]
            pub fn rmod(&self) -> RMODR {
                RMODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 2:4 - rpl"]
            #[inline]
            pub fn rpl(&self) -> RPLR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RPLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - enable"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 1 - rmod"]
            #[inline]
            pub fn rmod(&mut self) -> _RMODW {
                _RMODW { w: self }
            }
            #[doc = "Bits 2:4 - rpl"]
            #[inline]
            pub fn rpl(&mut self) -> _RPLW {
                _RPLW { w: self }
            }
        }
    }
    #[doc = "Timeout Range Register"]
    pub struct TORR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timeout Range Register"]
    pub mod torr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TORR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOP0R {
            bits: u8,
        }
        impl TOP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOP1R {
            bits: u8,
        }
        impl TOP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - top (lower half)"]
            #[inline]
            pub fn top0(&self) -> TOP0R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TOP0R { bits }
            }
            #[doc = "Bits 4:7 - top (upper half)"]
            #[inline]
            pub fn top1(&self) -> TOP1R {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TOP1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - top (lower half)"]
            #[inline]
            pub fn top0(&mut self) -> _TOP0W {
                _TOP0W { w: self }
            }
            #[doc = "Bits 4:7 - top (upper half)"]
            #[inline]
            pub fn top1(&mut self) -> _TOP1W {
                _TOP1W { w: self }
            }
        }
    }
    #[doc = "Current Counter Value Register"]
    pub struct CCVR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Current Counter Value Register"]
    pub mod ccvr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CCVR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Counter Restart Register"]
    pub struct CRR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Counter Restart Register"]
    pub mod crr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt Status Register"]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Status Register"]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATR {
            bits: bool,
        }
        impl STATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - stat"]
            #[inline]
            pub fn stat(&self) -> STATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - stat"]
            #[inline]
            pub fn stat(&mut self) -> _STATW {
                _STATW { w: self }
            }
        }
    }
    #[doc = "Interrupt Clear Register"]
    pub struct EOI {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Clear Register"]
    pub mod eoi {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EOI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOIR {
            bits: bool,
        }
        impl EOIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - eoi"]
            #[inline]
            pub fn eoi(&self) -> EOIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOIR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - eoi"]
            #[inline]
            pub fn eoi(&mut self) -> _EOIW {
                _EOIW { w: self }
            }
        }
    }
    #[doc = "Protection level Register"]
    pub struct PROT_LEVEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Protection level Register"]
    pub mod prot_level {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PROT_LEVEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROT_LEVELR {
            bits: u8,
        }
        impl PROT_LEVELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PROT_LEVELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PROT_LEVELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - prot_level"]
            #[inline]
            pub fn prot_level(&self) -> PROT_LEVELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PROT_LEVELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - prot_level"]
            #[inline]
            pub fn prot_level(&mut self) -> _PROT_LEVELW {
                _PROT_LEVELW { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 5"]
    pub struct COMP_PARAM_5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameters Register 5"]
    pub mod comp_param_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_PARAM_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct USER_TOP_MAXR {
            bits: u32,
        }
        impl USER_TOP_MAXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _USER_TOP_MAXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USER_TOP_MAXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - user_top_max"]
            #[inline]
            pub fn user_top_max(&self) -> USER_TOP_MAXR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                USER_TOP_MAXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - user_top_max"]
            #[inline]
            pub fn user_top_max(&mut self) -> _USER_TOP_MAXW {
                _USER_TOP_MAXW { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 4"]
    pub struct COMP_PARAM_4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameters Register 4"]
    pub mod comp_param_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_PARAM_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct USER_TOP_INIT_MAXR {
            bits: u32,
        }
        impl USER_TOP_INIT_MAXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _USER_TOP_INIT_MAXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USER_TOP_INIT_MAXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - user_top_init_max"]
            #[inline]
            pub fn user_top_init_max(&self) -> USER_TOP_INIT_MAXR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                USER_TOP_INIT_MAXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - user_top_init_max"]
            #[inline]
            pub fn user_top_init_max(&mut self) -> _USER_TOP_INIT_MAXW {
                _USER_TOP_INIT_MAXW { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 3"]
    pub struct COMP_PARAM_3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameters Register 3"]
    pub mod comp_param_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_PARAM_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOP_RSTR {
            bits: u32,
        }
        impl TOP_RSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOP_RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOP_RSTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - top_rst"]
            #[inline]
            pub fn top_rst(&self) -> TOP_RSTR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                TOP_RSTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - top_rst"]
            #[inline]
            pub fn top_rst(&mut self) -> _TOP_RSTW {
                _TOP_RSTW { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 2"]
    pub struct COMP_PARAM_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameters Register 2"]
    pub mod comp_param_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_PARAM_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNT_RSTR {
            bits: u32,
        }
        impl CNT_RSTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNT_RSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNT_RSTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - cnt_rst"]
            #[inline]
            pub fn cnt_rst(&self) -> CNT_RSTR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CNT_RSTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - cnt_rst"]
            #[inline]
            pub fn cnt_rst(&mut self) -> _CNT_RSTW {
                _CNT_RSTW { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 1"]
    pub struct COMP_PARAM_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Parameters Register 1"]
    pub mod comp_param_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_PARAM_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALWAYS_ENR {
            bits: bool,
        }
        impl ALWAYS_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLT_RMODR {
            bits: bool,
        }
        impl DFLT_RMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DUAL_TOPR {
            bits: bool,
        }
        impl DUAL_TOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HC_RMODR {
            bits: bool,
        }
        impl HC_RMODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HC_RPLR {
            bits: bool,
        }
        impl HC_RPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HC_TOPR {
            bits: bool,
        }
        impl HC_TOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct USE_FIX_TOPR {
            bits: bool,
        }
        impl USE_FIX_TOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PAUSER {
            bits: bool,
        }
        impl PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB_DATA_WIDTHR {
            bits: u8,
        }
        impl APB_DATA_WIDTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLT_RPLR {
            bits: u8,
        }
        impl DFLT_RPLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLT_TOPR {
            bits: u8,
        }
        impl DFLT_TOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DFLT_TOP_INITR {
            bits: u8,
        }
        impl DFLT_TOP_INITR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CNT_WIDTHR {
            bits: u8,
        }
        impl CNT_WIDTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALWAYS_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALWAYS_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLT_RMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLT_RMODW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DUAL_TOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DUAL_TOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HC_RMODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HC_RMODW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HC_RPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HC_RPLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HC_TOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HC_TOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _USE_FIX_TOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USE_FIX_TOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB_DATA_WIDTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB_DATA_WIDTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLT_RPLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLT_RPLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLT_TOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLT_TOPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DFLT_TOP_INITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DFLT_TOP_INITW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CNT_WIDTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CNT_WIDTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - always_en"]
            #[inline]
            pub fn always_en(&self) -> ALWAYS_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ALWAYS_ENR { bits }
            }
            #[doc = "Bit 1 - dflt_rmod"]
            #[inline]
            pub fn dflt_rmod(&self) -> DFLT_RMODR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DFLT_RMODR { bits }
            }
            #[doc = "Bit 2 - dual_top"]
            #[inline]
            pub fn dual_top(&self) -> DUAL_TOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DUAL_TOPR { bits }
            }
            #[doc = "Bit 3 - hc_rmod"]
            #[inline]
            pub fn hc_rmod(&self) -> HC_RMODR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HC_RMODR { bits }
            }
            #[doc = "Bit 4 - hc_rpl"]
            #[inline]
            pub fn hc_rpl(&self) -> HC_RPLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HC_RPLR { bits }
            }
            #[doc = "Bit 5 - hc_top"]
            #[inline]
            pub fn hc_top(&self) -> HC_TOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HC_TOPR { bits }
            }
            #[doc = "Bit 6 - use_fix_top"]
            #[inline]
            pub fn use_fix_top(&self) -> USE_FIX_TOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                USE_FIX_TOPR { bits }
            }
            #[doc = "Bit 7 - pause"]
            #[inline]
            pub fn pause(&self) -> PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PAUSER { bits }
            }
            #[doc = "Bits 8:9 - apb_data_width"]
            #[inline]
            pub fn apb_data_width(&self) -> APB_DATA_WIDTHR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                APB_DATA_WIDTHR { bits }
            }
            #[doc = "Bits 10:12 - dflt_rpl"]
            #[inline]
            pub fn dflt_rpl(&self) -> DFLT_RPLR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DFLT_RPLR { bits }
            }
            #[doc = "Bits 16:19 - dflt_top"]
            #[inline]
            pub fn dflt_top(&self) -> DFLT_TOPR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DFLT_TOPR { bits }
            }
            #[doc = "Bits 20:23 - dflt_top_init"]
            #[inline]
            pub fn dflt_top_init(&self) -> DFLT_TOP_INITR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DFLT_TOP_INITR { bits }
            }
            #[doc = "Bits 24:28 - cnt_width"]
            #[inline]
            pub fn cnt_width(&self) -> CNT_WIDTHR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CNT_WIDTHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - always_en"]
            #[inline]
            pub fn always_en(&mut self) -> _ALWAYS_ENW {
                _ALWAYS_ENW { w: self }
            }
            #[doc = "Bit 1 - dflt_rmod"]
            #[inline]
            pub fn dflt_rmod(&mut self) -> _DFLT_RMODW {
                _DFLT_RMODW { w: self }
            }
            #[doc = "Bit 2 - dual_top"]
            #[inline]
            pub fn dual_top(&mut self) -> _DUAL_TOPW {
                _DUAL_TOPW { w: self }
            }
            #[doc = "Bit 3 - hc_rmod"]
            #[inline]
            pub fn hc_rmod(&mut self) -> _HC_RMODW {
                _HC_RMODW { w: self }
            }
            #[doc = "Bit 4 - hc_rpl"]
            #[inline]
            pub fn hc_rpl(&mut self) -> _HC_RPLW {
                _HC_RPLW { w: self }
            }
            #[doc = "Bit 5 - hc_top"]
            #[inline]
            pub fn hc_top(&mut self) -> _HC_TOPW {
                _HC_TOPW { w: self }
            }
            #[doc = "Bit 6 - use_fix_top"]
            #[inline]
            pub fn use_fix_top(&mut self) -> _USE_FIX_TOPW {
                _USE_FIX_TOPW { w: self }
            }
            #[doc = "Bit 7 - pause"]
            #[inline]
            pub fn pause(&mut self) -> _PAUSEW {
                _PAUSEW { w: self }
            }
            #[doc = "Bits 8:9 - apb_data_width"]
            #[inline]
            pub fn apb_data_width(&mut self) -> _APB_DATA_WIDTHW {
                _APB_DATA_WIDTHW { w: self }
            }
            #[doc = "Bits 10:12 - dflt_rpl"]
            #[inline]
            pub fn dflt_rpl(&mut self) -> _DFLT_RPLW {
                _DFLT_RPLW { w: self }
            }
            #[doc = "Bits 16:19 - dflt_top"]
            #[inline]
            pub fn dflt_top(&mut self) -> _DFLT_TOPW {
                _DFLT_TOPW { w: self }
            }
            #[doc = "Bits 20:23 - dflt_top_init"]
            #[inline]
            pub fn dflt_top_init(&mut self) -> _DFLT_TOP_INITW {
                _DFLT_TOP_INITW { w: self }
            }
            #[doc = "Bits 24:28 - cnt_width"]
            #[inline]
            pub fn cnt_width(&mut self) -> _CNT_WIDTHW {
                _CNT_WIDTHW { w: self }
            }
        }
    }
    #[doc = "Component Version Register"]
    pub struct COMP_VERSION {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Version Register"]
    pub mod comp_version {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_VERSION {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Component Type Register"]
    pub struct COMP_TYPE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Component Type Register"]
    pub mod comp_type {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COMP_TYPE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Watchdog Timer 1"]
pub struct WDT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT1 {}
impl WDT1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wdt0::RegisterBlock {
        0x5041_0000 as *const _
    }
}
impl Deref for WDT1 {
    type Target = wdt0::RegisterBlock;
    fn deref(&self) -> &wdt0::RegisterBlock {
        unsafe { &*WDT1::ptr() }
    }
}
#[doc = "One-Time Programmable Memory Controller"]
pub struct OTP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for OTP {}
impl OTP {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const otp::RegisterBlock {
        0x5042_0000 as *const _
    }
}
impl Deref for OTP {
    type Target = otp::RegisterBlock;
    fn deref(&self) -> &otp::RegisterBlock {
        unsafe { &*OTP::ptr() }
    }
}
#[doc = "One-Time Programmable Memory Controller"]
pub mod otp {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Dummy register: this peripheral is not implemented yet"]
        pub dummy: DUMMY,
    }
    #[doc = "Dummy register: this peripheral is not implemented yet"]
    pub struct DUMMY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Dummy register: this peripheral is not implemented yet"]
    pub mod dummy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DUMMY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Digital Video Port"]
pub struct DVP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DVP {}
impl DVP {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const dvp::RegisterBlock {
        0x5043_0000 as *const _
    }
}
impl Deref for DVP {
    type Target = dvp::RegisterBlock;
    fn deref(&self) -> &dvp::RegisterBlock {
        unsafe { &*DVP::ptr() }
    }
}
#[doc = "Digital Video Port"]
pub mod dvp {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Config Register"]
        pub dvp_cfg: DVP_CFG,
        #[doc = "0x04 - R_ADDR"]
        pub r_addr: R_ADDR,
        #[doc = "0x08 - G_ADDR"]
        pub g_addr: G_ADDR,
        #[doc = "0x0c - B_ADDR"]
        pub b_addr: B_ADDR,
        #[doc = "0x10 - CMOS Config Register"]
        pub cmos_cfg: CMOS_CFG,
        #[doc = "0x14 - SCCB Config Register"]
        pub sccb_cfg: SCCB_CFG,
        #[doc = "0x18 - SCCB Control Register"]
        pub sccb_ctl: SCCB_CTL,
        #[doc = "0x1c - AXI Register"]
        pub axi: AXI,
        #[doc = "0x20 - STS Register"]
        pub sts: STS,
        #[doc = "0x24 - REVERSE"]
        pub reverse: REVERSE,
        #[doc = "0x28 - RGB_ADDR"]
        pub rgb_addr: RGB_ADDR,
    }
    #[doc = "Config Register"]
    pub struct DVP_CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Config Register"]
    pub mod dvp_cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DVP_CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct START_INT_ENABLER {
            bits: bool,
        }
        impl START_INT_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FINISH_INT_ENABLER {
            bits: bool,
        }
        impl FINISH_INT_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AI_OUTPUT_ENABLER {
            bits: bool,
        }
        impl AI_OUTPUT_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DISPLAY_OUTPUT_ENABLER {
            bits: bool,
        }
        impl DISPLAY_OUTPUT_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTO_ENABLER {
            bits: bool,
        }
        impl AUTO_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BURST_SIZE_4BEATSR {
            bits: bool,
        }
        impl BURST_SIZE_4BEATSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `format`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FORMATR {
            #[doc = "RGB_FORMAT"]
            RGB,
            #[doc = "YUV_FORMAT"]
            YUV,
            #[doc = "Y_FORMAT"]
            Y,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FORMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FORMATR::RGB => 0,
                    FORMATR::YUV => 0x01,
                    FORMATR::Y => 0x03,
                    FORMATR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FORMATR {
                match value {
                    0 => FORMATR::RGB,
                    1 => FORMATR::YUV,
                    3 => FORMATR::Y,
                    i => FORMATR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RGB`"]
            #[inline]
            pub fn is_rgb(&self) -> bool {
                *self == FORMATR::RGB
            }
            #[doc = "Checks if the value of the field is `YUV`"]
            #[inline]
            pub fn is_yuv(&self) -> bool {
                *self == FORMATR::YUV
            }
            #[doc = "Checks if the value of the field is `Y`"]
            #[inline]
            pub fn is_y(&self) -> bool {
                *self == FORMATR::Y
            }
        }
        #[doc = r" Value of the field"]
        pub struct HREF_BURST_NUMR {
            bits: u8,
        }
        impl HREF_BURST_NUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LINE_NUMR {
            bits: u16,
        }
        impl LINE_NUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _START_INT_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _START_INT_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FINISH_INT_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FINISH_INT_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AI_OUTPUT_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AI_OUTPUT_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISPLAY_OUTPUT_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISPLAY_OUTPUT_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTO_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTO_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BURST_SIZE_4BEATSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BURST_SIZE_4BEATSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `format`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FORMATW {
            #[doc = "RGB_FORMAT"]
            RGB,
            #[doc = "YUV_FORMAT"]
            YUV,
            #[doc = "Y_FORMAT"]
            Y,
        }
        impl FORMATW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FORMATW::RGB => 0,
                    FORMATW::YUV => 1,
                    FORMATW::Y => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FORMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FORMATW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FORMATW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "RGB_FORMAT"]
            #[inline]
            pub fn rgb(self) -> &'a mut W {
                self.variant(FORMATW::RGB)
            }
            #[doc = "YUV_FORMAT"]
            #[inline]
            pub fn yuv(self) -> &'a mut W {
                self.variant(FORMATW::YUV)
            }
            #[doc = "Y_FORMAT"]
            #[inline]
            pub fn y(self) -> &'a mut W {
                self.variant(FORMATW::Y)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HREF_BURST_NUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HREF_BURST_NUMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LINE_NUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LINE_NUMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - START_INT_ENABLE"]
            #[inline]
            pub fn start_int_enable(&self) -> START_INT_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                START_INT_ENABLER { bits }
            }
            #[doc = "Bit 1 - FINISH_INT_ENABLE"]
            #[inline]
            pub fn finish_int_enable(&self) -> FINISH_INT_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FINISH_INT_ENABLER { bits }
            }
            #[doc = "Bit 2 - AI_OUTPUT_ENABLE"]
            #[inline]
            pub fn ai_output_enable(&self) -> AI_OUTPUT_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AI_OUTPUT_ENABLER { bits }
            }
            #[doc = "Bit 3 - DISPLAY_OUTPUT_ENABLE"]
            #[inline]
            pub fn display_output_enable(&self) -> DISPLAY_OUTPUT_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DISPLAY_OUTPUT_ENABLER { bits }
            }
            #[doc = "Bit 4 - AUTO_ENABLE"]
            #[inline]
            pub fn auto_enable(&self) -> AUTO_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTO_ENABLER { bits }
            }
            #[doc = "Bit 8 - BURST_SIZE_4BEATS"]
            #[inline]
            pub fn burst_size_4beats(&self) -> BURST_SIZE_4BEATSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BURST_SIZE_4BEATSR { bits }
            }
            #[doc = "Bits 9:10 - FORMAT"]
            #[inline]
            pub fn format(&self) -> FORMATR {
                FORMATR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:19 - HREF_BURST_NUM"]
            #[inline]
            pub fn href_burst_num(&self) -> HREF_BURST_NUMR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HREF_BURST_NUMR { bits }
            }
            #[doc = "Bits 20:29 - LINE_NUM"]
            #[inline]
            pub fn line_num(&self) -> LINE_NUMR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LINE_NUMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - START_INT_ENABLE"]
            #[inline]
            pub fn start_int_enable(&mut self) -> _START_INT_ENABLEW {
                _START_INT_ENABLEW { w: self }
            }
            #[doc = "Bit 1 - FINISH_INT_ENABLE"]
            #[inline]
            pub fn finish_int_enable(&mut self) -> _FINISH_INT_ENABLEW {
                _FINISH_INT_ENABLEW { w: self }
            }
            #[doc = "Bit 2 - AI_OUTPUT_ENABLE"]
            #[inline]
            pub fn ai_output_enable(&mut self) -> _AI_OUTPUT_ENABLEW {
                _AI_OUTPUT_ENABLEW { w: self }
            }
            #[doc = "Bit 3 - DISPLAY_OUTPUT_ENABLE"]
            #[inline]
            pub fn display_output_enable(&mut self) -> _DISPLAY_OUTPUT_ENABLEW {
                _DISPLAY_OUTPUT_ENABLEW { w: self }
            }
            #[doc = "Bit 4 - AUTO_ENABLE"]
            #[inline]
            pub fn auto_enable(&mut self) -> _AUTO_ENABLEW {
                _AUTO_ENABLEW { w: self }
            }
            #[doc = "Bit 8 - BURST_SIZE_4BEATS"]
            #[inline]
            pub fn burst_size_4beats(&mut self) -> _BURST_SIZE_4BEATSW {
                _BURST_SIZE_4BEATSW { w: self }
            }
            #[doc = "Bits 9:10 - FORMAT"]
            #[inline]
            pub fn format(&mut self) -> _FORMATW {
                _FORMATW { w: self }
            }
            #[doc = "Bits 12:19 - HREF_BURST_NUM"]
            #[inline]
            pub fn href_burst_num(&mut self) -> _HREF_BURST_NUMW {
                _HREF_BURST_NUMW { w: self }
            }
            #[doc = "Bits 20:29 - LINE_NUM"]
            #[inline]
            pub fn line_num(&mut self) -> _LINE_NUMW {
                _LINE_NUMW { w: self }
            }
        }
    }
    #[doc = "R_ADDR"]
    pub struct R_ADDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "R_ADDR"]
    pub mod r_addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::R_ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "G_ADDR"]
    pub struct G_ADDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "G_ADDR"]
    pub mod g_addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::G_ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "B_ADDR"]
    pub struct B_ADDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "B_ADDR"]
    pub mod b_addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::B_ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "CMOS Config Register"]
    pub struct CMOS_CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CMOS Config Register"]
    pub mod cmos_cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CMOS_CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLK_DIVR {
            bits: u8,
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLK_ENABLER {
            bits: bool,
        }
        impl CLK_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESETR {
            bits: bool,
        }
        impl RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_DOWNR {
            bits: bool,
        }
        impl POWER_DOWNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_DOWNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_DOWNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - CLK_DIV"]
            #[inline]
            pub fn clk_div(&self) -> CLK_DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLK_DIVR { bits }
            }
            #[doc = "Bit 8 - CLK_ENABLE"]
            #[inline]
            pub fn clk_enable(&self) -> CLK_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLK_ENABLER { bits }
            }
            #[doc = "Bit 16 - RESET"]
            #[inline]
            pub fn reset(&self) -> RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESETR { bits }
            }
            #[doc = "Bit 24 - POWER_DOWN"]
            #[inline]
            pub fn power_down(&self) -> POWER_DOWNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_DOWNR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - CLK_DIV"]
            #[inline]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
            #[doc = "Bit 8 - CLK_ENABLE"]
            #[inline]
            pub fn clk_enable(&mut self) -> _CLK_ENABLEW {
                _CLK_ENABLEW { w: self }
            }
            #[doc = "Bit 16 - RESET"]
            #[inline]
            pub fn reset(&mut self) -> _RESETW {
                _RESETW { w: self }
            }
            #[doc = "Bit 24 - POWER_DOWN"]
            #[inline]
            pub fn power_down(&mut self) -> _POWER_DOWNW {
                _POWER_DOWNW { w: self }
            }
        }
    }
    #[doc = "SCCB Config Register"]
    pub struct SCCB_CFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCCB Config Register"]
    pub mod sccb_cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCCB_CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `byte_num`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BYTE_NUMR {
            #[doc = "BYTE_NUM_2"]
            NUM2,
            #[doc = "BYTE_NUM_3"]
            NUM3,
            #[doc = "BYTE_NUM_4"]
            NUM4,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl BYTE_NUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    BYTE_NUMR::NUM2 => 0x01,
                    BYTE_NUMR::NUM3 => 0x02,
                    BYTE_NUMR::NUM4 => 0x03,
                    BYTE_NUMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> BYTE_NUMR {
                match value {
                    1 => BYTE_NUMR::NUM2,
                    2 => BYTE_NUMR::NUM3,
                    3 => BYTE_NUMR::NUM4,
                    i => BYTE_NUMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NUM2`"]
            #[inline]
            pub fn is_num2(&self) -> bool {
                *self == BYTE_NUMR::NUM2
            }
            #[doc = "Checks if the value of the field is `NUM3`"]
            #[inline]
            pub fn is_num3(&self) -> bool {
                *self == BYTE_NUMR::NUM3
            }
            #[doc = "Checks if the value of the field is `NUM4`"]
            #[inline]
            pub fn is_num4(&self) -> bool {
                *self == BYTE_NUMR::NUM4
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCL_LCNTR {
            bits: u8,
        }
        impl SCL_LCNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCL_HCNTR {
            bits: u8,
        }
        impl SCL_HCNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RDATAR {
            bits: u8,
        }
        impl RDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `byte_num`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BYTE_NUMW {
            #[doc = "BYTE_NUM_2"]
            NUM2,
            #[doc = "BYTE_NUM_3"]
            NUM3,
            #[doc = "BYTE_NUM_4"]
            NUM4,
        }
        impl BYTE_NUMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BYTE_NUMW::NUM2 => 1,
                    BYTE_NUMW::NUM3 => 2,
                    BYTE_NUMW::NUM4 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYTE_NUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYTE_NUMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BYTE_NUMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "BYTE_NUM_2"]
            #[inline]
            pub fn num2(self) -> &'a mut W {
                self.variant(BYTE_NUMW::NUM2)
            }
            #[doc = "BYTE_NUM_3"]
            #[inline]
            pub fn num3(self) -> &'a mut W {
                self.variant(BYTE_NUMW::NUM3)
            }
            #[doc = "BYTE_NUM_4"]
            #[inline]
            pub fn num4(self) -> &'a mut W {
                self.variant(BYTE_NUMW::NUM4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCL_LCNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCL_LCNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCL_HCNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCL_HCNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - BYTE_NUM"]
            #[inline]
            pub fn byte_num(&self) -> BYTE_NUMR {
                BYTE_NUMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:15 - SCL_LCNT"]
            #[inline]
            pub fn scl_lcnt(&self) -> SCL_LCNTR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCL_LCNTR { bits }
            }
            #[doc = "Bits 16:23 - SCL_HCNT"]
            #[inline]
            pub fn scl_hcnt(&self) -> SCL_HCNTR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCL_HCNTR { bits }
            }
            #[doc = "Bits 24:31 - RDATA"]
            #[inline]
            pub fn rdata(&self) -> RDATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RDATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - BYTE_NUM"]
            #[inline]
            pub fn byte_num(&mut self) -> _BYTE_NUMW {
                _BYTE_NUMW { w: self }
            }
            #[doc = "Bits 8:15 - SCL_LCNT"]
            #[inline]
            pub fn scl_lcnt(&mut self) -> _SCL_LCNTW {
                _SCL_LCNTW { w: self }
            }
            #[doc = "Bits 16:23 - SCL_HCNT"]
            #[inline]
            pub fn scl_hcnt(&mut self) -> _SCL_HCNTW {
                _SCL_HCNTW { w: self }
            }
        }
    }
    #[doc = "SCCB Control Register"]
    pub struct SCCB_CTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCCB Control Register"]
    pub mod sccb_ctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCCB_CTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEVICE_ADDRESSR {
            bits: u8,
        }
        impl DEVICE_ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REG_ADDRESSR {
            bits: u8,
        }
        impl REG_ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDATA_BYTE0R {
            bits: u8,
        }
        impl WDATA_BYTE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDATA_BYTE1R {
            bits: u8,
        }
        impl WDATA_BYTE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEVICE_ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEVICE_ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REG_ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REG_ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDATA_BYTE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDATA_BYTE0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDATA_BYTE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDATA_BYTE1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - DEVICE_ADDRESS"]
            #[inline]
            pub fn device_address(&self) -> DEVICE_ADDRESSR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEVICE_ADDRESSR { bits }
            }
            #[doc = "Bits 8:15 - REG_ADDRESS"]
            #[inline]
            pub fn reg_address(&self) -> REG_ADDRESSR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REG_ADDRESSR { bits }
            }
            #[doc = "Bits 16:23 - WDATA_BYTE0"]
            #[inline]
            pub fn wdata_byte0(&self) -> WDATA_BYTE0R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WDATA_BYTE0R { bits }
            }
            #[doc = "Bits 24:31 - WDATA_BYTE1"]
            #[inline]
            pub fn wdata_byte1(&self) -> WDATA_BYTE1R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WDATA_BYTE1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - DEVICE_ADDRESS"]
            #[inline]
            pub fn device_address(&mut self) -> _DEVICE_ADDRESSW {
                _DEVICE_ADDRESSW { w: self }
            }
            #[doc = "Bits 8:15 - REG_ADDRESS"]
            #[inline]
            pub fn reg_address(&mut self) -> _REG_ADDRESSW {
                _REG_ADDRESSW { w: self }
            }
            #[doc = "Bits 16:23 - WDATA_BYTE0"]
            #[inline]
            pub fn wdata_byte0(&mut self) -> _WDATA_BYTE0W {
                _WDATA_BYTE0W { w: self }
            }
            #[doc = "Bits 24:31 - WDATA_BYTE1"]
            #[inline]
            pub fn wdata_byte1(&mut self) -> _WDATA_BYTE1W {
                _WDATA_BYTE1W { w: self }
            }
        }
    }
    #[doc = "AXI Register"]
    pub struct AXI {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AXI Register"]
    pub mod axi {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AXI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `gm_mlen`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GM_MLENR {
            #[doc = "GM_MLEN_1BYTE"]
            BYTE1,
            #[doc = "GM_MLEN_4BYTE"]
            BYTE4,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl GM_MLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    GM_MLENR::BYTE1 => 0,
                    GM_MLENR::BYTE4 => 0x03,
                    GM_MLENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> GM_MLENR {
                match value {
                    0 => GM_MLENR::BYTE1,
                    3 => GM_MLENR::BYTE4,
                    i => GM_MLENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BYTE1`"]
            #[inline]
            pub fn is_byte1(&self) -> bool {
                *self == GM_MLENR::BYTE1
            }
            #[doc = "Checks if the value of the field is `BYTE4`"]
            #[inline]
            pub fn is_byte4(&self) -> bool {
                *self == GM_MLENR::BYTE4
            }
        }
        #[doc = "Values that can be written to the field `gm_mlen`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GM_MLENW {
            #[doc = "GM_MLEN_1BYTE"]
            BYTE1,
            #[doc = "GM_MLEN_4BYTE"]
            BYTE4,
        }
        impl GM_MLENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GM_MLENW::BYTE1 => 0,
                    GM_MLENW::BYTE4 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GM_MLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GM_MLENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GM_MLENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "GM_MLEN_1BYTE"]
            #[inline]
            pub fn byte1(self) -> &'a mut W {
                self.variant(GM_MLENW::BYTE1)
            }
            #[doc = "GM_MLEN_4BYTE"]
            #[inline]
            pub fn byte4(self) -> &'a mut W {
                self.variant(GM_MLENW::BYTE4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - GM_MLEN"]
            #[inline]
            pub fn gm_mlen(&self) -> GM_MLENR {
                GM_MLENR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - GM_MLEN"]
            #[inline]
            pub fn gm_mlen(&mut self) -> _GM_MLENW {
                _GM_MLENW { w: self }
            }
        }
    }
    #[doc = "STS Register"]
    pub struct STS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "STS Register"]
    pub mod sts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_STARTR {
            bits: bool,
        }
        impl FRAME_STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_START_WER {
            bits: bool,
        }
        impl FRAME_START_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_FINISHR {
            bits: bool,
        }
        impl FRAME_FINISHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_FINISH_WER {
            bits: bool,
        }
        impl FRAME_FINISH_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DVP_ENR {
            bits: bool,
        }
        impl DVP_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DVP_EN_WER {
            bits: bool,
        }
        impl DVP_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCCB_ENR {
            bits: bool,
        }
        impl SCCB_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCCB_EN_WER {
            bits: bool,
        }
        impl SCCB_EN_WER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_START_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_START_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_FINISHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_FINISHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_FINISH_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_FINISH_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DVP_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DVP_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DVP_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DVP_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCB_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCB_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCCB_EN_WEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCCB_EN_WEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - FRAME_START"]
            #[inline]
            pub fn frame_start(&self) -> FRAME_STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAME_STARTR { bits }
            }
            #[doc = "Bit 1 - FRAME_START_WE"]
            #[inline]
            pub fn frame_start_we(&self) -> FRAME_START_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAME_START_WER { bits }
            }
            #[doc = "Bit 8 - FRAME_FINISH"]
            #[inline]
            pub fn frame_finish(&self) -> FRAME_FINISHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAME_FINISHR { bits }
            }
            #[doc = "Bit 9 - FRAME_FINISH_WE"]
            #[inline]
            pub fn frame_finish_we(&self) -> FRAME_FINISH_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAME_FINISH_WER { bits }
            }
            #[doc = "Bit 16 - DVP_EN"]
            #[inline]
            pub fn dvp_en(&self) -> DVP_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DVP_ENR { bits }
            }
            #[doc = "Bit 17 - DVP_EN_WE"]
            #[inline]
            pub fn dvp_en_we(&self) -> DVP_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DVP_EN_WER { bits }
            }
            #[doc = "Bit 24 - SCCB_EN"]
            #[inline]
            pub fn sccb_en(&self) -> SCCB_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCCB_ENR { bits }
            }
            #[doc = "Bit 25 - SCCB_EN_WE"]
            #[inline]
            pub fn sccb_en_we(&self) -> SCCB_EN_WER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCCB_EN_WER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - FRAME_START"]
            #[inline]
            pub fn frame_start(&mut self) -> _FRAME_STARTW {
                _FRAME_STARTW { w: self }
            }
            #[doc = "Bit 1 - FRAME_START_WE"]
            #[inline]
            pub fn frame_start_we(&mut self) -> _FRAME_START_WEW {
                _FRAME_START_WEW { w: self }
            }
            #[doc = "Bit 8 - FRAME_FINISH"]
            #[inline]
            pub fn frame_finish(&mut self) -> _FRAME_FINISHW {
                _FRAME_FINISHW { w: self }
            }
            #[doc = "Bit 9 - FRAME_FINISH_WE"]
            #[inline]
            pub fn frame_finish_we(&mut self) -> _FRAME_FINISH_WEW {
                _FRAME_FINISH_WEW { w: self }
            }
            #[doc = "Bit 16 - DVP_EN"]
            #[inline]
            pub fn dvp_en(&mut self) -> _DVP_ENW {
                _DVP_ENW { w: self }
            }
            #[doc = "Bit 17 - DVP_EN_WE"]
            #[inline]
            pub fn dvp_en_we(&mut self) -> _DVP_EN_WEW {
                _DVP_EN_WEW { w: self }
            }
            #[doc = "Bit 24 - SCCB_EN"]
            #[inline]
            pub fn sccb_en(&mut self) -> _SCCB_ENW {
                _SCCB_ENW { w: self }
            }
            #[doc = "Bit 25 - SCCB_EN_WE"]
            #[inline]
            pub fn sccb_en_we(&mut self) -> _SCCB_EN_WEW {
                _SCCB_EN_WEW { w: self }
            }
        }
    }
    #[doc = "REVERSE"]
    pub struct REVERSE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "REVERSE"]
    pub mod reverse {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::REVERSE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RGB_ADDR"]
    pub struct RGB_ADDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RGB_ADDR"]
    pub mod rgb_addr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RGB_ADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "System Controller"]
pub struct SYSCTL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCTL {}
impl SYSCTL {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const sysctl::RegisterBlock {
        0x5044_0000 as *const _
    }
}
impl Deref for SYSCTL {
    type Target = sysctl::RegisterBlock;
    fn deref(&self) -> &sysctl::RegisterBlock {
        unsafe { &*SYSCTL::ptr() }
    }
}
#[doc = "System Controller"]
pub mod sysctl {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Git short commit id"]
        pub git_id: GIT_ID,
        #[doc = "0x04 - System clock base frequency"]
        pub clk_freq: CLK_FREQ,
        #[doc = "0x08 - PLL0 controller"]
        pub pll0: PLL0,
        #[doc = "0x0c - PLL1 controller"]
        pub pll1: PLL1,
        #[doc = "0x10 - PLL2 controller"]
        pub pll2: PLL2,
        _reserved0: [u8; 4usize],
        #[doc = "0x18 - PLL lock tester"]
        pub pll_lock: PLL_LOCK,
        #[doc = "0x1c - AXI ROM detector"]
        pub rom_error: ROM_ERROR,
        #[doc = "0x20 - Clock select controller 0"]
        pub clk_sel0: CLK_SEL0,
        #[doc = "0x24 - Clock select controller 1"]
        pub clk_sel1: CLK_SEL1,
        #[doc = "0x28 - Central clock enable"]
        pub clk_en_cent: CLK_EN_CENT,
        #[doc = "0x2c - Peripheral clock enable"]
        pub clk_en_peri: CLK_EN_PERI,
        #[doc = "0x30 - Soft reset ctrl"]
        pub soft_reset: SOFT_RESET,
        #[doc = "0x34 - Peripheral reset controller"]
        pub peri_reset: PERI_RESET,
        #[doc = "0x38 - Clock threshold controller 0"]
        pub clk_th0: CLK_TH0,
        #[doc = "0x3c - Clock threshold controller 1"]
        pub clk_th1: CLK_TH1,
        #[doc = "0x40 - Clock threshold controller 2"]
        pub clk_th2: CLK_TH2,
        #[doc = "0x44 - Clock threshold controller 3"]
        pub clk_th3: CLK_TH3,
        #[doc = "0x48 - Clock threshold controller 4"]
        pub clk_th4: CLK_TH4,
        #[doc = "0x4c - Clock threshold controller 5"]
        pub clk_th5: CLK_TH5,
        #[doc = "0x50 - Clock threshold controller 6"]
        pub clk_th6: CLK_TH6,
        #[doc = "0x54 - Miscellaneous controller"]
        pub misc: MISC,
        #[doc = "0x58 - Peripheral controller"]
        pub peri: PERI,
        #[doc = "0x5c - SPI sleep controller"]
        pub spi_sleep: SPI_SLEEP,
        #[doc = "0x60 - Reset source status"]
        pub reset_status: RESET_STATUS,
        #[doc = "0x64 - DMA handshake selector"]
        pub dma_sel0: DMA_SEL0,
        #[doc = "0x68 - DMA handshake selector"]
        pub dma_sel1: DMA_SEL1,
        #[doc = "0x6c - IO Power Mode Select controller"]
        pub power_sel: POWER_SEL,
    }
    #[doc = "Git short commit id"]
    pub struct GIT_ID {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Git short commit id"]
    pub mod git_id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GIT_ID {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "System clock base frequency"]
    pub struct CLK_FREQ {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System clock base frequency"]
    pub mod clk_freq {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_FREQ {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "PLL0 controller"]
    pub struct PLL0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "PLL0 controller"]
    pub mod pll0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PLL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKRR {
            bits: u8,
        }
        impl CLKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKFR {
            bits: u8,
        }
        impl CLKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKODR {
            bits: u8,
        }
        impl CLKODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BWADJR {
            bits: u8,
        }
        impl BWADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESETR {
            bits: bool,
        }
        impl RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PWRDR {
            bits: bool,
        }
        impl PWRDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTFBR {
            bits: bool,
        }
        impl INTFBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BYPASSR {
            bits: bool,
        }
        impl BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TESTR {
            bits: bool,
        }
        impl TESTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUT_ENR {
            bits: bool,
        }
        impl OUT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TEST_ENR {
            bits: bool,
        }
        impl TEST_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKODW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BWADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BWADJW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWRDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWRDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTFBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTFBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TESTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TESTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEST_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEST_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn clkr(&self) -> CLKRR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKRR { bits }
            }
            #[doc = "Bits 4:9"]
            #[inline]
            pub fn clkf(&self) -> CLKFR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKFR { bits }
            }
            #[doc = "Bits 10:13"]
            #[inline]
            pub fn clkod(&self) -> CLKODR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKODR { bits }
            }
            #[doc = "Bits 14:19"]
            #[inline]
            pub fn bwadj(&self) -> BWADJR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BWADJR { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn reset(&self) -> RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESETR { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pwrd(&self) -> PWRDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PWRDR { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn intfb(&self) -> INTFBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INTFBR { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn bypass(&self) -> BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BYPASSR { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn test(&self) -> TESTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TESTR { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn out_en(&self) -> OUT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OUT_ENR { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn test_en(&self) -> TEST_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TEST_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn clkr(&mut self) -> _CLKRW {
                _CLKRW { w: self }
            }
            #[doc = "Bits 4:9"]
            #[inline]
            pub fn clkf(&mut self) -> _CLKFW {
                _CLKFW { w: self }
            }
            #[doc = "Bits 10:13"]
            #[inline]
            pub fn clkod(&mut self) -> _CLKODW {
                _CLKODW { w: self }
            }
            #[doc = "Bits 14:19"]
            #[inline]
            pub fn bwadj(&mut self) -> _BWADJW {
                _BWADJW { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn reset(&mut self) -> _RESETW {
                _RESETW { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pwrd(&mut self) -> _PWRDW {
                _PWRDW { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn intfb(&mut self) -> _INTFBW {
                _INTFBW { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn bypass(&mut self) -> _BYPASSW {
                _BYPASSW { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn test(&mut self) -> _TESTW {
                _TESTW { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn out_en(&mut self) -> _OUT_ENW {
                _OUT_ENW { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn test_en(&mut self) -> _TEST_ENW {
                _TEST_ENW { w: self }
            }
        }
    }
    #[doc = "PLL1 controller"]
    pub struct PLL1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "PLL1 controller"]
    pub mod pll1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PLL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKRR {
            bits: u8,
        }
        impl CLKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKFR {
            bits: u8,
        }
        impl CLKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKODR {
            bits: u8,
        }
        impl CLKODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BWADJR {
            bits: u8,
        }
        impl BWADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESETR {
            bits: bool,
        }
        impl RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PWRDR {
            bits: bool,
        }
        impl PWRDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTFBR {
            bits: bool,
        }
        impl INTFBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BYPASSR {
            bits: bool,
        }
        impl BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TESTR {
            bits: bool,
        }
        impl TESTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUT_ENR {
            bits: bool,
        }
        impl OUT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKODW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BWADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BWADJW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWRDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWRDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTFBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTFBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TESTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TESTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn clkr(&self) -> CLKRR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKRR { bits }
            }
            #[doc = "Bits 4:9"]
            #[inline]
            pub fn clkf(&self) -> CLKFR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKFR { bits }
            }
            #[doc = "Bits 10:13"]
            #[inline]
            pub fn clkod(&self) -> CLKODR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKODR { bits }
            }
            #[doc = "Bits 14:19"]
            #[inline]
            pub fn bwadj(&self) -> BWADJR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BWADJR { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn reset(&self) -> RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESETR { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pwrd(&self) -> PWRDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PWRDR { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn intfb(&self) -> INTFBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INTFBR { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn bypass(&self) -> BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BYPASSR { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn test(&self) -> TESTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TESTR { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn out_en(&self) -> OUT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OUT_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn clkr(&mut self) -> _CLKRW {
                _CLKRW { w: self }
            }
            #[doc = "Bits 4:9"]
            #[inline]
            pub fn clkf(&mut self) -> _CLKFW {
                _CLKFW { w: self }
            }
            #[doc = "Bits 10:13"]
            #[inline]
            pub fn clkod(&mut self) -> _CLKODW {
                _CLKODW { w: self }
            }
            #[doc = "Bits 14:19"]
            #[inline]
            pub fn bwadj(&mut self) -> _BWADJW {
                _BWADJW { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn reset(&mut self) -> _RESETW {
                _RESETW { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pwrd(&mut self) -> _PWRDW {
                _PWRDW { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn intfb(&mut self) -> _INTFBW {
                _INTFBW { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn bypass(&mut self) -> _BYPASSW {
                _BYPASSW { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn test(&mut self) -> _TESTW {
                _TESTW { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn out_en(&mut self) -> _OUT_ENW {
                _OUT_ENW { w: self }
            }
        }
    }
    #[doc = "PLL2 controller"]
    pub struct PLL2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "PLL2 controller"]
    pub mod pll2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PLL2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKRR {
            bits: u8,
        }
        impl CLKRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKFR {
            bits: u8,
        }
        impl CLKFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKODR {
            bits: u8,
        }
        impl CLKODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BWADJR {
            bits: u8,
        }
        impl BWADJR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESETR {
            bits: bool,
        }
        impl RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PWRDR {
            bits: bool,
        }
        impl PWRDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTFBR {
            bits: bool,
        }
        impl INTFBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BYPASSR {
            bits: bool,
        }
        impl BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TESTR {
            bits: bool,
        }
        impl TESTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUT_ENR {
            bits: bool,
        }
        impl OUT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CKIN_SELR {
            bits: u8,
        }
        impl CKIN_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKODW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BWADJW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BWADJW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWRDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWRDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTFBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTFBW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TESTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TESTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CKIN_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CKIN_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn clkr(&self) -> CLKRR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKRR { bits }
            }
            #[doc = "Bits 4:9"]
            #[inline]
            pub fn clkf(&self) -> CLKFR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKFR { bits }
            }
            #[doc = "Bits 10:13"]
            #[inline]
            pub fn clkod(&self) -> CLKODR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKODR { bits }
            }
            #[doc = "Bits 14:19"]
            #[inline]
            pub fn bwadj(&self) -> BWADJR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BWADJR { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn reset(&self) -> RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESETR { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pwrd(&self) -> PWRDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PWRDR { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn intfb(&self) -> INTFBR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INTFBR { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn bypass(&self) -> BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BYPASSR { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn test(&self) -> TESTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TESTR { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn out_en(&self) -> OUT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OUT_ENR { bits }
            }
            #[doc = "Bits 26:27"]
            #[inline]
            pub fn ckin_sel(&self) -> CKIN_SELR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CKIN_SELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn clkr(&mut self) -> _CLKRW {
                _CLKRW { w: self }
            }
            #[doc = "Bits 4:9"]
            #[inline]
            pub fn clkf(&mut self) -> _CLKFW {
                _CLKFW { w: self }
            }
            #[doc = "Bits 10:13"]
            #[inline]
            pub fn clkod(&mut self) -> _CLKODW {
                _CLKODW { w: self }
            }
            #[doc = "Bits 14:19"]
            #[inline]
            pub fn bwadj(&mut self) -> _BWADJW {
                _BWADJW { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn reset(&mut self) -> _RESETW {
                _RESETW { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn pwrd(&mut self) -> _PWRDW {
                _PWRDW { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn intfb(&mut self) -> _INTFBW {
                _INTFBW { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn bypass(&mut self) -> _BYPASSW {
                _BYPASSW { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn test(&mut self) -> _TESTW {
                _TESTW { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn out_en(&mut self) -> _OUT_ENW {
                _OUT_ENW { w: self }
            }
            #[doc = "Bits 26:27"]
            #[inline]
            pub fn ckin_sel(&mut self) -> _CKIN_SELW {
                _CKIN_SELW { w: self }
            }
        }
    }
    #[doc = "PLL lock tester"]
    pub struct PLL_LOCK {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "PLL lock tester"]
    pub mod pll_lock {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PLL_LOCK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLL_LOCK0R {
            bits: u8,
        }
        impl PLL_LOCK0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLL_SLIP_CLEAR0R {
            bits: bool,
        }
        impl PLL_SLIP_CLEAR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TEST_CLK_OUT0R {
            bits: bool,
        }
        impl TEST_CLK_OUT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLL_LOCK1R {
            bits: u8,
        }
        impl PLL_LOCK1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLL_SLIP_CLEAR1R {
            bits: bool,
        }
        impl PLL_SLIP_CLEAR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TEST_CLK_OUT1R {
            bits: bool,
        }
        impl TEST_CLK_OUT1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLL_LOCK2R {
            bits: u8,
        }
        impl PLL_LOCK2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PLL_SLIP_CLEAR2R {
            bits: bool,
        }
        impl PLL_SLIP_CLEAR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TEST_CLK_OUT2R {
            bits: bool,
        }
        impl TEST_CLK_OUT2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLL_LOCK0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLL_LOCK0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLL_SLIP_CLEAR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLL_SLIP_CLEAR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEST_CLK_OUT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEST_CLK_OUT0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLL_LOCK1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLL_LOCK1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLL_SLIP_CLEAR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLL_SLIP_CLEAR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEST_CLK_OUT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEST_CLK_OUT1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLL_LOCK2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLL_LOCK2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLL_SLIP_CLEAR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLL_SLIP_CLEAR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TEST_CLK_OUT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TEST_CLK_OUT2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1"]
            #[inline]
            pub fn pll_lock0(&self) -> PLL_LOCK0R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PLL_LOCK0R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pll_slip_clear0(&self) -> PLL_SLIP_CLEAR0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PLL_SLIP_CLEAR0R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn test_clk_out0(&self) -> TEST_CLK_OUT0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TEST_CLK_OUT0R { bits }
            }
            #[doc = "Bits 8:9"]
            #[inline]
            pub fn pll_lock1(&self) -> PLL_LOCK1R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PLL_LOCK1R { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pll_slip_clear1(&self) -> PLL_SLIP_CLEAR1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PLL_SLIP_CLEAR1R { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn test_clk_out1(&self) -> TEST_CLK_OUT1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TEST_CLK_OUT1R { bits }
            }
            #[doc = "Bits 16:17"]
            #[inline]
            pub fn pll_lock2(&self) -> PLL_LOCK2R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PLL_LOCK2R { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pll_slip_clear2(&self) -> PLL_SLIP_CLEAR2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PLL_SLIP_CLEAR2R { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn test_clk_out2(&self) -> TEST_CLK_OUT2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TEST_CLK_OUT2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1"]
            #[inline]
            pub fn pll_lock0(&mut self) -> _PLL_LOCK0W {
                _PLL_LOCK0W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn pll_slip_clear0(&mut self) -> _PLL_SLIP_CLEAR0W {
                _PLL_SLIP_CLEAR0W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn test_clk_out0(&mut self) -> _TEST_CLK_OUT0W {
                _TEST_CLK_OUT0W { w: self }
            }
            #[doc = "Bits 8:9"]
            #[inline]
            pub fn pll_lock1(&mut self) -> _PLL_LOCK1W {
                _PLL_LOCK1W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn pll_slip_clear1(&mut self) -> _PLL_SLIP_CLEAR1W {
                _PLL_SLIP_CLEAR1W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn test_clk_out1(&mut self) -> _TEST_CLK_OUT1W {
                _TEST_CLK_OUT1W { w: self }
            }
            #[doc = "Bits 16:17"]
            #[inline]
            pub fn pll_lock2(&mut self) -> _PLL_LOCK2W {
                _PLL_LOCK2W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn pll_slip_clear2(&mut self) -> _PLL_SLIP_CLEAR2W {
                _PLL_SLIP_CLEAR2W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn test_clk_out2(&mut self) -> _TEST_CLK_OUT2W {
                _TEST_CLK_OUT2W { w: self }
            }
        }
    }
    #[doc = "AXI ROM detector"]
    pub struct ROM_ERROR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AXI ROM detector"]
    pub mod rom_error {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ROM_ERROR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ROM_MUL_ERRORR {
            bits: bool,
        }
        impl ROM_MUL_ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ROM_ONE_ERRORR {
            bits: bool,
        }
        impl ROM_ONE_ERRORR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROM_MUL_ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROM_MUL_ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROM_ONE_ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROM_ONE_ERRORW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn rom_mul_error(&self) -> ROM_MUL_ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ROM_MUL_ERRORR { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn rom_one_error(&self) -> ROM_ONE_ERRORR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ROM_ONE_ERRORR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn rom_mul_error(&mut self) -> _ROM_MUL_ERRORW {
                _ROM_MUL_ERRORW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn rom_one_error(&mut self) -> _ROM_ONE_ERRORW {
                _ROM_ONE_ERRORW { w: self }
            }
        }
    }
    #[doc = "Clock select controller 0"]
    pub struct CLK_SEL0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock select controller 0"]
    pub mod clk_sel0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_SEL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACLK_SELR {
            bits: bool,
        }
        impl ACLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACLK_DIVIDER_SELR {
            bits: u8,
        }
        impl ACLK_DIVIDER_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB0_CLK_SELR {
            bits: u8,
        }
        impl APB0_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB1_CLK_SELR {
            bits: u8,
        }
        impl APB1_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB2_CLK_SELR {
            bits: u8,
        }
        impl APB2_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI3_CLK_SELR {
            bits: bool,
        }
        impl SPI3_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER0_CLK_SELR {
            bits: bool,
        }
        impl TIMER0_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER1_CLK_SELR {
            bits: bool,
        }
        impl TIMER1_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER2_CLK_SELR {
            bits: bool,
        }
        impl TIMER2_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACLK_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACLK_DIVIDER_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACLK_DIVIDER_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB0_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB0_CLK_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB1_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB1_CLK_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB2_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB2_CLK_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI3_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3_CLK_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER0_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER0_CLK_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER1_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER1_CLK_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER2_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER2_CLK_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn aclk_sel(&self) -> ACLK_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ACLK_SELR { bits }
            }
            #[doc = "Bits 1:2"]
            #[inline]
            pub fn aclk_divider_sel(&self) -> ACLK_DIVIDER_SELR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACLK_DIVIDER_SELR { bits }
            }
            #[doc = "Bits 3:5"]
            #[inline]
            pub fn apb0_clk_sel(&self) -> APB0_CLK_SELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                APB0_CLK_SELR { bits }
            }
            #[doc = "Bits 6:8"]
            #[inline]
            pub fn apb1_clk_sel(&self) -> APB1_CLK_SELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                APB1_CLK_SELR { bits }
            }
            #[doc = "Bits 9:11"]
            #[inline]
            pub fn apb2_clk_sel(&self) -> APB2_CLK_SELR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                APB2_CLK_SELR { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn spi3_clk_sel(&self) -> SPI3_CLK_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI3_CLK_SELR { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn timer0_clk_sel(&self) -> TIMER0_CLK_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER0_CLK_SELR { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn timer1_clk_sel(&self) -> TIMER1_CLK_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER1_CLK_SELR { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn timer2_clk_sel(&self) -> TIMER2_CLK_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER2_CLK_SELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn aclk_sel(&mut self) -> _ACLK_SELW {
                _ACLK_SELW { w: self }
            }
            #[doc = "Bits 1:2"]
            #[inline]
            pub fn aclk_divider_sel(&mut self) -> _ACLK_DIVIDER_SELW {
                _ACLK_DIVIDER_SELW { w: self }
            }
            #[doc = "Bits 3:5"]
            #[inline]
            pub fn apb0_clk_sel(&mut self) -> _APB0_CLK_SELW {
                _APB0_CLK_SELW { w: self }
            }
            #[doc = "Bits 6:8"]
            #[inline]
            pub fn apb1_clk_sel(&mut self) -> _APB1_CLK_SELW {
                _APB1_CLK_SELW { w: self }
            }
            #[doc = "Bits 9:11"]
            #[inline]
            pub fn apb2_clk_sel(&mut self) -> _APB2_CLK_SELW {
                _APB2_CLK_SELW { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn spi3_clk_sel(&mut self) -> _SPI3_CLK_SELW {
                _SPI3_CLK_SELW { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn timer0_clk_sel(&mut self) -> _TIMER0_CLK_SELW {
                _TIMER0_CLK_SELW { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn timer1_clk_sel(&mut self) -> _TIMER1_CLK_SELW {
                _TIMER1_CLK_SELW { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn timer2_clk_sel(&mut self) -> _TIMER2_CLK_SELW {
                _TIMER2_CLK_SELW { w: self }
            }
        }
    }
    #[doc = "Clock select controller 1"]
    pub struct CLK_SEL1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock select controller 1"]
    pub mod clk_sel1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_SEL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI3_SAMPLE_CLK_SELR {
            bits: bool,
        }
        impl SPI3_SAMPLE_CLK_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI3_SAMPLE_CLK_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3_SAMPLE_CLK_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn spi3_sample_clk_sel(&self) -> SPI3_SAMPLE_CLK_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI3_SAMPLE_CLK_SELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn spi3_sample_clk_sel(&mut self) -> _SPI3_SAMPLE_CLK_SELW {
                _SPI3_SAMPLE_CLK_SELW { w: self }
            }
        }
    }
    #[doc = "Central clock enable"]
    pub struct CLK_EN_CENT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Central clock enable"]
    pub mod clk_en_cent {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_EN_CENT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPU_CLK_ENR {
            bits: bool,
        }
        impl CPU_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRAM0_CLK_ENR {
            bits: bool,
        }
        impl SRAM0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRAM1_CLK_ENR {
            bits: bool,
        }
        impl SRAM1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB0_CLK_ENR {
            bits: bool,
        }
        impl APB0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB1_CLK_ENR {
            bits: bool,
        }
        impl APB1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APB2_CLK_ENR {
            bits: bool,
        }
        impl APB2_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPU_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPU_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRAM0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRAM0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRAM1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRAM1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APB2_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _APB2_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn cpu_clk_en(&self) -> CPU_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CPU_CLK_ENR { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn sram0_clk_en(&self) -> SRAM0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRAM0_CLK_ENR { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn sram1_clk_en(&self) -> SRAM1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRAM1_CLK_ENR { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn apb0_clk_en(&self) -> APB0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APB0_CLK_ENR { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn apb1_clk_en(&self) -> APB1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APB1_CLK_ENR { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn apb2_clk_en(&self) -> APB2_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APB2_CLK_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn cpu_clk_en(&mut self) -> _CPU_CLK_ENW {
                _CPU_CLK_ENW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn sram0_clk_en(&mut self) -> _SRAM0_CLK_ENW {
                _SRAM0_CLK_ENW { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn sram1_clk_en(&mut self) -> _SRAM1_CLK_ENW {
                _SRAM1_CLK_ENW { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn apb0_clk_en(&mut self) -> _APB0_CLK_ENW {
                _APB0_CLK_ENW { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn apb1_clk_en(&mut self) -> _APB1_CLK_ENW {
                _APB1_CLK_ENW { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn apb2_clk_en(&mut self) -> _APB2_CLK_ENW {
                _APB2_CLK_ENW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock enable"]
    pub struct CLK_EN_PERI {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral clock enable"]
    pub mod clk_en_peri {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_EN_PERI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ROM_CLK_ENR {
            bits: bool,
        }
        impl ROM_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_CLK_ENR {
            bits: bool,
        }
        impl DMA_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AI_CLK_ENR {
            bits: bool,
        }
        impl AI_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DVP_CLK_ENR {
            bits: bool,
        }
        impl DVP_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_CLK_ENR {
            bits: bool,
        }
        impl FFT_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPIO_CLK_ENR {
            bits: bool,
        }
        impl GPIO_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_CLK_ENR {
            bits: bool,
        }
        impl SPI0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_CLK_ENR {
            bits: bool,
        }
        impl SPI1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI2_CLK_ENR {
            bits: bool,
        }
        impl SPI2_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI3_CLK_ENR {
            bits: bool,
        }
        impl SPI3_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S0_CLK_ENR {
            bits: bool,
        }
        impl I2S0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S1_CLK_ENR {
            bits: bool,
        }
        impl I2S1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S2_CLK_ENR {
            bits: bool,
        }
        impl I2S2_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C0_CLK_ENR {
            bits: bool,
        }
        impl I2C0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C1_CLK_ENR {
            bits: bool,
        }
        impl I2C1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C2_CLK_ENR {
            bits: bool,
        }
        impl I2C2_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UART1_CLK_ENR {
            bits: bool,
        }
        impl UART1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UART2_CLK_ENR {
            bits: bool,
        }
        impl UART2_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UART3_CLK_ENR {
            bits: bool,
        }
        impl UART3_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AES_CLK_ENR {
            bits: bool,
        }
        impl AES_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FPIOA_CLK_ENR {
            bits: bool,
        }
        impl FPIOA_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER0_CLK_ENR {
            bits: bool,
        }
        impl TIMER0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER1_CLK_ENR {
            bits: bool,
        }
        impl TIMER1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER2_CLK_ENR {
            bits: bool,
        }
        impl TIMER2_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT0_CLK_ENR {
            bits: bool,
        }
        impl WDT0_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT1_CLK_ENR {
            bits: bool,
        }
        impl WDT1_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SHA_CLK_ENR {
            bits: bool,
        }
        impl SHA_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OTP_CLK_ENR {
            bits: bool,
        }
        impl OTP_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTC_CLK_ENR {
            bits: bool,
        }
        impl RTC_CLK_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROM_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROM_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AI_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AI_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DVP_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DVP_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIO_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIO_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI2_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI3_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S2_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S2_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART2_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART2_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART3_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART3_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AES_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AES_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FPIOA_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FPIOA_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER2_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER2_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT0_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT0_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT1_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT1_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SHA_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SHA_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OTP_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OTP_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTC_CLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTC_CLK_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn rom_clk_en(&self) -> ROM_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ROM_CLK_ENR { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn dma_clk_en(&self) -> DMA_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_CLK_ENR { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn ai_clk_en(&self) -> AI_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AI_CLK_ENR { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn dvp_clk_en(&self) -> DVP_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DVP_CLK_ENR { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn fft_clk_en(&self) -> FFT_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FFT_CLK_ENR { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn gpio_clk_en(&self) -> GPIO_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GPIO_CLK_ENR { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn spi0_clk_en(&self) -> SPI0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI0_CLK_ENR { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn spi1_clk_en(&self) -> SPI1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI1_CLK_ENR { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn spi2_clk_en(&self) -> SPI2_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI2_CLK_ENR { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn spi3_clk_en(&self) -> SPI3_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI3_CLK_ENR { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn i2s0_clk_en(&self) -> I2S0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S0_CLK_ENR { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn i2s1_clk_en(&self) -> I2S1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S1_CLK_ENR { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn i2s2_clk_en(&self) -> I2S2_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S2_CLK_ENR { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn i2c0_clk_en(&self) -> I2C0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C0_CLK_ENR { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn i2c1_clk_en(&self) -> I2C1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C1_CLK_ENR { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn i2c2_clk_en(&self) -> I2C2_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C2_CLK_ENR { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn uart1_clk_en(&self) -> UART1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UART1_CLK_ENR { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn uart2_clk_en(&self) -> UART2_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UART2_CLK_ENR { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn uart3_clk_en(&self) -> UART3_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UART3_CLK_ENR { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn aes_clk_en(&self) -> AES_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AES_CLK_ENR { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn fpioa_clk_en(&self) -> FPIOA_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FPIOA_CLK_ENR { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn timer0_clk_en(&self) -> TIMER0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER0_CLK_ENR { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn timer1_clk_en(&self) -> TIMER1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER1_CLK_ENR { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn timer2_clk_en(&self) -> TIMER2_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER2_CLK_ENR { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn wdt0_clk_en(&self) -> WDT0_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDT0_CLK_ENR { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn wdt1_clk_en(&self) -> WDT1_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDT1_CLK_ENR { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn sha_clk_en(&self) -> SHA_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SHA_CLK_ENR { bits }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn otp_clk_en(&self) -> OTP_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OTP_CLK_ENR { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn rtc_clk_en(&self) -> RTC_CLK_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTC_CLK_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn rom_clk_en(&mut self) -> _ROM_CLK_ENW {
                _ROM_CLK_ENW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn dma_clk_en(&mut self) -> _DMA_CLK_ENW {
                _DMA_CLK_ENW { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn ai_clk_en(&mut self) -> _AI_CLK_ENW {
                _AI_CLK_ENW { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn dvp_clk_en(&mut self) -> _DVP_CLK_ENW {
                _DVP_CLK_ENW { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn fft_clk_en(&mut self) -> _FFT_CLK_ENW {
                _FFT_CLK_ENW { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn gpio_clk_en(&mut self) -> _GPIO_CLK_ENW {
                _GPIO_CLK_ENW { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn spi0_clk_en(&mut self) -> _SPI0_CLK_ENW {
                _SPI0_CLK_ENW { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn spi1_clk_en(&mut self) -> _SPI1_CLK_ENW {
                _SPI1_CLK_ENW { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn spi2_clk_en(&mut self) -> _SPI2_CLK_ENW {
                _SPI2_CLK_ENW { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn spi3_clk_en(&mut self) -> _SPI3_CLK_ENW {
                _SPI3_CLK_ENW { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn i2s0_clk_en(&mut self) -> _I2S0_CLK_ENW {
                _I2S0_CLK_ENW { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn i2s1_clk_en(&mut self) -> _I2S1_CLK_ENW {
                _I2S1_CLK_ENW { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn i2s2_clk_en(&mut self) -> _I2S2_CLK_ENW {
                _I2S2_CLK_ENW { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn i2c0_clk_en(&mut self) -> _I2C0_CLK_ENW {
                _I2C0_CLK_ENW { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn i2c1_clk_en(&mut self) -> _I2C1_CLK_ENW {
                _I2C1_CLK_ENW { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn i2c2_clk_en(&mut self) -> _I2C2_CLK_ENW {
                _I2C2_CLK_ENW { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn uart1_clk_en(&mut self) -> _UART1_CLK_ENW {
                _UART1_CLK_ENW { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn uart2_clk_en(&mut self) -> _UART2_CLK_ENW {
                _UART2_CLK_ENW { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn uart3_clk_en(&mut self) -> _UART3_CLK_ENW {
                _UART3_CLK_ENW { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn aes_clk_en(&mut self) -> _AES_CLK_ENW {
                _AES_CLK_ENW { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn fpioa_clk_en(&mut self) -> _FPIOA_CLK_ENW {
                _FPIOA_CLK_ENW { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn timer0_clk_en(&mut self) -> _TIMER0_CLK_ENW {
                _TIMER0_CLK_ENW { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn timer1_clk_en(&mut self) -> _TIMER1_CLK_ENW {
                _TIMER1_CLK_ENW { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn timer2_clk_en(&mut self) -> _TIMER2_CLK_ENW {
                _TIMER2_CLK_ENW { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn wdt0_clk_en(&mut self) -> _WDT0_CLK_ENW {
                _WDT0_CLK_ENW { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn wdt1_clk_en(&mut self) -> _WDT1_CLK_ENW {
                _WDT1_CLK_ENW { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn sha_clk_en(&mut self) -> _SHA_CLK_ENW {
                _SHA_CLK_ENW { w: self }
            }
            #[doc = "Bit 27"]
            #[inline]
            pub fn otp_clk_en(&mut self) -> _OTP_CLK_ENW {
                _OTP_CLK_ENW { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn rtc_clk_en(&mut self) -> _RTC_CLK_ENW {
                _RTC_CLK_ENW { w: self }
            }
        }
    }
    #[doc = "Soft reset ctrl"]
    pub struct SOFT_RESET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Soft reset ctrl"]
    pub mod soft_reset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SOFT_RESET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SOFT_RESETR {
            bits: bool,
        }
        impl SOFT_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SOFT_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SOFT_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn soft_reset(&self) -> SOFT_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SOFT_RESETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn soft_reset(&mut self) -> _SOFT_RESETW {
                _SOFT_RESETW { w: self }
            }
        }
    }
    #[doc = "Peripheral reset controller"]
    pub struct PERI_RESET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral reset controller"]
    pub mod peri_reset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PERI_RESET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ROM_RESETR {
            bits: bool,
        }
        impl ROM_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_RESETR {
            bits: bool,
        }
        impl DMA_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AI_RESETR {
            bits: bool,
        }
        impl AI_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DVP_RESETR {
            bits: bool,
        }
        impl DVP_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FFT_RESETR {
            bits: bool,
        }
        impl FFT_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPIO_RESETR {
            bits: bool,
        }
        impl GPIO_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_RESETR {
            bits: bool,
        }
        impl SPI0_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_RESETR {
            bits: bool,
        }
        impl SPI1_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI2_RESETR {
            bits: bool,
        }
        impl SPI2_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI3_RESETR {
            bits: bool,
        }
        impl SPI3_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S0_RESETR {
            bits: bool,
        }
        impl I2S0_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S1_RESETR {
            bits: bool,
        }
        impl I2S1_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S2_RESETR {
            bits: bool,
        }
        impl I2S2_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C0_RESETR {
            bits: bool,
        }
        impl I2C0_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C1_RESETR {
            bits: bool,
        }
        impl I2C1_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C2_RESETR {
            bits: bool,
        }
        impl I2C2_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UART1_RESETR {
            bits: bool,
        }
        impl UART1_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UART2_RESETR {
            bits: bool,
        }
        impl UART2_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct UART3_RESETR {
            bits: bool,
        }
        impl UART3_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AES_RESETR {
            bits: bool,
        }
        impl AES_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FPIOA_RESETR {
            bits: bool,
        }
        impl FPIOA_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER0_RESETR {
            bits: bool,
        }
        impl TIMER0_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER1_RESETR {
            bits: bool,
        }
        impl TIMER1_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER2_RESETR {
            bits: bool,
        }
        impl TIMER2_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT0_RESETR {
            bits: bool,
        }
        impl WDT0_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT1_RESETR {
            bits: bool,
        }
        impl WDT1_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SHA_RESETR {
            bits: bool,
        }
        impl SHA_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTC_RESETR {
            bits: bool,
        }
        impl RTC_RESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROM_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROM_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AI_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AI_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DVP_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DVP_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FFT_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FFT_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIO_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIO_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI2_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI3_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S0_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S0_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S1_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S1_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S2_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S2_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART1_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART1_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART2_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART2_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART3_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART3_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AES_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AES_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FPIOA_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FPIOA_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER0_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER0_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER1_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER1_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER2_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER2_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT0_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT0_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT1_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT1_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SHA_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SHA_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTC_RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTC_RESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn rom_reset(&self) -> ROM_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ROM_RESETR { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn dma_reset(&self) -> DMA_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_RESETR { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn ai_reset(&self) -> AI_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AI_RESETR { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn dvp_reset(&self) -> DVP_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DVP_RESETR { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn fft_reset(&self) -> FFT_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FFT_RESETR { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn gpio_reset(&self) -> GPIO_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GPIO_RESETR { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn spi0_reset(&self) -> SPI0_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI0_RESETR { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn spi1_reset(&self) -> SPI1_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI1_RESETR { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn spi2_reset(&self) -> SPI2_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI2_RESETR { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn spi3_reset(&self) -> SPI3_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI3_RESETR { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn i2s0_reset(&self) -> I2S0_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S0_RESETR { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn i2s1_reset(&self) -> I2S1_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S1_RESETR { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn i2s2_reset(&self) -> I2S2_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S2_RESETR { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn i2c0_reset(&self) -> I2C0_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C0_RESETR { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn i2c1_reset(&self) -> I2C1_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C1_RESETR { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn i2c2_reset(&self) -> I2C2_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2C2_RESETR { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn uart1_reset(&self) -> UART1_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UART1_RESETR { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn uart2_reset(&self) -> UART2_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UART2_RESETR { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn uart3_reset(&self) -> UART3_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                UART3_RESETR { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn aes_reset(&self) -> AES_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AES_RESETR { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn fpioa_reset(&self) -> FPIOA_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FPIOA_RESETR { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn timer0_reset(&self) -> TIMER0_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER0_RESETR { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn timer1_reset(&self) -> TIMER1_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER1_RESETR { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn timer2_reset(&self) -> TIMER2_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER2_RESETR { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn wdt0_reset(&self) -> WDT0_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDT0_RESETR { bits }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn wdt1_reset(&self) -> WDT1_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDT1_RESETR { bits }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn sha_reset(&self) -> SHA_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SHA_RESETR { bits }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn rtc_reset(&self) -> RTC_RESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTC_RESETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn rom_reset(&mut self) -> _ROM_RESETW {
                _ROM_RESETW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn dma_reset(&mut self) -> _DMA_RESETW {
                _DMA_RESETW { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn ai_reset(&mut self) -> _AI_RESETW {
                _AI_RESETW { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn dvp_reset(&mut self) -> _DVP_RESETW {
                _DVP_RESETW { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn fft_reset(&mut self) -> _FFT_RESETW {
                _FFT_RESETW { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn gpio_reset(&mut self) -> _GPIO_RESETW {
                _GPIO_RESETW { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn spi0_reset(&mut self) -> _SPI0_RESETW {
                _SPI0_RESETW { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn spi1_reset(&mut self) -> _SPI1_RESETW {
                _SPI1_RESETW { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn spi2_reset(&mut self) -> _SPI2_RESETW {
                _SPI2_RESETW { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn spi3_reset(&mut self) -> _SPI3_RESETW {
                _SPI3_RESETW { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn i2s0_reset(&mut self) -> _I2S0_RESETW {
                _I2S0_RESETW { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn i2s1_reset(&mut self) -> _I2S1_RESETW {
                _I2S1_RESETW { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn i2s2_reset(&mut self) -> _I2S2_RESETW {
                _I2S2_RESETW { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn i2c0_reset(&mut self) -> _I2C0_RESETW {
                _I2C0_RESETW { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn i2c1_reset(&mut self) -> _I2C1_RESETW {
                _I2C1_RESETW { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn i2c2_reset(&mut self) -> _I2C2_RESETW {
                _I2C2_RESETW { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn uart1_reset(&mut self) -> _UART1_RESETW {
                _UART1_RESETW { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn uart2_reset(&mut self) -> _UART2_RESETW {
                _UART2_RESETW { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn uart3_reset(&mut self) -> _UART3_RESETW {
                _UART3_RESETW { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn aes_reset(&mut self) -> _AES_RESETW {
                _AES_RESETW { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn fpioa_reset(&mut self) -> _FPIOA_RESETW {
                _FPIOA_RESETW { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn timer0_reset(&mut self) -> _TIMER0_RESETW {
                _TIMER0_RESETW { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn timer1_reset(&mut self) -> _TIMER1_RESETW {
                _TIMER1_RESETW { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn timer2_reset(&mut self) -> _TIMER2_RESETW {
                _TIMER2_RESETW { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn wdt0_reset(&mut self) -> _WDT0_RESETW {
                _WDT0_RESETW { w: self }
            }
            #[doc = "Bit 25"]
            #[inline]
            pub fn wdt1_reset(&mut self) -> _WDT1_RESETW {
                _WDT1_RESETW { w: self }
            }
            #[doc = "Bit 26"]
            #[inline]
            pub fn sha_reset(&mut self) -> _SHA_RESETW {
                _SHA_RESETW { w: self }
            }
            #[doc = "Bit 29"]
            #[inline]
            pub fn rtc_reset(&mut self) -> _RTC_RESETW {
                _RTC_RESETW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 0"]
    pub struct CLK_TH0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 0"]
    pub mod clk_th0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRAM0_GCLKR {
            bits: u8,
        }
        impl SRAM0_GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRAM1_GCLKR {
            bits: u8,
        }
        impl SRAM1_GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AI_GCLKR {
            bits: u8,
        }
        impl AI_GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DVP_GCLKR {
            bits: u8,
        }
        impl DVP_GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ROM_GCLKR {
            bits: u8,
        }
        impl ROM_GCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRAM0_GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRAM0_GCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRAM1_GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRAM1_GCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AI_GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AI_GCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DVP_GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DVP_GCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROM_GCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROM_GCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn sram0_gclk(&self) -> SRAM0_GCLKR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SRAM0_GCLKR { bits }
            }
            #[doc = "Bits 4:7"]
            #[inline]
            pub fn sram1_gclk(&self) -> SRAM1_GCLKR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SRAM1_GCLKR { bits }
            }
            #[doc = "Bits 8:11"]
            #[inline]
            pub fn ai_gclk(&self) -> AI_GCLKR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AI_GCLKR { bits }
            }
            #[doc = "Bits 12:15"]
            #[inline]
            pub fn dvp_gclk(&self) -> DVP_GCLKR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DVP_GCLKR { bits }
            }
            #[doc = "Bits 16:19"]
            #[inline]
            pub fn rom_gclk(&self) -> ROM_GCLKR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ROM_GCLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3"]
            #[inline]
            pub fn sram0_gclk(&mut self) -> _SRAM0_GCLKW {
                _SRAM0_GCLKW { w: self }
            }
            #[doc = "Bits 4:7"]
            #[inline]
            pub fn sram1_gclk(&mut self) -> _SRAM1_GCLKW {
                _SRAM1_GCLKW { w: self }
            }
            #[doc = "Bits 8:11"]
            #[inline]
            pub fn ai_gclk(&mut self) -> _AI_GCLKW {
                _AI_GCLKW { w: self }
            }
            #[doc = "Bits 12:15"]
            #[inline]
            pub fn dvp_gclk(&mut self) -> _DVP_GCLKW {
                _DVP_GCLKW { w: self }
            }
            #[doc = "Bits 16:19"]
            #[inline]
            pub fn rom_gclk(&mut self) -> _ROM_GCLKW {
                _ROM_GCLKW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 1"]
    pub struct CLK_TH1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 1"]
    pub mod clk_th1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_CLKR {
            bits: u8,
        }
        impl SPI0_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_CLKR {
            bits: u8,
        }
        impl SPI1_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI2_CLKR {
            bits: u8,
        }
        impl SPI2_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI3_CLKR {
            bits: u8,
        }
        impl SPI3_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI2_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI3_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn spi0_clk(&self) -> SPI0_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_CLKR { bits }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn spi1_clk(&self) -> SPI1_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_CLKR { bits }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn spi2_clk(&self) -> SPI2_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI2_CLKR { bits }
            }
            #[doc = "Bits 24:31"]
            #[inline]
            pub fn spi3_clk(&self) -> SPI3_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI3_CLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn spi0_clk(&mut self) -> _SPI0_CLKW {
                _SPI0_CLKW { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn spi1_clk(&mut self) -> _SPI1_CLKW {
                _SPI1_CLKW { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn spi2_clk(&mut self) -> _SPI2_CLKW {
                _SPI2_CLKW { w: self }
            }
            #[doc = "Bits 24:31"]
            #[inline]
            pub fn spi3_clk(&mut self) -> _SPI3_CLKW {
                _SPI3_CLKW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 2"]
    pub struct CLK_TH2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 2"]
    pub mod clk_th2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER0_CLKR {
            bits: u8,
        }
        impl TIMER0_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER1_CLKR {
            bits: u8,
        }
        impl TIMER1_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER2_CLKR {
            bits: u8,
        }
        impl TIMER2_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER0_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER0_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER1_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER1_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER2_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER2_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn timer0_clk(&self) -> TIMER0_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIMER0_CLKR { bits }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn timer1_clk(&self) -> TIMER1_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIMER1_CLKR { bits }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn timer2_clk(&self) -> TIMER2_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIMER2_CLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn timer0_clk(&mut self) -> _TIMER0_CLKW {
                _TIMER0_CLKW { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn timer1_clk(&mut self) -> _TIMER1_CLKW {
                _TIMER1_CLKW { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn timer2_clk(&mut self) -> _TIMER2_CLKW {
                _TIMER2_CLKW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 3"]
    pub struct CLK_TH3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 3"]
    pub mod clk_th3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S0_CLKR {
            bits: u16,
        }
        impl I2S0_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S1_CLKR {
            bits: u16,
        }
        impl I2S1_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S0_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S0_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S1_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S1_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15"]
            #[inline]
            pub fn i2s0_clk(&self) -> I2S0_CLKR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                I2S0_CLKR { bits }
            }
            #[doc = "Bits 16:31"]
            #[inline]
            pub fn i2s1_clk(&self) -> I2S1_CLKR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                I2S1_CLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15"]
            #[inline]
            pub fn i2s0_clk(&mut self) -> _I2S0_CLKW {
                _I2S0_CLKW { w: self }
            }
            #[doc = "Bits 16:31"]
            #[inline]
            pub fn i2s1_clk(&mut self) -> _I2S1_CLKW {
                _I2S1_CLKW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 4"]
    pub struct CLK_TH4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 4"]
    pub mod clk_th4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S2_CLKR {
            bits: u16,
        }
        impl I2S2_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S0_MCLKR {
            bits: u8,
        }
        impl I2S0_MCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S1_MCLKR {
            bits: u8,
        }
        impl I2S1_MCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S2_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S2_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S0_MCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S0_MCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S1_MCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S1_MCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15"]
            #[inline]
            pub fn i2s2_clk(&self) -> I2S2_CLKR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                I2S2_CLKR { bits }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn i2s0_mclk(&self) -> I2S0_MCLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2S0_MCLKR { bits }
            }
            #[doc = "Bits 24:31"]
            #[inline]
            pub fn i2s1_mclk(&self) -> I2S1_MCLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2S1_MCLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15"]
            #[inline]
            pub fn i2s2_clk(&mut self) -> _I2S2_CLKW {
                _I2S2_CLKW { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn i2s0_mclk(&mut self) -> _I2S0_MCLKW {
                _I2S0_MCLKW { w: self }
            }
            #[doc = "Bits 24:31"]
            #[inline]
            pub fn i2s1_mclk(&mut self) -> _I2S1_MCLKW {
                _I2S1_MCLKW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 5"]
    pub struct CLK_TH5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 5"]
    pub mod clk_th5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S2_MCLKR {
            bits: u8,
        }
        impl I2S2_MCLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C0_CLKR {
            bits: u8,
        }
        impl I2C0_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C1_CLKR {
            bits: u8,
        }
        impl I2C1_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C2_CLKR {
            bits: u8,
        }
        impl I2C2_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S2_MCLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S2_MCLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C0_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C0_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C1_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C1_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C2_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C2_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn i2s2_mclk(&self) -> I2S2_MCLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2S2_MCLKR { bits }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn i2c0_clk(&self) -> I2C0_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C0_CLKR { bits }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn i2c1_clk(&self) -> I2C1_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C1_CLKR { bits }
            }
            #[doc = "Bits 24:31"]
            #[inline]
            pub fn i2c2_clk(&self) -> I2C2_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C2_CLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn i2s2_mclk(&mut self) -> _I2S2_MCLKW {
                _I2S2_MCLKW { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn i2c0_clk(&mut self) -> _I2C0_CLKW {
                _I2C0_CLKW { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline]
            pub fn i2c1_clk(&mut self) -> _I2C1_CLKW {
                _I2C1_CLKW { w: self }
            }
            #[doc = "Bits 24:31"]
            #[inline]
            pub fn i2c2_clk(&mut self) -> _I2C2_CLKW {
                _I2C2_CLKW { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 6"]
    pub struct CLK_TH6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock threshold controller 6"]
    pub mod clk_th6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLK_TH6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT0_CLKR {
            bits: u8,
        }
        impl WDT0_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT1_CLKR {
            bits: u8,
        }
        impl WDT1_CLKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT0_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT0_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT1_CLKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT1_CLKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn wdt0_clk(&self) -> WDT0_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WDT0_CLKR { bits }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn wdt1_clk(&self) -> WDT1_CLKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WDT1_CLKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7"]
            #[inline]
            pub fn wdt0_clk(&mut self) -> _WDT0_CLKW {
                _WDT0_CLKW { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline]
            pub fn wdt1_clk(&mut self) -> _WDT1_CLKW {
                _WDT1_CLKW { w: self }
            }
        }
    }
    #[doc = "Miscellaneous controller"]
    pub struct MISC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Miscellaneous controller"]
    pub mod misc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MISC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEBUG_SELR {
            bits: u8,
        }
        impl DEBUG_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI_DVP_DATA_ENABLER {
            bits: bool,
        }
        impl SPI_DVP_DATA_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEBUG_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEBUG_SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI_DVP_DATA_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI_DVP_DATA_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5"]
            #[inline]
            pub fn debug_sel(&self) -> DEBUG_SELR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEBUG_SELR { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn spi_dvp_data_enable(&self) -> SPI_DVP_DATA_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI_DVP_DATA_ENABLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5"]
            #[inline]
            pub fn debug_sel(&mut self) -> _DEBUG_SELW {
                _DEBUG_SELW { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn spi_dvp_data_enable(&mut self) -> _SPI_DVP_DATA_ENABLEW {
                _SPI_DVP_DATA_ENABLEW { w: self }
            }
        }
    }
    #[doc = "Peripheral controller"]
    pub struct PERI {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral controller"]
    pub mod peri {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PERI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER0_PAUSER {
            bits: bool,
        }
        impl TIMER0_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER1_PAUSER {
            bits: bool,
        }
        impl TIMER1_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER2_PAUSER {
            bits: bool,
        }
        impl TIMER2_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER3_PAUSER {
            bits: bool,
        }
        impl TIMER3_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER4_PAUSER {
            bits: bool,
        }
        impl TIMER4_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER5_PAUSER {
            bits: bool,
        }
        impl TIMER5_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER6_PAUSER {
            bits: bool,
        }
        impl TIMER6_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER7_PAUSER {
            bits: bool,
        }
        impl TIMER7_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER8_PAUSER {
            bits: bool,
        }
        impl TIMER8_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER9_PAUSER {
            bits: bool,
        }
        impl TIMER9_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER10_PAUSER {
            bits: bool,
        }
        impl TIMER10_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER11_PAUSER {
            bits: bool,
        }
        impl TIMER11_PAUSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_XIP_ENR {
            bits: bool,
        }
        impl SPI0_XIP_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_XIP_ENR {
            bits: bool,
        }
        impl SPI1_XIP_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI2_XIP_ENR {
            bits: bool,
        }
        impl SPI2_XIP_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI3_XIP_ENR {
            bits: bool,
        }
        impl SPI3_XIP_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_CLK_BYPASSR {
            bits: bool,
        }
        impl SPI0_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_CLK_BYPASSR {
            bits: bool,
        }
        impl SPI1_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI2_CLK_BYPASSR {
            bits: bool,
        }
        impl SPI2_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S0_CLK_BYPASSR {
            bits: bool,
        }
        impl I2S0_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S1_CLK_BYPASSR {
            bits: bool,
        }
        impl I2S1_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2S2_CLK_BYPASSR {
            bits: bool,
        }
        impl I2S2_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct JTAG_CLK_BYPASSR {
            bits: bool,
        }
        impl JTAG_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DVP_CLK_BYPASSR {
            bits: bool,
        }
        impl DVP_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEBUG_CLK_BYPASSR {
            bits: bool,
        }
        impl DEBUG_CLK_BYPASSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER0_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER0_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER1_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER1_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER2_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER2_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER3_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER3_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER4_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER4_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER5_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER5_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER6_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER6_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER7_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER7_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER8_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER8_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER9_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER9_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER10_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER10_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER11_PAUSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER11_PAUSEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_XIP_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_XIP_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_XIP_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_XIP_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI2_XIP_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2_XIP_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI3_XIP_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI3_XIP_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI2_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI2_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S0_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S0_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S1_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S1_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2S2_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2S2_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JTAG_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JTAG_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DVP_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DVP_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEBUG_CLK_BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEBUG_CLK_BYPASSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn timer0_pause(&self) -> TIMER0_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER0_PAUSER { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn timer1_pause(&self) -> TIMER1_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER1_PAUSER { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn timer2_pause(&self) -> TIMER2_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER2_PAUSER { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn timer3_pause(&self) -> TIMER3_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER3_PAUSER { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn timer4_pause(&self) -> TIMER4_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER4_PAUSER { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn timer5_pause(&self) -> TIMER5_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER5_PAUSER { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn timer6_pause(&self) -> TIMER6_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER6_PAUSER { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn timer7_pause(&self) -> TIMER7_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER7_PAUSER { bits }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn timer8_pause(&self) -> TIMER8_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER8_PAUSER { bits }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn timer9_pause(&self) -> TIMER9_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER9_PAUSER { bits }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn timer10_pause(&self) -> TIMER10_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER10_PAUSER { bits }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn timer11_pause(&self) -> TIMER11_PAUSER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TIMER11_PAUSER { bits }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn spi0_xip_en(&self) -> SPI0_XIP_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI0_XIP_ENR { bits }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn spi1_xip_en(&self) -> SPI1_XIP_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI1_XIP_ENR { bits }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn spi2_xip_en(&self) -> SPI2_XIP_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI2_XIP_ENR { bits }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn spi3_xip_en(&self) -> SPI3_XIP_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI3_XIP_ENR { bits }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn spi0_clk_bypass(&self) -> SPI0_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI0_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn spi1_clk_bypass(&self) -> SPI1_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI1_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn spi2_clk_bypass(&self) -> SPI2_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SPI2_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn i2s0_clk_bypass(&self) -> I2S0_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S0_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn i2s1_clk_bypass(&self) -> I2S1_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S1_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn i2s2_clk_bypass(&self) -> I2S2_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2S2_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn jtag_clk_bypass(&self) -> JTAG_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                JTAG_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn dvp_clk_bypass(&self) -> DVP_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DVP_CLK_BYPASSR { bits }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn debug_clk_bypass(&self) -> DEBUG_CLK_BYPASSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DEBUG_CLK_BYPASSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn timer0_pause(&mut self) -> _TIMER0_PAUSEW {
                _TIMER0_PAUSEW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn timer1_pause(&mut self) -> _TIMER1_PAUSEW {
                _TIMER1_PAUSEW { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn timer2_pause(&mut self) -> _TIMER2_PAUSEW {
                _TIMER2_PAUSEW { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn timer3_pause(&mut self) -> _TIMER3_PAUSEW {
                _TIMER3_PAUSEW { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn timer4_pause(&mut self) -> _TIMER4_PAUSEW {
                _TIMER4_PAUSEW { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn timer5_pause(&mut self) -> _TIMER5_PAUSEW {
                _TIMER5_PAUSEW { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn timer6_pause(&mut self) -> _TIMER6_PAUSEW {
                _TIMER6_PAUSEW { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn timer7_pause(&mut self) -> _TIMER7_PAUSEW {
                _TIMER7_PAUSEW { w: self }
            }
            #[doc = "Bit 8"]
            #[inline]
            pub fn timer8_pause(&mut self) -> _TIMER8_PAUSEW {
                _TIMER8_PAUSEW { w: self }
            }
            #[doc = "Bit 9"]
            #[inline]
            pub fn timer9_pause(&mut self) -> _TIMER9_PAUSEW {
                _TIMER9_PAUSEW { w: self }
            }
            #[doc = "Bit 10"]
            #[inline]
            pub fn timer10_pause(&mut self) -> _TIMER10_PAUSEW {
                _TIMER10_PAUSEW { w: self }
            }
            #[doc = "Bit 11"]
            #[inline]
            pub fn timer11_pause(&mut self) -> _TIMER11_PAUSEW {
                _TIMER11_PAUSEW { w: self }
            }
            #[doc = "Bit 12"]
            #[inline]
            pub fn spi0_xip_en(&mut self) -> _SPI0_XIP_ENW {
                _SPI0_XIP_ENW { w: self }
            }
            #[doc = "Bit 13"]
            #[inline]
            pub fn spi1_xip_en(&mut self) -> _SPI1_XIP_ENW {
                _SPI1_XIP_ENW { w: self }
            }
            #[doc = "Bit 14"]
            #[inline]
            pub fn spi2_xip_en(&mut self) -> _SPI2_XIP_ENW {
                _SPI2_XIP_ENW { w: self }
            }
            #[doc = "Bit 15"]
            #[inline]
            pub fn spi3_xip_en(&mut self) -> _SPI3_XIP_ENW {
                _SPI3_XIP_ENW { w: self }
            }
            #[doc = "Bit 16"]
            #[inline]
            pub fn spi0_clk_bypass(&mut self) -> _SPI0_CLK_BYPASSW {
                _SPI0_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 17"]
            #[inline]
            pub fn spi1_clk_bypass(&mut self) -> _SPI1_CLK_BYPASSW {
                _SPI1_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 18"]
            #[inline]
            pub fn spi2_clk_bypass(&mut self) -> _SPI2_CLK_BYPASSW {
                _SPI2_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 19"]
            #[inline]
            pub fn i2s0_clk_bypass(&mut self) -> _I2S0_CLK_BYPASSW {
                _I2S0_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 20"]
            #[inline]
            pub fn i2s1_clk_bypass(&mut self) -> _I2S1_CLK_BYPASSW {
                _I2S1_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 21"]
            #[inline]
            pub fn i2s2_clk_bypass(&mut self) -> _I2S2_CLK_BYPASSW {
                _I2S2_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 22"]
            #[inline]
            pub fn jtag_clk_bypass(&mut self) -> _JTAG_CLK_BYPASSW {
                _JTAG_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 23"]
            #[inline]
            pub fn dvp_clk_bypass(&mut self) -> _DVP_CLK_BYPASSW {
                _DVP_CLK_BYPASSW { w: self }
            }
            #[doc = "Bit 24"]
            #[inline]
            pub fn debug_clk_bypass(&mut self) -> _DEBUG_CLK_BYPASSW {
                _DEBUG_CLK_BYPASSW { w: self }
            }
        }
    }
    #[doc = "SPI sleep controller"]
    pub struct SPI_SLEEP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPI sleep controller"]
    pub mod spi_sleep {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SPI_SLEEP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSI0_SLEEPR {
            bits: bool,
        }
        impl SSI0_SLEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSI1_SLEEPR {
            bits: bool,
        }
        impl SSI1_SLEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSI2_SLEEPR {
            bits: bool,
        }
        impl SSI2_SLEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSI3_SLEEPR {
            bits: bool,
        }
        impl SSI3_SLEEPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSI0_SLEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSI0_SLEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSI1_SLEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSI1_SLEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSI2_SLEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSI2_SLEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSI3_SLEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSI3_SLEEPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn ssi0_sleep(&self) -> SSI0_SLEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSI0_SLEEPR { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn ssi1_sleep(&self) -> SSI1_SLEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSI1_SLEEPR { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn ssi2_sleep(&self) -> SSI2_SLEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSI2_SLEEPR { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn ssi3_sleep(&self) -> SSI3_SLEEPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSI3_SLEEPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn ssi0_sleep(&mut self) -> _SSI0_SLEEPW {
                _SSI0_SLEEPW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn ssi1_sleep(&mut self) -> _SSI1_SLEEPW {
                _SSI1_SLEEPW { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn ssi2_sleep(&mut self) -> _SSI2_SLEEPW {
                _SSI2_SLEEPW { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn ssi3_sleep(&mut self) -> _SSI3_SLEEPW {
                _SSI3_SLEEPW { w: self }
            }
        }
    }
    #[doc = "Reset source status"]
    pub struct RESET_STATUS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Reset source status"]
    pub mod reset_status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RESET_STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESET_STS_CLRR {
            bits: bool,
        }
        impl RESET_STS_CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIN_RESET_STSR {
            bits: bool,
        }
        impl PIN_RESET_STSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT0_RESET_STSR {
            bits: bool,
        }
        impl WDT0_RESET_STSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDT1_RESET_STSR {
            bits: bool,
        }
        impl WDT1_RESET_STSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SOFT_RESET_STSR {
            bits: bool,
        }
        impl SOFT_RESET_STSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESET_STS_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESET_STS_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN_RESET_STSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN_RESET_STSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT0_RESET_STSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT0_RESET_STSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDT1_RESET_STSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDT1_RESET_STSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SOFT_RESET_STSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SOFT_RESET_STSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn reset_sts_clr(&self) -> RESET_STS_CLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RESET_STS_CLRR { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin_reset_sts(&self) -> PIN_RESET_STSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PIN_RESET_STSR { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn wdt0_reset_sts(&self) -> WDT0_RESET_STSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDT0_RESET_STSR { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn wdt1_reset_sts(&self) -> WDT1_RESET_STSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDT1_RESET_STSR { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn soft_reset_sts(&self) -> SOFT_RESET_STSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SOFT_RESET_STSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn reset_sts_clr(&mut self) -> _RESET_STS_CLRW {
                _RESET_STS_CLRW { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn pin_reset_sts(&mut self) -> _PIN_RESET_STSW {
                _PIN_RESET_STSW { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn wdt0_reset_sts(&mut self) -> _WDT0_RESET_STSW {
                _WDT0_RESET_STSW { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn wdt1_reset_sts(&mut self) -> _WDT1_RESET_STSW {
                _WDT1_RESET_STSW { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn soft_reset_sts(&mut self) -> _SOFT_RESET_STSW {
                _SOFT_RESET_STSW { w: self }
            }
        }
    }
    #[doc = "DMA handshake selector"]
    pub struct DMA_SEL0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA handshake selector"]
    pub mod dma_sel0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_SEL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `dma_sel0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA_SEL0R {
            #[doc = "undocumented"]
            SSI0_RX_REQ,
            #[doc = "undocumented"]
            SSI0_TX_REQ,
            #[doc = "undocumented"]
            SSI1_RX_REQ,
            #[doc = "undocumented"]
            SSI1_TX_REQ,
            #[doc = "undocumented"]
            SSI2_RX_REQ,
            #[doc = "undocumented"]
            SSI2_TX_REQ,
            #[doc = "undocumented"]
            SSI3_RX_REQ,
            #[doc = "undocumented"]
            SSI3_TX_REQ,
            #[doc = "undocumented"]
            I2C0_RX_REQ,
            #[doc = "undocumented"]
            I2C0_TX_REQ,
            #[doc = "undocumented"]
            I2C1_RX_REQ,
            #[doc = "undocumented"]
            I2C1_TX_REQ,
            #[doc = "undocumented"]
            I2C2_RX_REQ,
            #[doc = "undocumented"]
            I2C2_TX_REQ,
            #[doc = "undocumented"]
            UART1_RX_REQ,
            #[doc = "undocumented"]
            UART1_TX_REQ,
            #[doc = "undocumented"]
            UART2_RX_REQ,
            #[doc = "undocumented"]
            UART2_TX_REQ,
            #[doc = "undocumented"]
            UART3_RX_REQ,
            #[doc = "undocumented"]
            UART3_TX_REQ,
            #[doc = "undocumented"]
            AES_REQ,
            #[doc = "undocumented"]
            SHA_RX_REQ,
            #[doc = "undocumented"]
            AI_RX_REQ,
            #[doc = "undocumented"]
            FFT_RX_REQ,
            #[doc = "undocumented"]
            FFT_TX_REQ,
            #[doc = "undocumented"]
            I2S0_TX_REQ,
            #[doc = "undocumented"]
            I2S0_RX_REQ,
            #[doc = "undocumented"]
            I2S1_TX_REQ,
            #[doc = "undocumented"]
            I2S1_RX_REQ,
            #[doc = "undocumented"]
            I2S2_TX_REQ,
            #[doc = "undocumented"]
            I2S2_RX_REQ,
            #[doc = "undocumented"]
            I2S0_BF_DIR_REQ,
            #[doc = "undocumented"]
            I2S0_BF_VOICE_REQ,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DMA_SEL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DMA_SEL0R::SSI0_RX_REQ => 0,
                    DMA_SEL0R::SSI0_TX_REQ => 0x01,
                    DMA_SEL0R::SSI1_RX_REQ => 0x02,
                    DMA_SEL0R::SSI1_TX_REQ => 0x03,
                    DMA_SEL0R::SSI2_RX_REQ => 0x04,
                    DMA_SEL0R::SSI2_TX_REQ => 0x05,
                    DMA_SEL0R::SSI3_RX_REQ => 0x06,
                    DMA_SEL0R::SSI3_TX_REQ => 0x07,
                    DMA_SEL0R::I2C0_RX_REQ => 0x08,
                    DMA_SEL0R::I2C0_TX_REQ => 0x09,
                    DMA_SEL0R::I2C1_RX_REQ => 0x0a,
                    DMA_SEL0R::I2C1_TX_REQ => 0x0b,
                    DMA_SEL0R::I2C2_RX_REQ => 0x0c,
                    DMA_SEL0R::I2C2_TX_REQ => 0x0d,
                    DMA_SEL0R::UART1_RX_REQ => 0x0e,
                    DMA_SEL0R::UART1_TX_REQ => 0x0f,
                    DMA_SEL0R::UART2_RX_REQ => 0x10,
                    DMA_SEL0R::UART2_TX_REQ => 0x11,
                    DMA_SEL0R::UART3_RX_REQ => 0x12,
                    DMA_SEL0R::UART3_TX_REQ => 0x13,
                    DMA_SEL0R::AES_REQ => 0x14,
                    DMA_SEL0R::SHA_RX_REQ => 0x15,
                    DMA_SEL0R::AI_RX_REQ => 0x16,
                    DMA_SEL0R::FFT_RX_REQ => 0x17,
                    DMA_SEL0R::FFT_TX_REQ => 0x18,
                    DMA_SEL0R::I2S0_TX_REQ => 0x19,
                    DMA_SEL0R::I2S0_RX_REQ => 0x1a,
                    DMA_SEL0R::I2S1_TX_REQ => 0x1b,
                    DMA_SEL0R::I2S1_RX_REQ => 0x1c,
                    DMA_SEL0R::I2S2_TX_REQ => 0x1d,
                    DMA_SEL0R::I2S2_RX_REQ => 0x1e,
                    DMA_SEL0R::I2S0_BF_DIR_REQ => 0x1f,
                    DMA_SEL0R::I2S0_BF_VOICE_REQ => 0x20,
                    DMA_SEL0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DMA_SEL0R {
                match value {
                    0 => DMA_SEL0R::SSI0_RX_REQ,
                    1 => DMA_SEL0R::SSI0_TX_REQ,
                    2 => DMA_SEL0R::SSI1_RX_REQ,
                    3 => DMA_SEL0R::SSI1_TX_REQ,
                    4 => DMA_SEL0R::SSI2_RX_REQ,
                    5 => DMA_SEL0R::SSI2_TX_REQ,
                    6 => DMA_SEL0R::SSI3_RX_REQ,
                    7 => DMA_SEL0R::SSI3_TX_REQ,
                    8 => DMA_SEL0R::I2C0_RX_REQ,
                    9 => DMA_SEL0R::I2C0_TX_REQ,
                    10 => DMA_SEL0R::I2C1_RX_REQ,
                    11 => DMA_SEL0R::I2C1_TX_REQ,
                    12 => DMA_SEL0R::I2C2_RX_REQ,
                    13 => DMA_SEL0R::I2C2_TX_REQ,
                    14 => DMA_SEL0R::UART1_RX_REQ,
                    15 => DMA_SEL0R::UART1_TX_REQ,
                    16 => DMA_SEL0R::UART2_RX_REQ,
                    17 => DMA_SEL0R::UART2_TX_REQ,
                    18 => DMA_SEL0R::UART3_RX_REQ,
                    19 => DMA_SEL0R::UART3_TX_REQ,
                    20 => DMA_SEL0R::AES_REQ,
                    21 => DMA_SEL0R::SHA_RX_REQ,
                    22 => DMA_SEL0R::AI_RX_REQ,
                    23 => DMA_SEL0R::FFT_RX_REQ,
                    24 => DMA_SEL0R::FFT_TX_REQ,
                    25 => DMA_SEL0R::I2S0_TX_REQ,
                    26 => DMA_SEL0R::I2S0_RX_REQ,
                    27 => DMA_SEL0R::I2S1_TX_REQ,
                    28 => DMA_SEL0R::I2S1_RX_REQ,
                    29 => DMA_SEL0R::I2S2_TX_REQ,
                    30 => DMA_SEL0R::I2S2_RX_REQ,
                    31 => DMA_SEL0R::I2S0_BF_DIR_REQ,
                    32 => DMA_SEL0R::I2S0_BF_VOICE_REQ,
                    i => DMA_SEL0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SSI0_RX_REQ`"]
            #[inline]
            pub fn is_ssi0_rx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI0_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI0_TX_REQ`"]
            #[inline]
            pub fn is_ssi0_tx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI0_TX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI1_RX_REQ`"]
            #[inline]
            pub fn is_ssi1_rx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI1_TX_REQ`"]
            #[inline]
            pub fn is_ssi1_tx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI2_RX_REQ`"]
            #[inline]
            pub fn is_ssi2_rx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI2_TX_REQ`"]
            #[inline]
            pub fn is_ssi2_tx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI3_RX_REQ`"]
            #[inline]
            pub fn is_ssi3_rx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI3_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI3_TX_REQ`"]
            #[inline]
            pub fn is_ssi3_tx_req(&self) -> bool {
                *self == DMA_SEL0R::SSI3_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C0_RX_REQ`"]
            #[inline]
            pub fn is_i2c0_rx_req(&self) -> bool {
                *self == DMA_SEL0R::I2C0_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C0_TX_REQ`"]
            #[inline]
            pub fn is_i2c0_tx_req(&self) -> bool {
                *self == DMA_SEL0R::I2C0_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C1_RX_REQ`"]
            #[inline]
            pub fn is_i2c1_rx_req(&self) -> bool {
                *self == DMA_SEL0R::I2C1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C1_TX_REQ`"]
            #[inline]
            pub fn is_i2c1_tx_req(&self) -> bool {
                *self == DMA_SEL0R::I2C1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C2_RX_REQ`"]
            #[inline]
            pub fn is_i2c2_rx_req(&self) -> bool {
                *self == DMA_SEL0R::I2C2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C2_TX_REQ`"]
            #[inline]
            pub fn is_i2c2_tx_req(&self) -> bool {
                *self == DMA_SEL0R::I2C2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `UART1_RX_REQ`"]
            #[inline]
            pub fn is_uart1_rx_req(&self) -> bool {
                *self == DMA_SEL0R::UART1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `UART1_TX_REQ`"]
            #[inline]
            pub fn is_uart1_tx_req(&self) -> bool {
                *self == DMA_SEL0R::UART1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `UART2_RX_REQ`"]
            #[inline]
            pub fn is_uart2_rx_req(&self) -> bool {
                *self == DMA_SEL0R::UART2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `UART2_TX_REQ`"]
            #[inline]
            pub fn is_uart2_tx_req(&self) -> bool {
                *self == DMA_SEL0R::UART2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `UART3_RX_REQ`"]
            #[inline]
            pub fn is_uart3_rx_req(&self) -> bool {
                *self == DMA_SEL0R::UART3_RX_REQ
            }
            #[doc = "Checks if the value of the field is `UART3_TX_REQ`"]
            #[inline]
            pub fn is_uart3_tx_req(&self) -> bool {
                *self == DMA_SEL0R::UART3_TX_REQ
            }
            #[doc = "Checks if the value of the field is `AES_REQ`"]
            #[inline]
            pub fn is_aes_req(&self) -> bool {
                *self == DMA_SEL0R::AES_REQ
            }
            #[doc = "Checks if the value of the field is `SHA_RX_REQ`"]
            #[inline]
            pub fn is_sha_rx_req(&self) -> bool {
                *self == DMA_SEL0R::SHA_RX_REQ
            }
            #[doc = "Checks if the value of the field is `AI_RX_REQ`"]
            #[inline]
            pub fn is_ai_rx_req(&self) -> bool {
                *self == DMA_SEL0R::AI_RX_REQ
            }
            #[doc = "Checks if the value of the field is `FFT_RX_REQ`"]
            #[inline]
            pub fn is_fft_rx_req(&self) -> bool {
                *self == DMA_SEL0R::FFT_RX_REQ
            }
            #[doc = "Checks if the value of the field is `FFT_TX_REQ`"]
            #[inline]
            pub fn is_fft_tx_req(&self) -> bool {
                *self == DMA_SEL0R::FFT_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_TX_REQ`"]
            #[inline]
            pub fn is_i2s0_tx_req(&self) -> bool {
                *self == DMA_SEL0R::I2S0_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_RX_REQ`"]
            #[inline]
            pub fn is_i2s0_rx_req(&self) -> bool {
                *self == DMA_SEL0R::I2S0_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S1_TX_REQ`"]
            #[inline]
            pub fn is_i2s1_tx_req(&self) -> bool {
                *self == DMA_SEL0R::I2S1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S1_RX_REQ`"]
            #[inline]
            pub fn is_i2s1_rx_req(&self) -> bool {
                *self == DMA_SEL0R::I2S1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S2_TX_REQ`"]
            #[inline]
            pub fn is_i2s2_tx_req(&self) -> bool {
                *self == DMA_SEL0R::I2S2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S2_RX_REQ`"]
            #[inline]
            pub fn is_i2s2_rx_req(&self) -> bool {
                *self == DMA_SEL0R::I2S2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_BF_DIR_REQ`"]
            #[inline]
            pub fn is_i2s0_bf_dir_req(&self) -> bool {
                *self == DMA_SEL0R::I2S0_BF_DIR_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_BF_VOICE_REQ`"]
            #[inline]
            pub fn is_i2s0_bf_voice_req(&self) -> bool {
                *self == DMA_SEL0R::I2S0_BF_VOICE_REQ
            }
        }
        #[doc = "Possible values of the field `dma_sel1`"]
        pub type DMA_SEL1R = DMA_SEL0R;
        #[doc = "Possible values of the field `dma_sel2`"]
        pub type DMA_SEL2R = DMA_SEL0R;
        #[doc = "Possible values of the field `dma_sel3`"]
        pub type DMA_SEL3R = DMA_SEL0R;
        #[doc = "Possible values of the field `dma_sel4`"]
        pub type DMA_SEL4R = DMA_SEL0R;
        #[doc = "Values that can be written to the field `dma_sel0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA_SEL0W {
            #[doc = "`0`"]
            SSI0_RX_REQ,
            #[doc = "`1`"]
            SSI0_TX_REQ,
            #[doc = "`10`"]
            SSI1_RX_REQ,
            #[doc = "`11`"]
            SSI1_TX_REQ,
            #[doc = "`100`"]
            SSI2_RX_REQ,
            #[doc = "`101`"]
            SSI2_TX_REQ,
            #[doc = "`110`"]
            SSI3_RX_REQ,
            #[doc = "`111`"]
            SSI3_TX_REQ,
            #[doc = "`1000`"]
            I2C0_RX_REQ,
            #[doc = "`1001`"]
            I2C0_TX_REQ,
            #[doc = "`1010`"]
            I2C1_RX_REQ,
            #[doc = "`1011`"]
            I2C1_TX_REQ,
            #[doc = "`1100`"]
            I2C2_RX_REQ,
            #[doc = "`1101`"]
            I2C2_TX_REQ,
            #[doc = "`1110`"]
            UART1_RX_REQ,
            #[doc = "`1111`"]
            UART1_TX_REQ,
            #[doc = "`10000`"]
            UART2_RX_REQ,
            #[doc = "`10001`"]
            UART2_TX_REQ,
            #[doc = "`10010`"]
            UART3_RX_REQ,
            #[doc = "`10011`"]
            UART3_TX_REQ,
            #[doc = "`10100`"]
            AES_REQ,
            #[doc = "`10101`"]
            SHA_RX_REQ,
            #[doc = "`10110`"]
            AI_RX_REQ,
            #[doc = "`10111`"]
            FFT_RX_REQ,
            #[doc = "`11000`"]
            FFT_TX_REQ,
            #[doc = "`11001`"]
            I2S0_TX_REQ,
            #[doc = "`11010`"]
            I2S0_RX_REQ,
            #[doc = "`11011`"]
            I2S1_TX_REQ,
            #[doc = "`11100`"]
            I2S1_RX_REQ,
            #[doc = "`11101`"]
            I2S2_TX_REQ,
            #[doc = "`11110`"]
            I2S2_RX_REQ,
            #[doc = "`11111`"]
            I2S0_BF_DIR_REQ,
            #[doc = "`100000`"]
            I2S0_BF_VOICE_REQ,
        }
        impl DMA_SEL0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DMA_SEL0W::SSI0_RX_REQ => 0,
                    DMA_SEL0W::SSI0_TX_REQ => 1,
                    DMA_SEL0W::SSI1_RX_REQ => 2,
                    DMA_SEL0W::SSI1_TX_REQ => 3,
                    DMA_SEL0W::SSI2_RX_REQ => 4,
                    DMA_SEL0W::SSI2_TX_REQ => 5,
                    DMA_SEL0W::SSI3_RX_REQ => 6,
                    DMA_SEL0W::SSI3_TX_REQ => 7,
                    DMA_SEL0W::I2C0_RX_REQ => 8,
                    DMA_SEL0W::I2C0_TX_REQ => 9,
                    DMA_SEL0W::I2C1_RX_REQ => 10,
                    DMA_SEL0W::I2C1_TX_REQ => 11,
                    DMA_SEL0W::I2C2_RX_REQ => 12,
                    DMA_SEL0W::I2C2_TX_REQ => 13,
                    DMA_SEL0W::UART1_RX_REQ => 14,
                    DMA_SEL0W::UART1_TX_REQ => 15,
                    DMA_SEL0W::UART2_RX_REQ => 16,
                    DMA_SEL0W::UART2_TX_REQ => 17,
                    DMA_SEL0W::UART3_RX_REQ => 18,
                    DMA_SEL0W::UART3_TX_REQ => 19,
                    DMA_SEL0W::AES_REQ => 20,
                    DMA_SEL0W::SHA_RX_REQ => 21,
                    DMA_SEL0W::AI_RX_REQ => 22,
                    DMA_SEL0W::FFT_RX_REQ => 23,
                    DMA_SEL0W::FFT_TX_REQ => 24,
                    DMA_SEL0W::I2S0_TX_REQ => 25,
                    DMA_SEL0W::I2S0_RX_REQ => 26,
                    DMA_SEL0W::I2S1_TX_REQ => 27,
                    DMA_SEL0W::I2S1_RX_REQ => 28,
                    DMA_SEL0W::I2S2_TX_REQ => 29,
                    DMA_SEL0W::I2S2_RX_REQ => 30,
                    DMA_SEL0W::I2S0_BF_DIR_REQ => 31,
                    DMA_SEL0W::I2S0_BF_VOICE_REQ => 32,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_SEL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SEL0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_SEL0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_VOICE_REQ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `dma_sel1`"]
        pub type DMA_SEL1W = DMA_SEL0W;
        #[doc = r" Proxy"]
        pub struct _DMA_SEL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SEL1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_SEL1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_VOICE_REQ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `dma_sel2`"]
        pub type DMA_SEL2W = DMA_SEL0W;
        #[doc = r" Proxy"]
        pub struct _DMA_SEL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SEL2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_SEL2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_VOICE_REQ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `dma_sel3`"]
        pub type DMA_SEL3W = DMA_SEL0W;
        #[doc = r" Proxy"]
        pub struct _DMA_SEL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SEL3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_SEL3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_VOICE_REQ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `dma_sel4`"]
        pub type DMA_SEL4W = DMA_SEL0W;
        #[doc = r" Proxy"]
        pub struct _DMA_SEL4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SEL4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_SEL4W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL0W::I2S0_BF_VOICE_REQ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5"]
            #[inline]
            pub fn dma_sel0(&self) -> DMA_SEL0R {
                DMA_SEL0R::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:11"]
            #[inline]
            pub fn dma_sel1(&self) -> DMA_SEL1R {
                DMA_SEL1R::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:17"]
            #[inline]
            pub fn dma_sel2(&self) -> DMA_SEL2R {
                DMA_SEL2R::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 18:23"]
            #[inline]
            pub fn dma_sel3(&self) -> DMA_SEL3R {
                DMA_SEL3R::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 24:29"]
            #[inline]
            pub fn dma_sel4(&self) -> DMA_SEL4R {
                DMA_SEL4R::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5"]
            #[inline]
            pub fn dma_sel0(&mut self) -> _DMA_SEL0W {
                _DMA_SEL0W { w: self }
            }
            #[doc = "Bits 6:11"]
            #[inline]
            pub fn dma_sel1(&mut self) -> _DMA_SEL1W {
                _DMA_SEL1W { w: self }
            }
            #[doc = "Bits 12:17"]
            #[inline]
            pub fn dma_sel2(&mut self) -> _DMA_SEL2W {
                _DMA_SEL2W { w: self }
            }
            #[doc = "Bits 18:23"]
            #[inline]
            pub fn dma_sel3(&mut self) -> _DMA_SEL3W {
                _DMA_SEL3W { w: self }
            }
            #[doc = "Bits 24:29"]
            #[inline]
            pub fn dma_sel4(&mut self) -> _DMA_SEL4W {
                _DMA_SEL4W { w: self }
            }
        }
    }
    #[doc = "DMA handshake selector"]
    pub struct DMA_SEL1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA handshake selector"]
    pub mod dma_sel1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_SEL1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `dma_sel5`"]
        pub type DMA_SEL5R = super::dma_sel0::DMA_SEL0R;
        #[doc = "Values that can be written to the field `dma_sel5`"]
        pub type DMA_SEL5W = super::dma_sel0::DMA_SEL0W;
        #[doc = r" Proxy"]
        pub struct _DMA_SEL5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SEL5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DMA_SEL5W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "`0`"]
            #[inline]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(super::dma_sel0::DMA_SEL0W::I2S0_BF_VOICE_REQ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5"]
            #[inline]
            pub fn dma_sel5(&self) -> DMA_SEL5R {
                DMA_SEL5R::_from({
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5"]
            #[inline]
            pub fn dma_sel5(&mut self) -> _DMA_SEL5W {
                _DMA_SEL5W { w: self }
            }
        }
    }
    #[doc = "IO Power Mode Select controller"]
    pub struct POWER_SEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "IO Power Mode Select controller"]
    pub mod power_sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER_SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL0R {
            bits: bool,
        }
        impl POWER_MODE_SEL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL1R {
            bits: bool,
        }
        impl POWER_MODE_SEL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL2R {
            bits: bool,
        }
        impl POWER_MODE_SEL2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL3R {
            bits: bool,
        }
        impl POWER_MODE_SEL3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL4R {
            bits: bool,
        }
        impl POWER_MODE_SEL4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL5R {
            bits: bool,
        }
        impl POWER_MODE_SEL5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL6R {
            bits: bool,
        }
        impl POWER_MODE_SEL6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct POWER_MODE_SEL7R {
            bits: bool,
        }
        impl POWER_MODE_SEL7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWER_MODE_SEL7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWER_MODE_SEL7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn power_mode_sel0(&self) -> POWER_MODE_SEL0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL0R { bits }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn power_mode_sel1(&self) -> POWER_MODE_SEL1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL1R { bits }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn power_mode_sel2(&self) -> POWER_MODE_SEL2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL2R { bits }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn power_mode_sel3(&self) -> POWER_MODE_SEL3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL3R { bits }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn power_mode_sel4(&self) -> POWER_MODE_SEL4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL4R { bits }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn power_mode_sel5(&self) -> POWER_MODE_SEL5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL5R { bits }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn power_mode_sel6(&self) -> POWER_MODE_SEL6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL6R { bits }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn power_mode_sel7(&self) -> POWER_MODE_SEL7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                POWER_MODE_SEL7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0"]
            #[inline]
            pub fn power_mode_sel0(&mut self) -> _POWER_MODE_SEL0W {
                _POWER_MODE_SEL0W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline]
            pub fn power_mode_sel1(&mut self) -> _POWER_MODE_SEL1W {
                _POWER_MODE_SEL1W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline]
            pub fn power_mode_sel2(&mut self) -> _POWER_MODE_SEL2W {
                _POWER_MODE_SEL2W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline]
            pub fn power_mode_sel3(&mut self) -> _POWER_MODE_SEL3W {
                _POWER_MODE_SEL3W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline]
            pub fn power_mode_sel4(&mut self) -> _POWER_MODE_SEL4W {
                _POWER_MODE_SEL4W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline]
            pub fn power_mode_sel5(&mut self) -> _POWER_MODE_SEL5W {
                _POWER_MODE_SEL5W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline]
            pub fn power_mode_sel6(&mut self) -> _POWER_MODE_SEL6W {
                _POWER_MODE_SEL6W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline]
            pub fn power_mode_sel7(&mut self) -> _POWER_MODE_SEL7W {
                _POWER_MODE_SEL7W { w: self }
            }
        }
    }
}
#[doc = "AES Accelerator"]
pub struct AES {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AES {}
impl AES {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const aes::RegisterBlock {
        0x5045_0000 as *const _
    }
}
impl Deref for AES {
    type Target = aes::RegisterBlock;
    fn deref(&self) -> &aes::RegisterBlock {
        unsafe { &*AES::ptr() }
    }
}
#[doc = "AES Accelerator"]
pub mod aes {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - 1st-4th word of key"]
        pub key: [KEY; 4],
        #[doc = "0x10 - Encryption or decryption select"]
        pub encrypt_sel: ENCRYPT_SEL,
        #[doc = "0x14 - AES mode register"]
        pub mode_ctl: MODE_CTL,
        #[doc = "0x18 - Initialisation Vector (96 bit for GCM, 128 bit for CBC)"]
        pub iv: [IV; 4],
        #[doc = "0x28 - Endian control"]
        pub endian: ENDIAN,
        #[doc = "0x2c - Finished status"]
        pub finish: FINISH,
        #[doc = "0x30 - DMA select"]
        pub dma_sel: DMA_SEL,
        #[doc = "0x34 - GCM additional authenticated data count in bytes, minus one"]
        pub aad_num: AAD_NUM,
        _reserved0: [u8; 4usize],
        #[doc = "0x3c - Plaintext/ciphertext input data count in bytes, minus one"]
        pub pc_num: PC_NUM,
        #[doc = "0x40 - Plaintext/ciphertext input data"]
        pub text_data: TEXT_DATA,
        #[doc = "0x44 - Additional authenticated data"]
        pub aad_data: AAD_DATA,
        #[doc = "0x48 - Tag check status"]
        pub tag_chk: TAG_CHK,
        #[doc = "0x4c - Data can input flag"]
        pub data_in_flag: DATA_IN_FLAG,
        #[doc = "0x50 - GCM input tag for comparison with the calculated tag"]
        pub gcm_in_tag: [GCM_IN_TAG; 4],
        #[doc = "0x60 - Plaintext/ciphertext output data"]
        pub out_data: OUT_DATA,
        #[doc = "0x64 - AES module enable"]
        pub en: EN,
        #[doc = "0x68 - Data can output flag"]
        pub data_out_flag: DATA_OUT_FLAG,
        #[doc = "0x6c - Can input tag (when using GCM)"]
        pub tag_in_flag: TAG_IN_FLAG,
        #[doc = "0x70 - Tag clear (a write to this register clears the tag_chk status)"]
        pub tag_clear: TAG_CLEAR,
        #[doc = "0x74 - Computed GCM output tag"]
        pub gcm_out_tag: [GCM_OUT_TAG; 4],
        #[doc = "0x84 - 5th-8th word of key"]
        pub key_ext: [KEY_EXT; 4],
    }
    #[doc = "1st-4th word of key"]
    pub struct KEY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "1st-4th word of key"]
    pub mod key {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::KEY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Encryption or decryption select"]
    pub struct ENCRYPT_SEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Encryption or decryption select"]
    pub mod encrypt_sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENCRYPT_SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `encrypt_sel`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENCRYPT_SELR {
            #[doc = "Sets encryption mode"]
            ENCRYPTION,
            #[doc = "Sets decryption mode"]
            DECRYPTION,
        }
        impl ENCRYPT_SELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENCRYPT_SELR::ENCRYPTION => false,
                    ENCRYPT_SELR::DECRYPTION => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENCRYPT_SELR {
                match value {
                    false => ENCRYPT_SELR::ENCRYPTION,
                    true => ENCRYPT_SELR::DECRYPTION,
                }
            }
            #[doc = "Checks if the value of the field is `ENCRYPTION`"]
            #[inline]
            pub fn is_encryption(&self) -> bool {
                *self == ENCRYPT_SELR::ENCRYPTION
            }
            #[doc = "Checks if the value of the field is `DECRYPTION`"]
            #[inline]
            pub fn is_decryption(&self) -> bool {
                *self == ENCRYPT_SELR::DECRYPTION
            }
        }
        #[doc = "Values that can be written to the field `encrypt_sel`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENCRYPT_SELW {
            #[doc = "Sets encryption mode"]
            ENCRYPTION,
            #[doc = "Sets decryption mode"]
            DECRYPTION,
        }
        impl ENCRYPT_SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENCRYPT_SELW::ENCRYPTION => false,
                    ENCRYPT_SELW::DECRYPTION => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENCRYPT_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENCRYPT_SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENCRYPT_SELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sets encryption mode"]
            #[inline]
            pub fn encryption(self) -> &'a mut W {
                self.variant(ENCRYPT_SELW::ENCRYPTION)
            }
            #[doc = "Sets decryption mode"]
            #[inline]
            pub fn decryption(self) -> &'a mut W {
                self.variant(ENCRYPT_SELW::DECRYPTION)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Select encryption or decryption mode"]
            #[inline]
            pub fn encrypt_sel(&self) -> ENCRYPT_SELR {
                ENCRYPT_SELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Select encryption or decryption mode"]
            #[inline]
            pub fn encrypt_sel(&mut self) -> _ENCRYPT_SELW {
                _ENCRYPT_SELW { w: self }
            }
        }
    }
    #[doc = "AES mode register"]
    pub struct MODE_CTL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AES mode register"]
    pub mod mode_ctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MODE_CTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `cipher_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CIPHER_MODER {
            #[doc = "Electronic Codebook"]
            ECB,
            #[doc = "Cipher Block Chaining"]
            CBC,
            #[doc = "Galois/Counter Mode"]
            GCM,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CIPHER_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CIPHER_MODER::ECB => 0,
                    CIPHER_MODER::CBC => 0x01,
                    CIPHER_MODER::GCM => 0x02,
                    CIPHER_MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CIPHER_MODER {
                match value {
                    0 => CIPHER_MODER::ECB,
                    1 => CIPHER_MODER::CBC,
                    2 => CIPHER_MODER::GCM,
                    i => CIPHER_MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ECB`"]
            #[inline]
            pub fn is_ecb(&self) -> bool {
                *self == CIPHER_MODER::ECB
            }
            #[doc = "Checks if the value of the field is `CBC`"]
            #[inline]
            pub fn is_cbc(&self) -> bool {
                *self == CIPHER_MODER::CBC
            }
            #[doc = "Checks if the value of the field is `GCM`"]
            #[inline]
            pub fn is_gcm(&self) -> bool {
                *self == CIPHER_MODER::GCM
            }
        }
        #[doc = "Possible values of the field `key_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum KEY_MODER {
            #[doc = "AES-128"]
            AES128,
            #[doc = "AES-192"]
            AES192,
            #[doc = "AES-256"]
            AES256,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl KEY_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    KEY_MODER::AES128 => 0,
                    KEY_MODER::AES192 => 0x01,
                    KEY_MODER::AES256 => 0x02,
                    KEY_MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> KEY_MODER {
                match value {
                    0 => KEY_MODER::AES128,
                    1 => KEY_MODER::AES192,
                    2 => KEY_MODER::AES256,
                    i => KEY_MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `AES128`"]
            #[inline]
            pub fn is_aes128(&self) -> bool {
                *self == KEY_MODER::AES128
            }
            #[doc = "Checks if the value of the field is `AES192`"]
            #[inline]
            pub fn is_aes192(&self) -> bool {
                *self == KEY_MODER::AES192
            }
            #[doc = "Checks if the value of the field is `AES256`"]
            #[inline]
            pub fn is_aes256(&self) -> bool {
                *self == KEY_MODER::AES256
            }
        }
        #[doc = "Possible values of the field `key_order`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum KEY_ORDERR {
            #[doc = "Big Endian"]
            BE,
            #[doc = "Little Endian"]
            LE,
        }
        impl KEY_ORDERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    KEY_ORDERR::BE => false,
                    KEY_ORDERR::LE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> KEY_ORDERR {
                match value {
                    false => KEY_ORDERR::BE,
                    true => KEY_ORDERR::LE,
                }
            }
            #[doc = "Checks if the value of the field is `BE`"]
            #[inline]
            pub fn is_be(&self) -> bool {
                *self == KEY_ORDERR::BE
            }
            #[doc = "Checks if the value of the field is `LE`"]
            #[inline]
            pub fn is_le(&self) -> bool {
                *self == KEY_ORDERR::LE
            }
        }
        #[doc = "Possible values of the field `input_order`"]
        pub type INPUT_ORDERR = KEY_ORDERR;
        #[doc = "Possible values of the field `output_order`"]
        pub type OUTPUT_ORDERR = KEY_ORDERR;
        #[doc = "Values that can be written to the field `cipher_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CIPHER_MODEW {
            #[doc = "Electronic Codebook"]
            ECB,
            #[doc = "Cipher Block Chaining"]
            CBC,
            #[doc = "Galois/Counter Mode"]
            GCM,
        }
        impl CIPHER_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CIPHER_MODEW::ECB => 0,
                    CIPHER_MODEW::CBC => 1,
                    CIPHER_MODEW::GCM => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CIPHER_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CIPHER_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CIPHER_MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Electronic Codebook"]
            #[inline]
            pub fn ecb(self) -> &'a mut W {
                self.variant(CIPHER_MODEW::ECB)
            }
            #[doc = "Cipher Block Chaining"]
            #[inline]
            pub fn cbc(self) -> &'a mut W {
                self.variant(CIPHER_MODEW::CBC)
            }
            #[doc = "Galois/Counter Mode"]
            #[inline]
            pub fn gcm(self) -> &'a mut W {
                self.variant(CIPHER_MODEW::GCM)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `key_mode`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum KEY_MODEW {
            #[doc = "AES-128"]
            AES128,
            #[doc = "AES-192"]
            AES192,
            #[doc = "AES-256"]
            AES256,
        }
        impl KEY_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    KEY_MODEW::AES128 => 0,
                    KEY_MODEW::AES192 => 1,
                    KEY_MODEW::AES256 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEY_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEY_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: KEY_MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "AES-128"]
            #[inline]
            pub fn aes128(self) -> &'a mut W {
                self.variant(KEY_MODEW::AES128)
            }
            #[doc = "AES-192"]
            #[inline]
            pub fn aes192(self) -> &'a mut W {
                self.variant(KEY_MODEW::AES192)
            }
            #[doc = "AES-256"]
            #[inline]
            pub fn aes256(self) -> &'a mut W {
                self.variant(KEY_MODEW::AES256)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `key_order`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum KEY_ORDERW {
            #[doc = "Big Endian"]
            BE,
            #[doc = "Little Endian"]
            LE,
        }
        impl KEY_ORDERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    KEY_ORDERW::BE => false,
                    KEY_ORDERW::LE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _KEY_ORDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KEY_ORDERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: KEY_ORDERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Big Endian"]
            #[inline]
            pub fn be(self) -> &'a mut W {
                self.variant(KEY_ORDERW::BE)
            }
            #[doc = "Little Endian"]
            #[inline]
            pub fn le(self) -> &'a mut W {
                self.variant(KEY_ORDERW::LE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `input_order`"]
        pub type INPUT_ORDERW = KEY_ORDERW;
        #[doc = r" Proxy"]
        pub struct _INPUT_ORDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUT_ORDERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INPUT_ORDERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Big Endian"]
            #[inline]
            pub fn be(self) -> &'a mut W {
                self.variant(KEY_ORDERW::BE)
            }
            #[doc = "Little Endian"]
            #[inline]
            pub fn le(self) -> &'a mut W {
                self.variant(KEY_ORDERW::LE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `output_order`"]
        pub type OUTPUT_ORDERW = KEY_ORDERW;
        #[doc = r" Proxy"]
        pub struct _OUTPUT_ORDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTPUT_ORDERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OUTPUT_ORDERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Big Endian"]
            #[inline]
            pub fn be(self) -> &'a mut W {
                self.variant(KEY_ORDERW::BE)
            }
            #[doc = "Little Endian"]
            #[inline]
            pub fn le(self) -> &'a mut W {
                self.variant(KEY_ORDERW::LE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Cipher mode"]
            #[inline]
            pub fn cipher_mode(&self) -> CIPHER_MODER {
                CIPHER_MODER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Key mode"]
            #[inline]
            pub fn key_mode(&self) -> KEY_MODER {
                KEY_MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Input key order"]
            #[inline]
            pub fn key_order(&self) -> KEY_ORDERR {
                KEY_ORDERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Input data order"]
            #[inline]
            pub fn input_order(&self) -> INPUT_ORDERR {
                INPUT_ORDERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Output data order"]
            #[inline]
            pub fn output_order(&self) -> OUTPUT_ORDERR {
                OUTPUT_ORDERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Cipher mode"]
            #[inline]
            pub fn cipher_mode(&mut self) -> _CIPHER_MODEW {
                _CIPHER_MODEW { w: self }
            }
            #[doc = "Bits 3:4 - Key mode"]
            #[inline]
            pub fn key_mode(&mut self) -> _KEY_MODEW {
                _KEY_MODEW { w: self }
            }
            #[doc = "Bit 5 - Input key order"]
            #[inline]
            pub fn key_order(&mut self) -> _KEY_ORDERW {
                _KEY_ORDERW { w: self }
            }
            #[doc = "Bit 7 - Input data order"]
            #[inline]
            pub fn input_order(&mut self) -> _INPUT_ORDERW {
                _INPUT_ORDERW { w: self }
            }
            #[doc = "Bit 9 - Output data order"]
            #[inline]
            pub fn output_order(&mut self) -> _OUTPUT_ORDERW {
                _OUTPUT_ORDERW { w: self }
            }
        }
    }
    #[doc = "Initialisation Vector (96 bit for GCM, 128 bit for CBC)"]
    pub struct IV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Initialisation Vector (96 bit for GCM, 128 bit for CBC)"]
    pub mod iv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Endian control"]
    pub struct ENDIAN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Endian control"]
    pub mod endian {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENDIAN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `endian`"]
        pub type ENDIANR = super::mode_ctl::KEY_ORDERR;
        #[doc = "Values that can be written to the field `endian`"]
        pub type ENDIANW = super::mode_ctl::KEY_ORDERW;
        #[doc = r" Proxy"]
        pub struct _ENDIANW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDIANW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDIANW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Big Endian"]
            #[inline]
            pub fn be(self) -> &'a mut W {
                self.variant(super::mode_ctl::KEY_ORDERW::BE)
            }
            #[doc = "Little Endian"]
            #[inline]
            pub fn le(self) -> &'a mut W {
                self.variant(super::mode_ctl::KEY_ORDERW::LE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Input data endian"]
            #[inline]
            pub fn endian(&self) -> ENDIANR {
                ENDIANR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Input data endian"]
            #[inline]
            pub fn endian(&mut self) -> _ENDIANW {
                _ENDIANW { w: self }
            }
        }
    }
    #[doc = "Finished status"]
    pub struct FINISH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Finished status"]
    pub mod finish {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FINISH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `finish`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FINISHR {
            #[doc = "Operation not finished"]
            NOT_FINISHED,
            #[doc = "Operation finished"]
            FINISHED,
        }
        impl FINISHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FINISHR::NOT_FINISHED => false,
                    FINISHR::FINISHED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FINISHR {
                match value {
                    false => FINISHR::NOT_FINISHED,
                    true => FINISHR::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_FINISHED`"]
            #[inline]
            pub fn is_not_finished(&self) -> bool {
                *self == FINISHR::NOT_FINISHED
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline]
            pub fn is_finished(&self) -> bool {
                *self == FINISHR::FINISHED
            }
        }
        #[doc = "Values that can be written to the field `finish`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FINISHW {
            #[doc = "Operation not finished"]
            NOT_FINISHED,
            #[doc = "Operation finished"]
            FINISHED,
        }
        impl FINISHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FINISHW::NOT_FINISHED => false,
                    FINISHW::FINISHED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FINISHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FINISHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FINISHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Operation not finished"]
            #[inline]
            pub fn not_finished(self) -> &'a mut W {
                self.variant(FINISHW::NOT_FINISHED)
            }
            #[doc = "Operation finished"]
            #[inline]
            pub fn finished(self) -> &'a mut W {
                self.variant(FINISHW::FINISHED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - AES operation finished status"]
            #[inline]
            pub fn finish(&self) -> FINISHR {
                FINISHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - AES operation finished status"]
            #[inline]
            pub fn finish(&mut self) -> _FINISHW {
                _FINISHW { w: self }
            }
        }
    }
    #[doc = "DMA select"]
    pub struct DMA_SEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DMA select"]
    pub mod dma_sel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DMA_SEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DMA_SELR {
            bits: bool,
        }
        impl DMA_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DMA_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DMA_SELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Output to DMA if set, to CPU otherwise"]
            #[inline]
            pub fn dma_sel(&self) -> DMA_SELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DMA_SELR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Output to DMA if set, to CPU otherwise"]
            #[inline]
            pub fn dma_sel(&mut self) -> _DMA_SELW {
                _DMA_SELW { w: self }
            }
        }
    }
    #[doc = "GCM additional authenticated data count in bytes, minus one"]
    pub struct AAD_NUM {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "GCM additional authenticated data count in bytes, minus one"]
    pub mod aad_num {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AAD_NUM {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Plaintext/ciphertext input data count in bytes, minus one"]
    pub struct PC_NUM {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Plaintext/ciphertext input data count in bytes, minus one"]
    pub mod pc_num {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PC_NUM {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Plaintext/ciphertext input data"]
    pub struct TEXT_DATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Plaintext/ciphertext input data"]
    pub mod text_data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TEXT_DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Additional authenticated data"]
    pub struct AAD_DATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Additional authenticated data"]
    pub mod aad_data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::AAD_DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Tag check status"]
    pub struct TAG_CHK {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Tag check status"]
    pub mod tag_chk {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TAG_CHK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `tag_chk`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAG_CHKR {
            #[doc = "Check not finished"]
            BUSY,
            #[doc = "Check failed"]
            FAIL,
            #[doc = "Check success"]
            SUCCESS,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TAG_CHKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TAG_CHKR::BUSY => 0,
                    TAG_CHKR::FAIL => 0x01,
                    TAG_CHKR::SUCCESS => 0x02,
                    TAG_CHKR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TAG_CHKR {
                match value {
                    0 => TAG_CHKR::BUSY,
                    1 => TAG_CHKR::FAIL,
                    2 => TAG_CHKR::SUCCESS,
                    i => TAG_CHKR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline]
            pub fn is_busy(&self) -> bool {
                *self == TAG_CHKR::BUSY
            }
            #[doc = "Checks if the value of the field is `FAIL`"]
            #[inline]
            pub fn is_fail(&self) -> bool {
                *self == TAG_CHKR::FAIL
            }
            #[doc = "Checks if the value of the field is `SUCCESS`"]
            #[inline]
            pub fn is_success(&self) -> bool {
                *self == TAG_CHKR::SUCCESS
            }
        }
        #[doc = "Values that can be written to the field `tag_chk`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TAG_CHKW {
            #[doc = "Check not finished"]
            BUSY,
            #[doc = "Check failed"]
            FAIL,
            #[doc = "Check success"]
            SUCCESS,
        }
        impl TAG_CHKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TAG_CHKW::BUSY => 0,
                    TAG_CHKW::FAIL => 1,
                    TAG_CHKW::SUCCESS => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TAG_CHKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAG_CHKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TAG_CHKW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Check not finished"]
            #[inline]
            pub fn busy(self) -> &'a mut W {
                self.variant(TAG_CHKW::BUSY)
            }
            #[doc = "Check failed"]
            #[inline]
            pub fn fail(self) -> &'a mut W {
                self.variant(TAG_CHKW::FAIL)
            }
            #[doc = "Check success"]
            #[inline]
            pub fn success(self) -> &'a mut W {
                self.variant(TAG_CHKW::SUCCESS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Tag check status"]
            #[inline]
            pub fn tag_chk(&self) -> TAG_CHKR {
                TAG_CHKR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Tag check status"]
            #[inline]
            pub fn tag_chk(&mut self) -> _TAG_CHKW {
                _TAG_CHKW { w: self }
            }
        }
    }
    #[doc = "Data can input flag"]
    pub struct DATA_IN_FLAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data can input flag"]
    pub mod data_in_flag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA_IN_FLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `data_in_flag`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_IN_FLAGR {
            #[doc = "Cannot input"]
            CANNOT_INPUT,
            #[doc = "Can input"]
            CAN_INPUT,
        }
        impl DATA_IN_FLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DATA_IN_FLAGR::CANNOT_INPUT => false,
                    DATA_IN_FLAGR::CAN_INPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DATA_IN_FLAGR {
                match value {
                    false => DATA_IN_FLAGR::CANNOT_INPUT,
                    true => DATA_IN_FLAGR::CAN_INPUT,
                }
            }
            #[doc = "Checks if the value of the field is `CANNOT_INPUT`"]
            #[inline]
            pub fn is_cannot_input(&self) -> bool {
                *self == DATA_IN_FLAGR::CANNOT_INPUT
            }
            #[doc = "Checks if the value of the field is `CAN_INPUT`"]
            #[inline]
            pub fn is_can_input(&self) -> bool {
                *self == DATA_IN_FLAGR::CAN_INPUT
            }
        }
        #[doc = "Values that can be written to the field `data_in_flag`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_IN_FLAGW {
            #[doc = "Cannot input"]
            CANNOT_INPUT,
            #[doc = "Can input"]
            CAN_INPUT,
        }
        impl DATA_IN_FLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DATA_IN_FLAGW::CANNOT_INPUT => false,
                    DATA_IN_FLAGW::CAN_INPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_IN_FLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_IN_FLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DATA_IN_FLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Cannot input"]
            #[inline]
            pub fn cannot_input(self) -> &'a mut W {
                self.variant(DATA_IN_FLAGW::CANNOT_INPUT)
            }
            #[doc = "Can input"]
            #[inline]
            pub fn can_input(self) -> &'a mut W {
                self.variant(DATA_IN_FLAGW::CAN_INPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Data can be written to text_data or aad_data when this flag is set"]
            #[inline]
            pub fn data_in_flag(&self) -> DATA_IN_FLAGR {
                DATA_IN_FLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Data can be written to text_data or aad_data when this flag is set"]
            #[inline]
            pub fn data_in_flag(&mut self) -> _DATA_IN_FLAGW {
                _DATA_IN_FLAGW { w: self }
            }
        }
    }
    #[doc = "GCM input tag for comparison with the calculated tag"]
    pub struct GCM_IN_TAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "GCM input tag for comparison with the calculated tag"]
    pub mod gcm_in_tag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GCM_IN_TAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Plaintext/ciphertext output data"]
    pub struct OUT_DATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Plaintext/ciphertext output data"]
    pub mod out_data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT_DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "AES module enable"]
    pub struct EN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "AES module enable"]
    pub mod en {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `en`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENR {
            #[doc = "Disable module"]
            DISABLE,
            #[doc = "Enable module"]
            ENABLE,
        }
        impl ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENR::DISABLE => false,
                    ENR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENR {
                match value {
                    false => ENR::DISABLE,
                    true => ENR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ENR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == ENR::ENABLE
            }
        }
        #[doc = "Values that can be written to the field `en`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENW {
            #[doc = "Disable module"]
            DISABLE,
            #[doc = "Enable module"]
            ENABLE,
        }
        impl ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENW::DISABLE => false,
                    ENW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable module"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ENW::DISABLE)
            }
            #[doc = "Enable module"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(ENW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - AES module enable"]
            #[inline]
            pub fn en(&self) -> ENR {
                ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - AES module enable"]
            #[inline]
            pub fn en(&mut self) -> _ENW {
                _ENW { w: self }
            }
        }
    }
    #[doc = "Data can output flag"]
    pub struct DATA_OUT_FLAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data can output flag"]
    pub mod data_out_flag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA_OUT_FLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `data_out_flag`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_OUT_FLAGR {
            #[doc = "Data cannot output"]
            CANNOT_OUTPUT,
            #[doc = "Data can output"]
            CAN_OUTPUT,
        }
        impl DATA_OUT_FLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DATA_OUT_FLAGR::CANNOT_OUTPUT => false,
                    DATA_OUT_FLAGR::CAN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DATA_OUT_FLAGR {
                match value {
                    false => DATA_OUT_FLAGR::CANNOT_OUTPUT,
                    true => DATA_OUT_FLAGR::CAN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `CANNOT_OUTPUT`"]
            #[inline]
            pub fn is_cannot_output(&self) -> bool {
                *self == DATA_OUT_FLAGR::CANNOT_OUTPUT
            }
            #[doc = "Checks if the value of the field is `CAN_OUTPUT`"]
            #[inline]
            pub fn is_can_output(&self) -> bool {
                *self == DATA_OUT_FLAGR::CAN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `data_out_flag`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_OUT_FLAGW {
            #[doc = "Data cannot output"]
            CANNOT_OUTPUT,
            #[doc = "Data can output"]
            CAN_OUTPUT,
        }
        impl DATA_OUT_FLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DATA_OUT_FLAGW::CANNOT_OUTPUT => false,
                    DATA_OUT_FLAGW::CAN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA_OUT_FLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA_OUT_FLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DATA_OUT_FLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Data cannot output"]
            #[inline]
            pub fn cannot_output(self) -> &'a mut W {
                self.variant(DATA_OUT_FLAGW::CANNOT_OUTPUT)
            }
            #[doc = "Data can output"]
            #[inline]
            pub fn can_output(self) -> &'a mut W {
                self.variant(DATA_OUT_FLAGW::CAN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Data can be read from out_data when this flag is set"]
            #[inline]
            pub fn data_out_flag(&self) -> DATA_OUT_FLAGR {
                DATA_OUT_FLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Data can be read from out_data when this flag is set"]
            #[inline]
            pub fn data_out_flag(&mut self) -> _DATA_OUT_FLAGW {
                _DATA_OUT_FLAGW { w: self }
            }
        }
    }
    #[doc = "Can input tag (when using GCM)"]
    pub struct TAG_IN_FLAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Can input tag (when using GCM)"]
    pub mod tag_in_flag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TAG_IN_FLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `tag_in_flag`"]
        pub type TAG_IN_FLAGR = super::data_in_flag::DATA_IN_FLAGR;
        #[doc = "Values that can be written to the field `tag_in_flag`"]
        pub type TAG_IN_FLAGW = super::data_in_flag::DATA_IN_FLAGW;
        #[doc = r" Proxy"]
        pub struct _TAG_IN_FLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TAG_IN_FLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TAG_IN_FLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Cannot input"]
            #[inline]
            pub fn cannot_input(self) -> &'a mut W {
                self.variant(super::data_in_flag::DATA_IN_FLAGW::CANNOT_INPUT)
            }
            #[doc = "Can input"]
            #[inline]
            pub fn can_input(self) -> &'a mut W {
                self.variant(super::data_in_flag::DATA_IN_FLAGW::CAN_INPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - GCM tag can be written to gcm_in_tag when this flag is set"]
            #[inline]
            pub fn tag_in_flag(&self) -> TAG_IN_FLAGR {
                TAG_IN_FLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - GCM tag can be written to gcm_in_tag when this flag is set"]
            #[inline]
            pub fn tag_in_flag(&mut self) -> _TAG_IN_FLAGW {
                _TAG_IN_FLAGW { w: self }
            }
        }
    }
    #[doc = "Tag clear (a write to this register clears the tag_chk status)"]
    pub struct TAG_CLEAR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Tag clear (a write to this register clears the tag_chk status)"]
    pub mod tag_clear {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TAG_CLEAR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Computed GCM output tag"]
    pub struct GCM_OUT_TAG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Computed GCM output tag"]
    pub mod gcm_out_tag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GCM_OUT_TAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "5th-8th word of key"]
    pub struct KEY_EXT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "5th-8th word of key"]
    pub mod key_ext {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::KEY_EXT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "Real Time Clock"]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const rtc::RegisterBlock {
        0x5046_0000 as *const _
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    fn deref(&self) -> &rtc::RegisterBlock {
        unsafe { &*RTC::ptr() }
    }
}
#[doc = "Real Time Clock"]
pub mod rtc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Timer date information"]
        pub date: DATE,
        #[doc = "0x04 - Timer time information"]
        pub time: TIME,
        #[doc = "0x08 - Alarm date information"]
        pub alarm_date: ALARM_DATE,
        #[doc = "0x0c - Alarm time information"]
        pub alarm_time: ALARM_TIME,
        #[doc = "0x10 - Timer counter initial value"]
        pub initial_count: INITIAL_COUNT,
        #[doc = "0x14 - Timer counter current value"]
        pub current_count: CURRENT_COUNT,
        #[doc = "0x18 - RTC interrupt settings"]
        pub interrupt_ctrl: INTERRUPT_CTRL,
        #[doc = "0x1c - RTC register settings"]
        pub register_ctrl: REGISTER_CTRL,
        _reserved0: [u8; 8usize],
        #[doc = "0x28 - Timer extended information"]
        pub extended: EXTENDED,
    }
    #[doc = "Timer date information"]
    pub struct DATE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer date information"]
    pub mod date {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WEEKR {
            bits: u8,
        }
        impl WEEKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DAYR {
            bits: u8,
        }
        impl DAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONTHR {
            bits: u8,
        }
        impl MONTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct YEARR {
            bits: u16,
        }
        impl YEARR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WEEKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WEEKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _YEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _YEARW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline]
            pub fn week(&self) -> WEEKR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WEEKR { bits }
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\] or \\[1,30\\] or \\[1,29\\] or \\[1,28\\]"]
            #[inline]
            pub fn day(&self) -> DAYR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DAYR { bits }
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline]
            pub fn month(&self) -> MONTHR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MONTHR { bits }
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline]
            pub fn year(&self) -> YEARR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                YEARR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline]
            pub fn week(&mut self) -> _WEEKW {
                _WEEKW { w: self }
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\] or \\[1,30\\] or \\[1,29\\] or \\[1,28\\]"]
            #[inline]
            pub fn day(&mut self) -> _DAYW {
                _DAYW { w: self }
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline]
            pub fn month(&mut self) -> _MONTHW {
                _MONTHW { w: self }
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline]
            pub fn year(&mut self) -> _YEARW {
                _YEARW { w: self }
            }
        }
    }
    #[doc = "Timer time information"]
    pub struct TIME {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer time information"]
    pub mod time {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TIME {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SECONDR {
            bits: u8,
        }
        impl SECONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MINUTER {
            bits: u8,
        }
        impl MINUTER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HOURR {
            bits: u8,
        }
        impl HOURR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SECONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SECONDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MINUTEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MINUTEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HOURW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HOURW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline]
            pub fn second(&self) -> SECONDR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SECONDR { bits }
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline]
            pub fn minute(&self) -> MINUTER {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MINUTER { bits }
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline]
            pub fn hour(&self) -> HOURR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HOURR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline]
            pub fn second(&mut self) -> _SECONDW {
                _SECONDW { w: self }
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline]
            pub fn minute(&mut self) -> _MINUTEW {
                _MINUTEW { w: self }
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline]
            pub fn hour(&mut self) -> _HOURW {
                _HOURW { w: self }
            }
        }
    }
    #[doc = "Alarm date information"]
    pub struct ALARM_DATE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Alarm date information"]
    pub mod alarm_date {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ALARM_DATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WEEKR {
            bits: u8,
        }
        impl WEEKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DAYR {
            bits: u8,
        }
        impl DAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONTHR {
            bits: u8,
        }
        impl MONTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct YEARR {
            bits: u16,
        }
        impl YEARR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WEEKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WEEKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _YEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _YEARW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline]
            pub fn week(&self) -> WEEKR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WEEKR { bits }
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\] or \\[1,30\\] or \\[1,29\\] or \\[1,28\\]"]
            #[inline]
            pub fn day(&self) -> DAYR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DAYR { bits }
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline]
            pub fn month(&self) -> MONTHR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MONTHR { bits }
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline]
            pub fn year(&self) -> YEARR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                YEARR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline]
            pub fn week(&mut self) -> _WEEKW {
                _WEEKW { w: self }
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\] or \\[1,30\\] or \\[1,29\\] or \\[1,28\\]"]
            #[inline]
            pub fn day(&mut self) -> _DAYW {
                _DAYW { w: self }
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline]
            pub fn month(&mut self) -> _MONTHW {
                _MONTHW { w: self }
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline]
            pub fn year(&mut self) -> _YEARW {
                _YEARW { w: self }
            }
        }
    }
    #[doc = "Alarm time information"]
    pub struct ALARM_TIME {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Alarm time information"]
    pub mod alarm_time {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ALARM_TIME {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SECONDR {
            bits: u8,
        }
        impl SECONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MINUTER {
            bits: u8,
        }
        impl MINUTER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HOURR {
            bits: u8,
        }
        impl HOURR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SECONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SECONDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MINUTEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MINUTEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x3f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HOURW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HOURW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline]
            pub fn second(&self) -> SECONDR {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SECONDR { bits }
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline]
            pub fn minute(&self) -> MINUTER {
                let bits = {
                    const MASK: u8 = 0x3f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MINUTER { bits }
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline]
            pub fn hour(&self) -> HOURR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HOURR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline]
            pub fn second(&mut self) -> _SECONDW {
                _SECONDW { w: self }
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline]
            pub fn minute(&mut self) -> _MINUTEW {
                _MINUTEW { w: self }
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline]
            pub fn hour(&mut self) -> _HOURW {
                _HOURW { w: self }
            }
        }
    }
    #[doc = "Timer counter initial value"]
    pub struct INITIAL_COUNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer counter initial value"]
    pub mod initial_count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INITIAL_COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - RTC counter initial value"]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - RTC counter initial value"]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Timer counter current value"]
    pub struct CURRENT_COUNT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer counter current value"]
    pub mod current_count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CURRENT_COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - RTC counter current value"]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - RTC counter current value"]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "RTC interrupt settings"]
    pub struct INTERRUPT_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC interrupt settings"]
    pub mod interrupt_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTERRUPT_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TICK_ENABLER {
            bits: bool,
        }
        impl TICK_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALARM_ENABLER {
            bits: bool,
        }
        impl ALARM_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TICK_INT_MODER {
            bits: u8,
        }
        impl TICK_INT_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALARM_COMPARE_MASKR {
            bits: u8,
        }
        impl ALARM_COMPARE_MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICK_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICK_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALARM_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALARM_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICK_INT_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICK_INT_MODEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALARM_COMPARE_MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALARM_COMPARE_MASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - TICK_ENABLE"]
            #[inline]
            pub fn tick_enable(&self) -> TICK_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TICK_ENABLER { bits }
            }
            #[doc = "Bit 1 - Alarm interrupt enable"]
            #[inline]
            pub fn alarm_enable(&self) -> ALARM_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ALARM_ENABLER { bits }
            }
            #[doc = "Bits 2:3 - Tick interrupt enable"]
            #[inline]
            pub fn tick_int_mode(&self) -> TICK_INT_MODER {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TICK_INT_MODER { bits }
            }
            #[doc = "Bits 24:31 - Alarm compare mask for interrupt"]
            #[inline]
            pub fn alarm_compare_mask(&self) -> ALARM_COMPARE_MASKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ALARM_COMPARE_MASKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - TICK_ENABLE"]
            #[inline]
            pub fn tick_enable(&mut self) -> _TICK_ENABLEW {
                _TICK_ENABLEW { w: self }
            }
            #[doc = "Bit 1 - Alarm interrupt enable"]
            #[inline]
            pub fn alarm_enable(&mut self) -> _ALARM_ENABLEW {
                _ALARM_ENABLEW { w: self }
            }
            #[doc = "Bits 2:3 - Tick interrupt enable"]
            #[inline]
            pub fn tick_int_mode(&mut self) -> _TICK_INT_MODEW {
                _TICK_INT_MODEW { w: self }
            }
            #[doc = "Bits 24:31 - Alarm compare mask for interrupt"]
            #[inline]
            pub fn alarm_compare_mask(&mut self) -> _ALARM_COMPARE_MASKW {
                _ALARM_COMPARE_MASKW { w: self }
            }
        }
    }
    #[doc = "RTC register settings"]
    pub struct REGISTER_CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RTC register settings"]
    pub mod register_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::REGISTER_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct READ_ENABLER {
            bits: bool,
        }
        impl READ_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WRITE_ENABLER {
            bits: bool,
        }
        impl WRITE_ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIMER_MASKR {
            bits: u8,
        }
        impl TIMER_MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ALARM_MASKR {
            bits: u8,
        }
        impl ALARM_MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct INITIAL_COUNT_MASKR {
            bits: bool,
        }
        impl INITIAL_COUNT_MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTERRUPT_REGISTER_MASKR {
            bits: bool,
        }
        impl INTERRUPT_REGISTER_MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _READ_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READ_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WRITE_ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WRITE_ENABLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMER_MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMER_MASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALARM_MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALARM_MASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INITIAL_COUNT_MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INITIAL_COUNT_MASKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTERRUPT_REGISTER_MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTERRUPT_REGISTER_MASKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RTC timer read enable"]
            #[inline]
            pub fn read_enable(&self) -> READ_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                READ_ENABLER { bits }
            }
            #[doc = "Bit 1 - RTC timer write enable"]
            #[inline]
            pub fn write_enable(&self) -> WRITE_ENABLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WRITE_ENABLER { bits }
            }
            #[doc = "Bits 13:20 - RTC timer mask"]
            #[inline]
            pub fn timer_mask(&self) -> TIMER_MASKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIMER_MASKR { bits }
            }
            #[doc = "Bits 21:28 - RTC alarm mask"]
            #[inline]
            pub fn alarm_mask(&self) -> ALARM_MASKR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ALARM_MASKR { bits }
            }
            #[doc = "Bit 29 - RTC counter initial count value mask"]
            #[inline]
            pub fn initial_count_mask(&self) -> INITIAL_COUNT_MASKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INITIAL_COUNT_MASKR { bits }
            }
            #[doc = "Bit 30 - RTC interrupt register mask"]
            #[inline]
            pub fn interrupt_register_mask(&self) -> INTERRUPT_REGISTER_MASKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                INTERRUPT_REGISTER_MASKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - RTC timer read enable"]
            #[inline]
            pub fn read_enable(&mut self) -> _READ_ENABLEW {
                _READ_ENABLEW { w: self }
            }
            #[doc = "Bit 1 - RTC timer write enable"]
            #[inline]
            pub fn write_enable(&mut self) -> _WRITE_ENABLEW {
                _WRITE_ENABLEW { w: self }
            }
            #[doc = "Bits 13:20 - RTC timer mask"]
            #[inline]
            pub fn timer_mask(&mut self) -> _TIMER_MASKW {
                _TIMER_MASKW { w: self }
            }
            #[doc = "Bits 21:28 - RTC alarm mask"]
            #[inline]
            pub fn alarm_mask(&mut self) -> _ALARM_MASKW {
                _ALARM_MASKW { w: self }
            }
            #[doc = "Bit 29 - RTC counter initial count value mask"]
            #[inline]
            pub fn initial_count_mask(&mut self) -> _INITIAL_COUNT_MASKW {
                _INITIAL_COUNT_MASKW { w: self }
            }
            #[doc = "Bit 30 - RTC interrupt register mask"]
            #[inline]
            pub fn interrupt_register_mask(&mut self) -> _INTERRUPT_REGISTER_MASKW {
                _INTERRUPT_REGISTER_MASKW { w: self }
            }
        }
    }
    #[doc = "Timer extended information"]
    pub struct EXTENDED {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer extended information"]
    pub mod extended {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTENDED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits };
                let mut w = W { bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CENTURYR {
            bits: u8,
        }
        impl CENTURYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `leap_year`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LEAP_YEARR {
            #[doc = "0 is not leap year"]
            NOT_LEAP,
            #[doc = "1 is leap year"]
            LEAP,
        }
        impl LEAP_YEARR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LEAP_YEARR::NOT_LEAP => false,
                    LEAP_YEARR::LEAP => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LEAP_YEARR {
                match value {
                    false => LEAP_YEARR::NOT_LEAP,
                    true => LEAP_YEARR::LEAP,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_LEAP`"]
            #[inline]
            pub fn is_not_leap(&self) -> bool {
                *self == LEAP_YEARR::NOT_LEAP
            }
            #[doc = "Checks if the value of the field is `LEAP`"]
            #[inline]
            pub fn is_leap(&self) -> bool {
                *self == LEAP_YEARR::LEAP
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENTURYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENTURYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `leap_year`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LEAP_YEARW {
            #[doc = "0 is not leap year"]
            NOT_LEAP,
            #[doc = "1 is leap year"]
            LEAP,
        }
        impl LEAP_YEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LEAP_YEARW::NOT_LEAP => false,
                    LEAP_YEARW::LEAP => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEAP_YEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEAP_YEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LEAP_YEARW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "0 is not leap year"]
            #[inline]
            pub fn not_leap(self) -> &'a mut W {
                self.variant(LEAP_YEARW::NOT_LEAP)
            }
            #[doc = "1 is leap year"]
            #[inline]
            pub fn leap(self) -> &'a mut W {
                self.variant(LEAP_YEARW::LEAP)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Century. Range \\[0,31\\]"]
            #[inline]
            pub fn century(&self) -> CENTURYR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CENTURYR { bits }
            }
            #[doc = "Bit 5 - Is leap year. 1 is leap year, 0 is not leap year"]
            #[inline]
            pub fn leap_year(&self) -> LEAP_YEARR {
                LEAP_YEARR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Century. Range \\[0,31\\]"]
            #[inline]
            pub fn century(&mut self) -> _CENTURYW {
                _CENTURYW { w: self }
            }
            #[doc = "Bit 5 - Is leap year. 1 is leap year, 0 is not leap year"]
            #[inline]
            pub fn leap_year(&mut self) -> _LEAP_YEARW {
                _LEAP_YEARW { w: self }
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "CLINT"]
    pub CLINT: CLINT,
    #[doc = "PLIC"]
    pub PLIC: PLIC,
    #[doc = "UARTHS"]
    pub UARTHS: UARTHS,
    #[doc = "GPIOHS"]
    pub GPIOHS: GPIOHS,
    #[doc = "KPU"]
    pub KPU: KPU,
    #[doc = "FFT"]
    pub FFT: FFT,
    #[doc = "DMAC"]
    pub DMAC: DMAC,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "UART3"]
    pub UART3: UART3,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "SPI3"]
    pub SPI3: SPI3,
    #[doc = "I2S0"]
    pub I2S0: I2S0,
    #[doc = "APU"]
    pub APU: APU,
    #[doc = "I2S1"]
    pub I2S1: I2S1,
    #[doc = "I2S2"]
    pub I2S2: I2S2,
    #[doc = "I2C0"]
    pub I2C0: I2C0,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "FPIOA"]
    pub FPIOA: FPIOA,
    #[doc = "SHA256"]
    pub SHA256: SHA256,
    #[doc = "TIMER0"]
    pub TIMER0: TIMER0,
    #[doc = "TIMER1"]
    pub TIMER1: TIMER1,
    #[doc = "TIMER2"]
    pub TIMER2: TIMER2,
    #[doc = "WDT0"]
    pub WDT0: WDT0,
    #[doc = "WDT1"]
    pub WDT1: WDT1,
    #[doc = "OTP"]
    pub OTP: OTP,
    #[doc = "DVP"]
    pub DVP: DVP,
    #[doc = "SYSCTL"]
    pub SYSCTL: SYSCTL,
    #[doc = "AES"]
    pub AES: AES,
    #[doc = "RTC"]
    pub RTC: RTC,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        riscv::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`"]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            CLINT: CLINT {
                _marker: PhantomData,
            },
            PLIC: PLIC {
                _marker: PhantomData,
            },
            UARTHS: UARTHS {
                _marker: PhantomData,
            },
            GPIOHS: GPIOHS {
                _marker: PhantomData,
            },
            KPU: KPU {
                _marker: PhantomData,
            },
            FFT: FFT {
                _marker: PhantomData,
            },
            DMAC: DMAC {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            I2S0: I2S0 {
                _marker: PhantomData,
            },
            APU: APU {
                _marker: PhantomData,
            },
            I2S1: I2S1 {
                _marker: PhantomData,
            },
            I2S2: I2S2 {
                _marker: PhantomData,
            },
            I2C0: I2C0 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            FPIOA: FPIOA {
                _marker: PhantomData,
            },
            SHA256: SHA256 {
                _marker: PhantomData,
            },
            TIMER0: TIMER0 {
                _marker: PhantomData,
            },
            TIMER1: TIMER1 {
                _marker: PhantomData,
            },
            TIMER2: TIMER2 {
                _marker: PhantomData,
            },
            WDT0: WDT0 {
                _marker: PhantomData,
            },
            WDT1: WDT1 {
                _marker: PhantomData,
            },
            OTP: OTP {
                _marker: PhantomData,
            },
            DVP: DVP {
                _marker: PhantomData,
            },
            SYSCTL: SYSCTL {
                _marker: PhantomData,
            },
            AES: AES {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
        }
    }
}
